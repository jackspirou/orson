{*
  UNREVISED. Revised⁻¹ Report on the Algorithmic Language Orson.

  Copyright © 2014 James B. Moen.
  See below for permissions.

  This is a draft of the defining document for the Orson programming language,
  written as a Bracy source file. The command "bracy -q unrevised.cy" compiles
  it to HTML, so you can read it with a browser. We've had fairly good results
  with 12 pt URW Palladio as the browser's default proportional font and 11 pt
  Liberation Mono as its default monospace font.

  This file uses lots of funny Unicode characters. The non-obvious ones appear
  in this table.

    ┌────┬────────┬───────────────────────────────────────────────────────┐
    │ ¢  │ U+00A2 │ Cent sign.                                            │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ Я  │ U+042F │ Cyrillic capital letter ya.                           │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ ⁎  │ U+204E │ Low asterisk.                                         │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ ␣  │ U+2423 │ Open box.                                             │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ ə  │ U+0259 │ Latin small letter schwa.                             │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ ◇  │ U+25C7 │ White diamond.                                        │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ ⬚  │ U+2B1A │ Dotted square.                                        │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ 刅 │ U+5205 │ CJK unified ideograph-5205 "to create; to begin."     │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ 字 │ U+5B57 │ CJK unified ideograph-5B57 "letter, character, word." │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ 木 │ U+6728 │ CJK unified ideograph-6728 "tree, wood, lumber."      │
    ├────┼────────┼───────────────────────────────────────────────────────┤
    │ 狘 │ U+72D8 │ CJK unified ideograph-72D8 "jump."                    │
    └────┴────────┴───────────────────────────────────────────────────────┘

  The symbol for a Skolem type is ə, an upside down and backward lower case e,
  because in logic, Skolem terms eliminate existentially quantified variables,
  which are introduced by ∃, an upside down and backward upper case E.

  The Russian phrase "это письмо?" means "is it a letter?" [duf 1962], and the
  Russian word "письмена" means "characters" or "letters" [smi 1973]. We can't
  read Russian reliably, so maybe these are wrong.

  [duf 1962]  Charles Duff, Dmitri Makaroff. Russian for Beginners. Barnes and
              Noble. New York, New York. 1962. Page 27.

  [smi 1973]  A. I. Smirnitsky.  Russian-English Dictionary.  E. P. Dutton and
              Company. New York, New York. 1973. Page 423.

  We can't read Chinese at all. The meanings of Chinese ideographs used in the
  examples are from Unicode descriptions in Gnome Character Map 2.28.0.
}

{title Unrevised Report on the Algorithmic Language Orson}

{center
  {b Revised{+ −1} Report on the Algorithmic Language Orson}

  James B. Moen
  February 4, 2014}

{center {b Abstract}}

{narrow
 {justify
  {i Orson} is a general purpose programming language, designed for use by
  individuals and small groups.
  Its programs work in two phases, called {i transformation} and {i execution.}
  During the transformation phase, Orson applies {i forms} to produce new
  expressions.
  Forms are similar to macros, but are expressed in a typed, lexically scoped
  applicative language that can perform arbitrary computations.
  During the execution phase, Orson evaluates the expressions that were
  produced during transformation.
  Orson may be implemented so that transformation occurs at compile time, and
  execution occurs at run time.
  This allows writing with forms in an abstract and general way, while still
  producing efficient programs.}}

{justify
  Copyright © 2014 James B. Moen.
  Permission is granted to copy, distribute and/or modify this document under
  the terms of the {c Gnu} Free Documentation License, Version 1.3 or any later
  version published by the Free Software Foundation; with no Invariant
  Sections, no Front-Cover Texts, and no Back-Cover Texts.
  A copy of the {goto gfdl license} is included in the section entitled
  ``{c Gnu} Free Documentation License.''

  This document uses special characters.
  Without proper rendering support, you may see question marks, boxes, or other
  symbols in place of these characters.
  This document must be rendered in a font where a quote `\ "\ ', an italic
  quote `\ {i "}\ ', and two apostrophes `\ {q ''}\ ' all look different.}

{rule}

{center {b Contents}}

{layout
 {row
  {right {goto introduction 0.\ \ }}
  {left Introduction.}}
 {row
  {left \ }
  {layout
   {row
    {left {goto overview 0.1.\ \ }}
    {left Overview.}}
   {row
    {left {goto organization 0.2.\ \ }}
    {left Organization.}}}}

 {row
  {right {goto terminology 1.\ \ }}
  {left Terminology.}}
 {row
  {left \ }
  {layout
   {row
    {left {goto abbreviate 1.1.\ \ }}
    {left Abbreviate.}}
   {row
    {left {goto transform 1.2.\ \ }}
    {left Transform.}}
   {row
    {left {goto execute 1.3.\ \ }}
    {left Execute.}}
   {row
    {left {goto evaluate 1.4.\ \ }}
    {left Evaluate.}}
   {row
    {left {goto constant 1.5.\ \ }}
    {left Constant.}}
   {row
    {left {goto unspecified 1.6.\ \ }}
    {left Unspecified.}}
   {row
    {left {goto undefined 1.7.\ \ }}
    {left Undefined.}}
   {row
    {left {goto errors 1.8.\ \ }}
    {left Error.}}
   {row
    {left {goto limit 1.9.\ \ }}
    {left Limit.}}
   {row
    {left {goto must 1.10.\ \ }}
    {left Must.}}}}

 {row
  {right {goto character 2.\ \ }}
  {left Characters.}}
 {row
  {left \ }
  {layout
   {row
    {left {goto unicode 2.1.\ \ }}
    {left Unicode.}}
   {row
    {left {goto international 2.2.\ \ }}
    {left Internationalization.}}}}

 {row
  {right {goto token 3.\ \ }}
  {left Tokens.}}
 {row
  {left \ }
  {layout
   {row
    {left {goto comment 3.1.\ \ }}
    {left Comment tokens.}}
   {row
    {left {goto nametoken 3.2.\ \ }}
    {left Name tokens.}}
   {row
    {left \ }
    {layout
     {row
      {left {goto plain 3.2.1.\ \ }}
      {left Plain names.}}
     {row
      {left {goto quoted 3.2.2.\ \ }}
      {left Quoted names.}}
     {row
      {left {goto secret 3.2.3.\ \ }}
      {left Secret names.}}
     {row
      {left {goto identical 3.2.4.\ \ }}
      {left Identical names.}}
     {row
      {left {goto unique 3.2.5.\ \ }}
      {left Unique names.}}}}
   {row
    {left {goto inttoken 3.3.\ \ }}
    {left Integer tokens.}}
   {row
    {left {goto realtoken 3.4.\ \ }}
    {left Real tokens.}}
   {row
    {left {goto chartoken 3.5.\ \ }}
    {left Character tokens.}}
   {row
    {left {goto stringtoken 3.6.\ \ }}
    {left String tokens.}}
   {row
    {left {goto slashed 3.7.\ \ }}
    {left Slashed characters.}}
   {row
    {left {goto symboltoken 3.8.\ \ }}
    {left Symbol tokens.}}}}

  {row
   {right {goto type 4.\ \ }}
   {left Types.}}
  {row
   {left \ }
   {layout
    {row
     {left {goto object 4.1.\ \ }}
     {left Objects.}}
    {row
     {left {goto subtype 4.2.\ \ }}
     {left Subtypes.}}
    {row
     {left {goto cotype 4.3.\ \ }}
     {left Cotypes.}}
    {row
     {left {goto compatible 4.4.\ \ }}
     {left Compatibility.}}
    {row
     {left {goto rule 4.5.\ \ }}
     {left Rules.}}
    {row
     {left {goto namepart 4.6.\ \ }}
     {left Names as parts of types.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto missing 4.6.1.\ \ }}
       {left Missing names.}}
      {row
       {left {goto subname 4.6.2.\ \ }}
       {left Subnames.}}
      {row
       {left {goto distinct 4.6.3.\ \ }}
       {left Distinct names.}}}}
    {row
     {left {goto joker 4.7.\ \ }}
     {left Jokers.}}
    {row
     {left {goto typesize 4.8.\ \ }}
     {left Sizes.}}}}

  {row
   {right {goto expression 5.\ \ }}
   {left Expressions.}}
  {row
   {left \ }
   {layout
    {row
     {left {goto sequence 5.1.\ \ }}
     {left Sequences.}}
    {row
     {left {goto subsequence 5.2.\ \ }}
     {left Subsequences.}}
    {row
     {left {goto assignment 5.3.\ \ }}
     {left Assignments.}}
    {row
     {left {goto disjunction 5.4.\ \ }}
     {left Disjunctions.}}
    {row
     {left {goto conjunction 5.5.\ \ }}
     {left Conjunctions.}}
    {row
     {left {goto comparison 5.6.\ \ }}
     {left Comparisons.}}
    {row
     {left {goto sum 5.7.\ \ }}
     {left Sums.}}
    {row
     {left {goto product 5.8.\ \ }}
     {left Products.}}
    {row
     {left {goto term 5.9.\ \ }}
     {left Terms.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto formtype 5.9.1.\ \ }}
       {left Plain form types.}}
      {row
       {left {goto gentype 5.9.2.\ \ }}
       {left Generic form types.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto freedom 5.9.2.1.\ \ }}
         {left Freedom.}}
        {row
         {left {goto replace 5.9.2.2.\ \ \ }}
         {left Replacement.}}
        {row
         {left {goto binder 5.9.2.3.\ \ \ }}
         {left Binders.}}
        {row
         {left {goto skolem 5.9.2.4.\ \ }}
         {left Skolemization.}}
        {row
         {left {goto gentransform 5.9.2.5.\ \ }}
         {left Generic transformation.}}
        {row
         {left {goto genrule 5.9.2.6.\ \ }}
         {left Generic rules.}}
        {row
         {left {goto gensubtype 5.9.2.7.\ \ }}
         {left Generic subtyping.}}
        {row
         {left {goto genmult 5.9.2.8.\ \ }}
         {left Multiple generic names.}}}}
      {row
       {left {goto pointer 5.9.3.\ \ }}
       {left Pointer types.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto ref 5.9.3.1.\ \ }}
         {left {i Ref} types.}}
        {row
         {left {goto row 5.9.3.2.\ \ }}
         {left {i Row} types.}}
        {row
         {left {goto circular 5.9.3.3.\ \ }}
         {left Circular pointer types.}}}}
      {row
       {left {goto proctype 5.9.4.\ \ }}
       {left Procedure types.}}
      {row
       {left {goto typetype 5.9.5.\ \ }}
       {left Type types.}}
      {row
       {left {goto vartype 5.9.6.\ \ }}
       {left Variable types.}}}}
    {row
     {left {goto unit 5.10.\ \ }}
     {left Units.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto call 5.10.1.\ \ }}
       {left Calls.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto forward 5.10.1.1.\ \ }}
         {left Forwarding.}}
        {row
         {left {goto subsume 5.10.1.2.\ \ }}
         {left Subsumption.}}}}
      {row
       {left {goto clause 5.10.2.\ \ }}
       {left Clauses.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto altclause 5.10.2.1.\ \ }}
         {left {i Alt} clauses.}}
        {row
         {left {goto altsclause 5.10.2.2.\ \ }}
         {left {i Alts} clauses.}}
        {row
         {left {goto caseclause 5.10.2.3.\ \ }}
         {left {i Case} clauses.}}
        {row
         {left {goto catchclause 5.10.2.4.\ \ }}
         {left {i Catch} clauses.}}
        {row
         {left {goto expclause 5.10.2.5.\ \ }}
         {left Expression clauses.}}
        {row
         {left {goto forclause 5.10.2.6.\ \ }}
         {left {i For} clauses.}}
        {row
         {left {goto formclause 5.10.2.7.\ \ }}
         {left {i Form} clauses.}}
        {row
         {left {goto genclause 5.10.2.8.\ \ }}
         {left {i Gen} clauses.}}
        {row
         {left {goto ifclause 5.10.2.9.\ \ }}
         {left {i If} clauses.}}
        {row
         {left {goto listclause 5.10.2.10.\ \ }}
         {left List clauses.}}
        {row
         {left {goto pastclause 5.10.2.11.\ \ }}
         {left {i Past} clauses.}}
        {row
         {left {goto procclause 5.10.2.12.\ \ }}
         {left {i Proc} clauses.}}
        {row
         {left {goto tupleclause 5.10.2.13.\ \ }}
         {left {i Tuple} clauses.}}
        {row
         {left {goto whileclause 5.10.2.14.\ \ }}
         {left {i While} clauses.}}
        {row
         {left {goto withclause 5.10.2.15.\ \ }}
         {left {i With} clauses.}}}}
      {row
       {left {goto hook 5.10.3.\ \ }}
       {left Hooks.}}
      {row
       {left {goto literal 5.10.4.\ \ }}
       {left Literals.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto charlit 5.10.4.1.\ \ }}
         {left Character literals.}}
        {row
         {left {goto intlit 5.10.4.2.\ \ }}
         {left Integer literals.}}
        {row
         {left {goto reallit 5.10.4.3.\ \ }}
         {left Real literals.}}
        {row
         {left {goto stringlit 5.10.4.4.\ \ }}
         {left String literals.}}}}
      {row
       {left {goto nameunit 5.10.5.\ \ }}
       {left Names.}}
      {row
       {left \ }
       {layout
        {row
         {left {goto bind 5.10.5.1.\ \ }}
         {left Bindings.}}
        {row
         {left {goto scope 5.10.5.2.\ \ }}
         {left Scopes.}}
        {row
         {left {goto nest 5.10.5.3.\ \ }}
         {left Nesting.}}
        {row
         {left {goto inherit 5.10.5.4.\ \ }}
         {left Inheritance.}}
        {row
         {left {goto shadow 5.10.5.5.\ \ }}
         {left Shadowing.}}
        {row
         {left {goto capture 5.10.5.6.\ \ }}
         {left Capture.}}
        {row
         {left {goto closure 5.10.5.7.\ \ }}
         {left Closure.}}}}
      {row
       {left {goto symbol 5.10.6.\ \ }}
       {left Symbol types.}}}}}}

  {row
   {right {goto program 6.\ \ }}
   {left Programs.}}
  {row
   {left \ }
   {layout
    {row
     {left {goto progclause 6.1.\ \ }}
     {left {i Prog} clauses.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto progsecret 6.1.1.\ \ }}
       {left Secret objects.}}
      {row
       {left {goto abstract 6.1.2.\ \ }}
       {left Abstract data structures.}}}}
    {row
     {left {goto loadclause 6.2.\ \ }}
     {left {i Load} clauses.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto pathname 6.2.1.\ \ }}
       {left Pathnames.}}
      {row
       {left {goto prefix 6.2.2.\ \ }}
       {left Prefixes.}}
      {row
       {left {goto suffix 6.2.3.\ \ }}
       {left Suffixes.}}}}}}

  {row
   {right {goto prelude 7.\ \ }}
   {left Preludes.}}
  {row
   {left \ }
   {layout
    {row
     {left {goto stdtype 7.1.\ \ }}
     {left Standard simple types.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto bool 7.1.1.\ \ }}
       {left {i bool,} {i false,} and {i true.}}}
      {row
       {left {goto char 7.1.2.\ \ }}
       {left {i char,} {i char}0, and {i char}1.}}
      {row
       {left {goto int 7.1.3.\ \ }}
       {left {i int,} {i int}0, {i int}1, and {i int}2.}}
      {row
       {left {goto list 7.1.4.\ \ }}
       {left {i list.}}}
      {row
       {left {goto null 7.1.5.\ \ }}
       {left {i null} and {i nil.}}}
      {row
       {left {goto real 7.1.6.\ \ }}
       {left {i real,} {i real}0, and {i real}1.}}
      {row
       {left {goto stream 7.1.7.\ \ }}
       {left {i stream} and {i eos.}}}
      {row
       {left {goto string 7.1.8.\ \ }}
       {left {i string} and ϵ.}}
      {row
       {left {goto void 7.1.9.\ \ }}
       {left {i void} and {i skip.}}}}}
    {row
     {left {goto stdjoker 7.2.\ \ }}
     {left Standard joker types.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto alj 7.2.1.\ \ }}
       {left {i alj.}}}
      {row
       {left {goto cha 7.2.2.\ \ }}
       {left {i cha.}}}
      {row
       {left {goto exe 7.2.3.\ \ }}
       {left {i exe.}}}
      {row
       {left {goto foj 7.2.4.\ \ }}
       {left {i foj.}}}
      {row
       {left {goto gej 7.2.5.\ \ }}
       {left {i gej.}}}
      {row
       {left {goto inj 7.2.6.\ \ }}
       {left {i inj.}}}
      {row
       {left {goto met 7.2.7.\ \ }}
       {left {i met.}}}
      {row
       {left {goto mut 7.2.8.\ \ }}
       {left {i mut.}}}
      {row
       {left {goto num 7.2.9.\ \ }}
       {left {i num.}}}
      {row
       {left {goto obj 7.2.10.\ \ }}
       {left {i obj.}}}
      {row
       {left {goto plj 7.2.11.\ \ }}
       {left {i plj.}}}
      {row
       {left {goto pro 7.2.12.\ \ }}
       {left {i pro.}}}
      {row
       {left {goto rej 7.2.13.\ \ }}
       {left {i rej.}}}
      {row
       {left {goto sca 7.2.14.\ \ }}
       {left {i sca.}}}
      {row
       {left {goto str 7.2.15.\ \ }}
       {left {i str.}}}
      {row
       {left {goto sym 7.2.16.\ \ }}
       {left {i sym.}}}
      {row
       {left {goto tup 7.2.17.\ \ }}
       {left {i tup.}}}}}
    {row
     {left {goto stdform 7.3.\ \ }}
     {left Standard forms.}}
    {row
     {left \ }
     {layout
      {row
       {left {goto postbracket 7.3.1.\ \ }}
       {left {i "}␣[]{i ".}}}
      {row
       {left {goto postbrace 7.3.2.\ \ }}
       {left {i "}␣\{\}{i ".}}}
      {row
       {left {goto ampersand 7.3.3.\ \ }}
       {left {i "}&{i ".}}}
      {row
       {left {goto ampequal 7.3.4.\ \ }}
       {left {i "}&={i ".}}}
      {row
       {left {goto star 7.3.5.\ \ }}
       {left {i "}⁎{i "} and {i "}×{i ".}}}
      {row
       {left {goto starequal 7.3.6.\ \ }}
       {left {i "}⁎={i "} and {i "}×={i ".}}}
      {row
       {left {goto plus 7.3.7.\ \ }}
       {left {i "}+{i ".}}}
      {row
       {left {goto plusequal 7.3.8.\ \ }}
       {left {i "}+={i ".}}}
      {row
       {left {goto dash 7.3.9.\ \ }}
       {left {i "}-{i "} and {i "}−{i ".}}}
      {row
       {left {goto dashequal 7.3.10.\ \ }}
       {left {i "}-={i "} and {i "}−={i ".}}}
      {row
       {left {goto dot 7.3.11.\ \ }}
       {left {i {i "}}.{i ".}}}
      {row
       {left {goto slash 7.3.12.\ \ }}
       {left {i "}/{i ".}}}
      {row
       {left {goto slashequal 7.3.13.\ \ }}
       {left {i "}/={i ".}}}
      {row
       {left {goto colonequal 7.3.14.\ \ }}
       {left {i "}:={i ".}}}
      {row
       {left {goto lt 7.3.15.\ \ }}
       {left {i "}<{i ".}}}
      {row
       {left {goto ltlt 7.3.16.\ \ }}
       {left {i "}<␣<{i ".}}}
      {row
       {left {goto ltle 7.3.17.\ \ }}
       {left {i "}<␣<={i "} and {i "}<␣≤{i ".}}}
      {row
       {left {goto left 7.3.18.\ \ }}
       {left {i "}<<{i "} and {i "}←{i ".}}}
      {row
       {left {goto leftequal 7.3.19.\ \ }}
       {left {i "}<<={i "} and {i "}←={i ".}}}
      {row
       {left {goto le 7.3.20.\ \ }}
       {left {i "}<={i "} and {i "}≤{i ".}}}
      {row
       {left {goto lelt 7.3.21.\ \ }}
       {left {i "}<=␣<{i "} and {i "}≤␣<{i ".}}}
      {row
       {left {goto lele 7.3.22.\ \ }}
       {left {i "}<=␣<={i "} and {i "}≤␣≤{i ".}}}
      {row
       {left {goto ne 7.3.23.\ \ }}
       {left {i "}<>{i "} and {i "}≠{i ".}}}
      {row
       {left {goto eq 7.3.24.\ \ }}
       {left {i "}={i ".}}}
      {row
       {left {goto gt 7.3.25.\ \ }}
       {left {i "}>{i ".}}}
      {row
       {left {goto gtgt 7.3.26.\ \ }}
       {left {i "}>␣>{i ".}}}
      {row
       {left {goto gtge 7.3.27.\ \ }}
       {left {i "}>␣>={i "} and {i "}>␣≥{i ".}}}
      {row
       {left {goto right 7.3.28.\ \ }}
       {left {i "}>>{i "} and {i "}→{i ".}}}
      {row
       {left {goto rightequal 7.3.29.\ \ }}
       {left {i "}>>={i "} and {i "}→={i ".}}}
      {row
       {left {goto ge 7.3.30.\ \ }}
       {left {i "}>={i "} and {i "}≥{i ".}}}
      {row
       {left {goto gegt 7.3.31.\ \ }}
       {left {i "}>=␣>{i "} and {i "}≥␣>{i ".}}}
      {row
       {left {goto gege 7.3.32.\ \ }}
       {left {i "}>=␣>={i "} and {i "}≥␣≥{i ".}}}
      {row
       {left {goto at 7.3.33.\ \ }}
       {left {i "}@{i "} and {i "}↓{i ".}}}
      {row
       {left {goto prebracket 7.3.34.\ \ }}
       {left {i "}[]␣{i ".}}}
      {row
       {left {goto uparrow 7.3.35.\ \ }}
       {left {i "}{q ^}{i "} and {i "}↑{i ".}}}
      {row
       {left {goto bar 7.3.36.\ \ }}
       {left {i "}|{i ".}}}
      {row
       {left {goto barequal 7.3.37.\ \ }}
       {left {i "}|={i ".}}}
      {row
       {left {goto tilde 7.3.38.\ \ }}
       {left {i "}~{i ".}}}
      {row
       {left {goto tildeequal 7.3.39.\ \ }}
       {left {i "}~={i ".}}}
      {row
       {left {goto catch 7.3.40.\ \ }}
       {left {i "}catch{i ".}}}
      {row
       {left {goto for 7.3.41.\ \ }}
       {left {i "}for{i ".}}}
      {row
       {left {goto mod 7.3.42.\ \ }}
       {left {i "}mod{i ".}}}
      {row
       {left {goto not 7.3.43.\ \ }}
       {left {i "}not{i "} and {i "}¬{i ".}}}
      {row
       {left {goto abs 7.3.44.\ \ }}
       {left {i abs.}}}
      {row
       {left {goto align 7.3.45.\ \ }}
       {left {i align.}}}
      {row
       {left {goto argc 7.3.46.\ \ }}
       {left {i argc} and {i argv.}}}
      {row
       {left {goto base 7.3.47.\ \ }}
       {left {i base.}}}
      {row
       {left {goto car 7.3.48.\ \ }}
       {left {i car.}}}
      {row
       {left {goto cdr 7.3.49.\ \ }}
       {left {i cdr.}}}
      {row
       {left {goto comp 7.3.50.\ \ }}
       {left {i comp.}}}
      {row
       {left {goto conc 7.3.51.\ \ }}
       {left {i conc.}}}
      {row
       {left {goto cons 7.3.52.\ \ }}
       {left {i cons.}}}
      {row
       {left {goto count 7.3.53.\ \ }}
       {left {i count.}}}
      {row
       {left {goto devar 7.3.54.\ \ }}
       {left {i devar.}}}
      {row
       {left {goto enum 7.3.55.\ \ }}
       {left {i enum.}}}
      {row
       {left {goto error 7.3.56.\ \ }}
       {left {i error and goat.}}}
      {row
       {left \ }
       {layout
        {row
         {left {goto errconst 7.3.56.1.\ \ }}
         {left Error constants.}}
        {row
         {left {goto errpos 7.3.56.2.\ \ }}
         {left Error positions.}}
        {row
         {left {goto scapegoat 7.3.56.3.\ \ }}
         {left Scapegoat lists.}}}}
      {row
       {left {goto except 7.3.57.\ \ }}
       {left {i except.}}}
      {row
       {left {goto exit 7.3.58.\ \ }}
       {left {i exit.}}}
      {row
       {left {goto flatten 7.3.59.\ \ }}
       {left {i flatten.}}}
      {row
       {left {goto halt 7.3.60.\ \ }}
       {left {i halt.}}}
      {row
       {left {goto high 7.3.61.\ \ }}
       {left {i high.}}}
      {row
       {left {goto ischar 7.3.62.\ \ }}
       {left {i isChar.}}}
      {row
       {left {goto iscotype 7.3.63.\ \ }}
       {left {i isCotype} and {i "}⊑{i ".}}}
      {row
       {left {goto isempty 7.3.64.\ \ }}
       {left {i isEmpty.}}}
      {row
       {left {goto iserror 7.3.65.\ \ }}
       {left {i isError.}}}
      {row
       {left {goto isint 7.3.66.\ \ }}
       {left {i isInt.}}}
      {row
       {left {goto isjoked 7.3.67.\ \ }}
       {left {i isJoked.}}}
      {row
       {left {goto isnil 7.3.68.\ \ }}
       {left {i isNull.}}}
      {row
       {left {goto isreal 7.3.69.\ \ }}
       {left {i isReal.}}}
      {row
       {left {goto isskol 7.3.70.\ \ }}
       {left {i isSkolem.}}}
      {row
       {left {goto isstring 7.3.71.\ \ }}
       {left {i isString.}}}
      {row
       {left {goto issubsumed 7.3.72.\ \ }}
       {left {i isSubsumed} and {i "}≼{i ".}}}
      {row
       {left {goto issubtype 7.3.73.\ \ }}
       {left {i isSubtype} and {i "}⊆{i ".}}}
      {row
       {left {goto length 7.3.74.\ \ }}
       {left {i length.}}}
      {row
       {left {goto low 7.3.75.\ \ }}
       {left {i low.}}}
      {row
       {left {goto max 7.3.76.\ \ }}
       {left {i max.}}}
      {row
       {left {goto min 7.3.77.\ \ }}
       {left {i min.}}}
      {row
       {left {goto offset 7.3.78.\ \ }}
       {left {i offset.}}}
      {row
       {left {goto refs 7.3.79.\ \ }}
       {left {i refs.}}}
      {row
       {left {goto rethrow 7.3.80.\ \ }}
       {left {i rethrow.}}}
      {row
       {left {goto size 7.3.81.\ \ }}
       {left {i size.}}}
      {row
       {left {goto slot 7.3.82.\ \ }}
       {left {i slot.}}}
      {row
       {left {goto sort 7.3.83.\ \ }}
       {left {i sort.}}}
      {row
       {left {goto throw 7.3.84.\ \ }}
       {left {i throw.}}}
      {row
       {left {goto thrown 7.3.85.\ \ }}
       {left {i thrown.}}}
      {row
       {left {goto version 7.3.86.\ \ }}
       {left {i version.}}}}}}}

  {row
   {right {goto syntax 8.\ \ }}
   {left Syntax.}}
  {row
   {left \ }
   {layout
    {row
     {left {goto charsyntax 8.1.\ \ }}
     {left Characters.}}
    {row
     {left {goto tokensyntax 8.2.\ \ }}
     {left Tokens.}}
    {row
     {left {goto expsyntax 8.3.\ \ }}
     {left Expressions.}}
    {row
     {left {goto progsyntax 8.4.\ \ }}
     {left Programs.}}
    {row
     {left {goto semicolon 8.5.\ \ }}
     {left Semicolons.}}}}

 {row
  {right {goto reference 9.\ \ }}
  {left References.}}

 {row
  {right {goto colophon 10.\ \ }}
  {left Colophon.}}

 {row
  {left \ }
  {left \ }}}

{rule}

{label introduction}
{left {b 0. Introduction.}}

{narrow
 {justify
   This is willy-nilly the age of teamwork.
   In another generation [...] cybernation will have advanced far enough that
   the solitary genius will come back into fashion—provided he can get a
   grant large enough to supply him with the battalions of self-programming
   computers he will need.}
 {right {goto dis1969 {c [dis 1969]}}}}

{justify
  {i Orson} is a general purpose programming language.
  It is intended for programmers who work alone, or in small informal groups.
  As a result, it omits complex mechanisms for hiding and sharing information,
  like classes, modules, and packages.
  Orson emphasizes efficiency, expressiveness, and extensibility instead of
  safety.
  However, it still allows writing programs that are both modular and safe.

  Orson's design investigates an alternative to object-oriented programming
  {goto sal1998 {c [sal 1998].}}
  It has been influenced by the designs of many other programming languages,
  including
  Algol 68    {goto vwi1977 {c [vwi 1977],}}
  C           {goto ker1988 {c [ker 1988],}}
  {c Clu}     {goto lis1981 {c [lis 1981],}}
  Common Lisp {goto ste1990 {c [ste 1990],}}
  Pascal      {goto jen1974 {c [jen 1974],}} and
  Scheme      {goto spe2007 {c [spe 2007].}}
  It may be significant that no languages of recent origin appear in this list.

  The name {i Orson} is not an acronym, so it does not properly appear in upper
  case letters.
  (If it was an acronym, then it might be Objects Require Some Other Notions.)
  Orson is not named after any person, place, or thing.}

{label overview}
{left {b 0.1. Overview.}}

{justify
  Orson programs are made up of {i expressions} that are {i evaluated} to
  return {i objects} and to perform {i side effects.}
  Objects are data to be manipulated.
  Side effects are changes to those objects.
  Each expression is evaluated in two phases: first {i transformation,} then
  {i execution.}

  During transformation, Orson appears to be a high-level, lexically scoped,
  applicative language like Scheme {goto spe2007 {c [spe 2007],}} but with an
  algebraic syntax and an explicit type system.
  When an expression is transformed, it returns a constant object or another
  expression.
  It also returns a {i type} that describes the object or expression.
  Depending on its type, the object or expression may be used in other
  transformations, and may also be executed later.

  Expressions are transformed primarily by applying {i forms.}
  Forms are similar to the {i macros} of languages like C
  {goto ker1988 {c [ker 1988]}} and Common Lisp {goto ste1990 {c [ste 1990].}}
  However, forms differ from these macros in the following ways.}

{bullet
 {justify
   Forms use the same notation as the rest of Orson.}
 {justify
   Forms operate on expressions, not strings that denote expressions.}
 {justify
   Forms are lexically scoped.}
 {justify
   Forms transform their arguments when they are applied.}
 {justify
   Forms obey the rules of Orson's type system.}
 {justify
   Forms can be applied recursively.}
 {justify
   Forms can automatically inherit the behavior of other forms.}}

{justify
  Because of these differences, forms can perform computations with constant
  objects during transformation.
  Forms can often be used as more efficient substitutes for procedures.
  Most operators are implemented as forms, so they can be redefined.
  Abstract data types can be implemented as forms that take types as arguments,
  and return types as results.
  Abstract control structures can be implemented as forms that take forms as
  arguments, and return forms as results.

  During execution, Orson appears to be a low-level, lexically scoped,
  imperative language like C, but with the same syntax and type system used
  during transformation.
  When an expression that results from transformation is executed, it returns
  an object, and may also perform side effects.
  For efficiency, it is possible to manipulate the internal representation of
  such an object.

  Orson's transformation phase can affect its execution phase, but its
  execution phase cannot affect its transformation phase.
  As a result, an Orson compiler can be implemented so that it performs all
  transformations at compile time, and all executions at run time.
  This allows writing with forms in an abstract, high-level way, while still
  producing efficient, low-level programs.}

{label organization}
{left {b 0.2. Organization.}}

{justify
  This Report is not a tutorial.
  The reader is assumed to be familiar with at least one modern programming
  language.
  Some familiarity with formal models of type systems
  {goto car1997 {c [car 1997]}} is also helpful.

  The name of a concept is usually {i italicized} where it is defined.
  Although formal notation is used to describe forms and types, most concepts
  are described in English.
  Examples are used only to clarify potentially unfamiliar concepts.
  If a concept is described without using examples, then it is like similar
  concepts in other languages.
  
  Most of this Report is divided into sections that correspond to Orson's
  syntax.
  Although this is convenient for finding information on a specific topic, it
  is less convenient for reading the Report from start to finish, since early
  sections often refer to later ones.
  To make the Report easier to read, it is written in {c html}
  {goto pow2001 {c [pow 2001],}} where the first reference in each section to
  another section appears as a link.
  This lets the reader enter the Report at any point and follow links whenever
  unfamiliar concepts are mentioned.
  It is regretted if this makes reading the Report like traversing a maze, as
  in the classic computer game {i Adventure} {goto lev1984 {c [lev 1984].}}}

{rule}

{label terminology}
{left {b 1. Terminology.}}

{narrow
 {justify
   What do I mean by the word mean?
   What do I mean by the word word, what do I mean by what do I mean, what do I
   mean by do, and what do I do by mean?}
 {right {goto cha1989 {c [cha 1989]}}}}

{justify
  Much of this Report describes how {goto expression expressions} are
  {goto evaluate evaluated} by being {goto transform transformed} and then
  {goto execute executed.}
  The next few sections define words and phrases that have special meanings in
  these descriptions.}

{label abbreviate}
{left {b 1.1. Abbreviate.}}

{justify
  A phrase like {i A is an abbreviation for B} means that whenever an
  {goto expression} {i A} appears, it is automatically replaced by another
  (usually longer) expression {i B.}
  Unless stated otherwise, {i A} is {goto evaluate evaluated} in exactly the
  same way as {i B.}
  This Report may use abbreviation to define some expressions in terms of
  others.
  Also, when the meaning is clear from context, this Report may use the
  expression {i A} to mean the expression {i B} that it abbreviates.}

{label transform}
{left {b 1.2. Transform.}}

{justify
  A phrase like {i A transforms to B and T} means that when an
  {goto expression} {i A} is transformed, it returns a new expression or
  {goto object} {i B,} and its {goto type} {i T.}
  If {i T} is uninteresting, or is obvious from context, then it is not
  mentioned.
  When the meaning is clear from context, this Report may use the expression
  {i A} to mean the expression or object {i B} to which it transforms.

  Sometimes explaining how an expression is transformed will completely
  describe it.
  This might be because the expression transforms to a
  {goto constant constant,} or because it transforms to an expression that is
  described elsewhere in the Report.}

{label execute}
{left {b 1.3. Execute.}}

{justify
  If an {goto expression} {i B} results from {goto transform transforming}
  another expression, then a phrase like {i B executes to O} means that when
  {i B} is executed, it returns the {goto object} {i O.}
  If an expression {i A} does not result from transforming another expression,
  then a phrase like {i A executes to O} means that {i A} first transforms to
  an uninteresting expression {i B,} which is not mentioned, and then {i B}
  executes to {i O.}
  When the meaning is clear from context, this Report may use the expression
  {i A} or {i B} to mean the object {i O} to which it executes.}

{label evaluate}
{left {b 1.4. Evaluate.}}

{justify
  A phrase like {i A evaluates to O and T} means that an {goto expression}
  {i A} first {goto transform transforms} to a new expression {i B,} and then
  {i B} {goto execute executes} to a {goto object} {i O,} whose type is
  {i T.}
  It may also mean that an expression {i A} transforms directly to a
  {goto constant} {i O,} whose type is {i T.}
  In either case, if {i B} and {i T} are uninteresting, or are obvious from
  context, then they are not mentioned.
  When the meaning is clear from context, this Report may use the expression
  {i A} to mean the object {i O} to which it evaluates.}

{label constant}
{left {b 1.5. Constant.}}

{justify
  A {i constant} is an {goto object} that exists only during
  {goto transform transformation,} or an object that transforms to itself.
  It is often important to determine if an object is a constant, because Orson
  can perform computations with constants during transformation.}

{label unspecified}
{left {b 1.6. Unspecified.}}

{justify
  If a situation is {i unspecified,} then an Orson program can respond to it in
  any way, provided that the response has harmless results.
  A phrase like {i an unspecified object of type T} means an arbitrarily chosen
  {goto object} whose {goto type} is {i T.}
  Correct Orson programs may create unspecified situations and unspecified
  objects.
  However, programs that do so might not be portable from one implementation of
  Orson to another.}

{label undefined}
{left {b 1.7. Undefined.}}

{justify
  If a situation is {i undefined,} then an Orson program can respond to it in
  any way, even if the response has harmful results.
  Correct Orson programs {goto must} not create undefined situations.
  Programs that do so might not be portable from one implementation of Orson to
  another.}

{label errors}
{left {b 1.8. Error.}}

{justify
  If a situation {i is an error,} or {i causes an error,} then no correct Orson
  program will allow it to occur.
  If the situation occurs during {goto transform transformation,} then Orson
  will {i report} the error in an {goto unspecified} way, perhaps by displaying
  a message.
  Orson will then {i recover} from the error, also in an unspecified way, so
  that transformation can continue.
  If the situation occurs during {goto execute execution,} then the results are
  {goto undefined undefined,} so that Orson need not report the error, and it
  need not recover from the error.}

{label limit}
{left {b 1.9. Limit.}}

{justify
  A phrase like {i there is a limit on the number of X's} means that it is an
  {goto errors error} for an Orson program to create a situation involving more
  than an {goto unspecified} maximum number of {i X}'s.
  A phrase like {i there may be a limit on the number of X's} has the same
  meaning, but also suggests that this limit is large enough to be effectively
  infinite.
  Limits may vary from one implementation of Orson to another, but they should
  be as large as possible.}

{label must}
{left {b 1.10. Must.}}

{justify
  If a situation {i must} occur, then it is an {goto errors error} if it does
  not occur.
  Words like {i can,} {i may,} {i might,} and {i should} have their usual
  meanings, and are not synonyms for {i must.}}

{rule}

{label character}
{left {b 2. Characters.}}

{narrow
 {justify
   I’ve found that I can be intrigued with characters without necessarily
   liking them.}
 {right {goto hem1999 {c [hem 1999]}}}}

{justify
  An Orson program resides on a series of one or more {i files.}
  Each file is a series of zero or more {i lines.}
  A line is a series of zero or more visible {i characters,} and ends with an
  invisible {goto unspecified} {i newline} character.
  A {goto blank} is considered to be a visible character.
  Except for newlines, invisible characters (like control characters and tabs)
  {goto must} not appear in Orson programs.
  There may be {goto limit limits} on the number of files in a program, the
  number of characters in a file, the number of lines in a file, and the number
  of characters in a line.}

{label unicode}
{left {b 2.1. Unicode.}}

{justify
  Orson uses a 31-bit character set that is a superset of the 21-bit Unicode
  character set {goto uni2006 {c [uni 2006].}}
  Unicode, in turn, is a superset of the 7-bit {c ascii} character set
  {goto ans1986 {c [ans 1986].}}
  Unicode specifies a nonnegative integer {i code} and an official {i name} for
  each of its characters.
  Codes are written as `U+' followed by four or more hexadecimal digits.
  Unicode does not specify visual representations, called {i glyphs,} for its
  characters.

  Orson uses the visible Unicode characters in the following table.
  The table shows a suggested glyph for each character, its code, and its
  official name.
  It also shows an unofficial name used by this Report, if it differs from the
  official name.
  For example, the glyph `α' stands for the character whose code is U+03B1,
  whose official name is {c greek small letter alpha,} and whose unofficial
  name is {i Mathematical letter.}}

{table
 {row
  {center \ {b Glyph}\ }
  {center \ {b Code}\ }
  {center \ {b Official Name}\ }
  {center \ {b Unofficial Name}\ }}
 {row
  {center {label blank} ␣}
  {center U+0020}
  {left \ {c space}\ }
  {left \ {i Blank}\ }}
 {row
  {center {label exclamation} !}
  {center U+0021}
  {left \ {c exclamation mark}\ }
  {left \ }}
 {row
  {center {label quote} {i "}}
  {center U+0022}
  {left \ {c quotation mark}\ }
  {left \ {i Quote}\ }}
 {row
  {center {label sharp} #}
  {center U+0023}
  {left \ {c number sign}\ }
  {left \ {i Sharp}\ }}
 {row
  {center {label dollar} $}
  {center U+0024}
  {left \ {c dollar sign}\ }
  {left \ }}
 {row
  {center &}
  {center U+0026}
  {left \ {c ampersand}\ }
  {left \ }}
 {row
  {center {label apostrophe} {q '}}
  {center U+0027}
  {left \ {c apostrophe}\ }
  {left \ }}
 {row
  {center {label paren} (}
  {center U+0028}
  {left \ {c left parenthesis}\ }
  {left \ }}
 {row
  {center )}
  {center U+0029}
  {left \ {c right parenthesis}\ }
  {left \ }}
 {row
  {center ⁎}
  {center U+002A}
  {left \ {c asterisk}\ }
  {left \ }}
 {row
  {center +}
  {center U+002B}
  {left \ {c plus sign}\ }
  {left \ {i Sign}}}
 {row
  {center ,}
  {center U+002C}
  {left \ {c comma}\ }
  {left \ }}
 {row
  {center -}
  {center U+002D}
  {left \ {c hyphen-minus}\ }
  {left \ {i Sign}}}
 {row
  {center {label dotchar} .}
  {center U+002E}
  {left \ {c full stop}\ }
  {left \ {i Dot}\ }}
 {row
  {center /}
  {center U+002F}
  {left \ {c solidus}\ }
  {left \ }}
 {row
  {center {label digit} 0}
  {center U+0030}
  {left \ {c digit zero}\ }
  {left \ {i Digit}\ }}
 {row
  {center 1}
  {center U+0031}
  {left \ {c digit one}\ }
  {left \ {i Digit}\ }}
 {row
  {center 2}
  {center U+0032}
  {left \ {c digit two}\ }
  {left \ {i Digit}\ }}
 {row
  {center 3}
  {center U+0033}
  {left \ {c digit three}\ }
  {left \ {i Digit}\ }}
 {row
  {center 4}
  {center U+0034}
  {left \ {c digit four}\ }
  {left \ {i Digit}\ }}
 {row
  {center 5}
  {center U+0035}
  {left \ {c digit five}\ }
  {left \ {i Digit}\ }}
 {row
  {center 6}
  {center U+0036}
  {left \ {c digit six}\ }
  {left \ {i Digit}\ }}
 {row
  {center 7}
  {center U+0037}
  {left \ {c digit seven}\ }
  {left \ {i Digit}\ }}
 {row
  {center 8}
  {center U+0038}
  {left \ {c digit eight}\ }
  {left \ {i Digit}\ }}
 {row
  {center 9}
  {center U+0039}
  {left \ {c digit nine}\ }
  {left \ {i Digit}\ }}
 {row
  {center {label colon} :}
  {center U+003A}
  {left \ {c colon}\ }
  {left \ }}
 {row
  {center ;}
  {center U+003B}
  {left \ {c semicolon}\ }
  {left \ }}
 {row
  {center <}
  {center U+003C}
  {left \ {c less-than sign}\ }
  {left \ }}
 {row
  {center =}
  {center U+003D}
  {left \ {c equals sign}\ }
  {left \ }}
 {row
  {center >}
  {center U+003E}
  {left \ {c greater-than sign}\ }
  {left \ }}
 {row
  {center {label question} ?}
  {center U+003F}
  {left \ {c question mark}\ }
  {left \ }}
 {row
  {center @}
  {center U+0040}
  {left \ {c commercial at}\ }
  {left \ }}
 {row
  {center {label upper} A}
  {center U+0041}
  {left \ {c latin capital letter a}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center B}
  {center U+0042}
  {left \ {c latin capital letter b}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center C}
  {center U+0043}
  {left \ {c latin capital letter c}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center D}
  {center U+0044}
  {left \ {c latin capital letter d}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center E}
  {center U+0045}
  {left \ {c latin capital letter e}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center F}
  {center U+0046}
  {left \ {c latin capital letter f}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center G}
  {center U+0047}
  {left \ {c latin capital letter g}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center H}
  {center U+0048}
  {left \ {c latin capital letter h}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center I}
  {center U+0049}
  {left \ {c latin capital letter i}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center J}
  {center U+004A}
  {left \ {c latin capital letter j}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center K}
  {center U+004B}
  {left \ {c latin capital letter k}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center L}
  {center U+004C}
  {left \ {c latin capital letter l}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center M}
  {center U+004D}
  {left \ {c latin capital letter m}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center N}
  {center U+004E}
  {left \ {c latin capital letter n}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center O}
  {center U+004F}
  {left \ {c latin capital letter o}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center P}
  {center U+0050}
  {left \ {c latin capital letter p}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center Q}
  {center U+0051}
  {left \ {c latin capital letter q}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center R}
  {center U+0052}
  {left \ {c latin capital letter r}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center S}
  {center U+0053}
  {left \ {c latin capital letter s}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center T}
  {center U+0054}
  {left \ {c latin capital letter t}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center U}
  {center U+0055}
  {left \ {c latin capital letter u}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center V}
  {center U+0056}
  {left \ {c latin capital letter v}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center W}
  {center U+0057}
  {left \ {c latin capital letter w}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center X}
  {center U+0058}
  {left \ {c latin capital letter x}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center Y}
  {center U+0059}
  {left \ {c latin capital letter y}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center Z}
  {center U+005A}
  {left \ {c latin capital letter z}\ }
  {left \ {i Upper case Roman letter}\ }}
 {row
  {center {label bracket} [}
  {center U+005B}
  {left \ {c left square bracket}\ }
  {left \ }}
 {row
  {center {label backslash} \\}
  {center U+005C}
  {left \ {c reverse solidus}\ }
  {left \ {i Backslash}\ }}
 {row
  {center ]}
  {center U+005D}
  {left \ {c right square bracket}\ }
  {left \ }}
 {row
  {center {q ^}}
  {center U+005E}
  {left \ {c circumflex accent}\ }
  {left \ }}
 {row
  {center {label underline} _}
  {center U+005F}
  {left \ {c low line}\ }
  {left \ {i Underline}\ }}
 {row
  {center {label lower} a}
  {center U+0061}
  {left \ {c latin small letter a}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center b}
  {center U+0062}
  {left \ {c latin small letter b}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center c}
  {center U+0063}
  {left \ {c latin small letter c}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center d}
  {center U+0064}
  {left \ {c latin small letter d}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center e}
  {center U+0065}
  {left \ {c latin small letter e}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center f}
  {center U+0066}
  {left \ {c latin small letter f}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center g}
  {center U+0067}
  {left \ {c latin small letter g}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center h}
  {center U+0068}
  {left \ {c latin small letter h}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center i}
  {center U+0069}
  {left \ {c latin small letter i}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center j}
  {center U+006A}
  {left \ {c latin small letter j}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center k}
  {center U+006B}
  {left \ {c latin small letter k}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center l}
  {center U+006C}
  {left \ {c latin small letter l}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center m}
  {center U+006D}
  {left \ {c latin small letter m}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center n}
  {center U+006E}
  {left \ {c latin small letter n}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center o}
  {center U+006F}
  {left \ {c latin small letter o}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center p}
  {center U+0070}
  {left \ {c latin small letter p}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center q}
  {center U+0071}
  {left \ {c latin small letter q}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center r}
  {center U+0072}
  {left \ {c latin small letter r}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center s}
  {center U+0073}
  {left \ {c latin small letter s}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center t}
  {center U+0074}
  {left \ {c latin small letter t}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center u}
  {center U+0075}
  {left \ {c latin small letter u}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center v}
  {center U+0076}
  {left \ {c latin small letter v}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center w}
  {center U+0077}
  {left \ {c latin small letter w}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center x}
  {center U+0078}
  {left \ {c latin small letter x}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center y}
  {center U+0079}
  {left \ {c latin small letter y}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center z}
  {center U+007A}
  {left \ {c latin small letter z}\ }
  {left \ {i Lower case Roman letter}\ }}
 {row
  {center {label brace} \{}
  {center U+007B}
  {left \ {c left curly bracket}\ }
  {left \ {i Open brace}\ }}
 {row
  {center |}
  {center U+007C}
  {left \ {c vertical line}\ }
  {left \ }}
 {row
  {center \}}
  {center U+007D}
  {left \ {c right curly bracket}\ } 
 {left \ {i Close brace}\ }}
 {row
  {center ~}
  {center U+007E}
  {left \ {c tilde}\ }
  {left \ }}
 {row
  {center ¬}
  {center U+00AC}
  {left \ {c not sign}\ }
  {left \ }}
 {row
  {center ×}
  {center U+00D7}
  {left \ {c multiplication sign}\ }
  {left \ }}
 {row
  {center Γ}
  {center U+0393}
  {left \ {c greek capital letter gamma}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Δ}
  {center U+0394}
  {left \ {c greek capital letter delta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Θ}
  {center U+0398}
  {left \ {c greek capital letter theta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Λ}
  {center U+039B}
  {left \ {c greek capital letter lamda} [{i sic}]\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Ξ}
  {center U+039E}
  {left \ {c greek capital letter xi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Π}
  {center U+03A0}
  {left \ {c greek capital letter pi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Σ}
  {center U+03A3}
  {left \ {c greek capital letter sigma}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Φ}
  {center U+03A6}
  {left \ {c greek capital letter phi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Ψ}
  {center U+03A8}
  {left \ {c greek capital letter psi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center Ω}
  {center U+03A9}
  {left \ {c greek capital letter omega}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center α}
  {center U+03B1}
  {left \ {c greek small letter alpha}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center β}
  {center U+03B2}
  {left \ {c greek small letter beta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center γ}
  {center U+03B3}
  {left \ {c greek small letter gamma}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center δ}
  {center U+03B4}
  {left \ {c greek small letter delta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ε}
  {center U+03B5}
  {left \ {c greek small letter epsilon}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ζ}
  {center U+03B6}
  {left \ {c greek small letter zeta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center η}
  {center U+03B7}
  {left \ {c greek small letter eta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center θ}
  {center U+03B8}
  {left \ {c greek small letter theta}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ι}
  {center U+03B9}
  {left \ {c greek small letter iota}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center κ}
  {center U+03BA}
  {left \ {c greek small letter kappa}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center λ}
  {center U+03BB}
  {left \ {c greek small letter lamda} [{i sic}]\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center μ}
  {center U+03BC}
  {left \ {c greek small letter mu}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ν}
  {center U+03BD}
  {left \ {c greek small letter nu}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ξ}
  {center U+03BE}
  {left \ {c greek small letter xi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center π}
  {center U+03C0}
  {left \ {c greek small letter pi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ρ}
  {center U+03C1}
  {left \ {c greek small letter rho}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ς}
  {center U+03C2}
  {left \ {c greek small letter final sigma}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center σ}
  {center U+03C3}
  {left \ {c greek small letter sigma}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center τ}
  {center U+03C4}
  {left \ {c greek small letter tau}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center υ}
  {center U+03C5}
  {left \ {c greek small letter upsilon}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center φ}
  {center U+03C6}
  {left \ {c greek small letter phi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center χ}
  {center U+03C7}
  {left \ {c greek small letter chi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ψ}
  {center U+03C8}
  {left \ {c greek small letter psi}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ω}
  {center U+03C9}
  {left \ {c greek small letter omega}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϑ}
  {center U+03D1}
  {left \ {c greek theta symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϒ}
  {center U+03D2}
  {left \ {c greek upsilon with hook symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϕ}
  {center U+03D5}
  {left \ {c greek phi symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϖ}
  {center U+03D6}
  {left \ {c greek pi symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϱ}
  {center U+03F1}
  {left \ {c greek rho symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ϵ}
  {center U+03F5}
  {left \ {c greek lunate epsilon symbol}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center {label subscript} ₀}
  {center U+2080}
  {left \ {c subscript zero}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₁}
  {center U+2081}
  {left \ {c subscript one}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₂}
  {center U+2082}
  {left \ {c subscript two}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₃}
  {center U+2083}
  {left \ {c subscript three}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₄}
  {center U+2084}
  {left \ {c subscript four}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₅}
  {center U+2085}
  {left \ {c subscript five}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₆}
  {center U+2086}
  {left \ {c subscript six}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₇}
  {center U+2087}
  {left \ {c subscript seven}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₈}
  {center U+2088}
  {left \ {c subscript eight}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ₉}
  {center U+2089}
  {left \ {c subscript nine}\ }
  {left \ {i Subscript}\ }}
 {row
  {center ←}
  {center U+2090}
  {left \ {c leftwards arrow}\ }
  {left \ }}
 {row
  {center ↑}
  {center U+2191}
  {left \ {c upwards arrow}\ }
  {left \ }}
 {row
  {center →}
  {center U+2192}
  {left \ {c rightwards arrow}\ }
  {left \ }}
 {row
  {center ↓}
  {center U+2193}
  {left \ {c downwards arrow}\ }
  {left \ }}
 {row
  {center ∀}
  {center U+2200}
  {left \ {c for all}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ∃}
  {center U+2203}
  {left \ {c there exists}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ∅}
  {center U+2205}
  {left \ {c empty set}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ∊}
  {center U+220A}
  {left \ {c small element of}\ }
  {left \ }}
 {row
  {center ∍}
  {center U+220D}
  {left \ {c small contains as member}\ }
  {left \ }}
 {row
  {center −}
  {center U+2212}
  {left \ {c minus sign}\ }
  {left \ {i Sign}\ }}
 {row
  {center ∘}
  {center U+2218}
  {left \ {c ring operator}\ }
  {left \ }}
 {row
  {center ∞}
  {center U+221E}
  {left \ {c infinity}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ∧}
  {center U+2227}
  {left \ {c logical and}\ }
  {left \ }}
 {row
  {center ∨}
  {center U+2228}
  {left \ {c logical or}\ }
  {left \ }}
 {row
  {center ∩}
  {center U+2229}
  {left \ {c intersection}\ }
  {left \ }}
 {row
  {center ∪}
  {center U+222A}
  {left \ {c union}\ }
  {left \ }}
 {row
  {center ≠}
  {center U+2260}
  {left \ {c not equal to}\ }
  {left \ }}
 {row
  {center ≡}
  {center U+2261}
  {left \ {c identical to}\ }
  {left \ }}
 {row
  {center ≢}
  {center U+2262}
  {left \ {c not identical to}\ }
  {left \ }}
 {row
  {center ≤}
  {center U+2264}
  {left \ {c less-than or equal to}\ }
  {left \ }}
 {row
  {center ≥}
  {center U+2265}
  {left \ {c greater-than or equal to}\ }
  {left \ }}
 {row
  {center ≺}
  {center U+227A}
  {left \ {c precedes}\ }
  {left \ }}
 {row
  {center ≻}
  {center U+227B}
  {left \ {c succeeds}\ }
  {left \ }}
 {row
  {center ≼}
  {center U+227C}
  {left \ {c precedes or equal to}\ }
  {left \ }}
 {row
  {center ≽}
  {center U+227D}
  {left \ {c succeeds or equal to}\ }
  {left \ }}
 {row
  {center ⊂}
  {center U+2282}
  {left \ {c subset of}\ }
  {left \ }}
 {row
  {center ⊃}
  {center U+2283}
  {left \ {c superset of}\ }
  {left \ }}
 {row
  {center ⊆}
  {center U+2286}
  {left \ {c subset of or equal to}\ }
  {left \ }}
 {row
  {center ⊇}
  {center U+2287}
  {left \ {c superset of or equal to}\ }
  {left \ }}
 {row
  {center ⊏}
  {center U+228F}
  {left \ {c square image of}\ }
  {left \ }}
 {row
  {center ⊐}
  {center U+2290}
  {left \ {c square original of}\ }
  {left \ }}
 {row
  {center ⊑}
  {center U+2291}
  {left \ {c square image of or equal to}\ }
  {left \ }}
 {row
  {center ⊒}
  {center U+2292}
  {left \ {c square original of or equal to}\ }
  {left \ }}
 {row
  {center ⊓}
  {center U+2293}
  {left \ {c square cap}\ }
  {left \ }}
 {row
  {center ⊔}
  {center U+2294}
  {left \ {c square cup}\ }
  {left \ }}
 {row
  {center ⊕}
  {center U+2295}
  {left \ {c circled plus}\ }
  {left \ }}
 {row
  {center ⊖}
  {center U+2296}
  {left \ {c circled minus}\ }
  {left \ }}
 {row
  {center ⊗}
  {center U+2297}
  {left \ {c circled times}\ }
  {left \ }}
 {row
  {center ⊘}
  {center U+2298}
  {left \ {c circled division slash}\ }
  {left \ }}
 {row
  {center ⊙} 
  {center U+2299}
  {left \ {c circled dot operator}\ }
  {left \ }}
 {row
  {center ⊥}
  {center U+22A5}
  {left \ {c up tack}\ }
  {left \ {i Mathematical letter}\ }}
 {row
  {center ⋅}
  {center U+22C5}
  {left \ {c dot operator}\ }
  {left \ }}}

{justify
  It is possible to write Orson programs using only visible {c ascii}
  characters (with codes between U+0020 and U+007E) and
  {goto character newlines.}
  This lets Orson be used on computers that do not support Unicode.
  Orson uses all the visible {c ascii} characters, except the percent sign `%'
  (U+0025) and the grave accent `\ {t `}\ ' (U+0060).

  This Report sometimes shows a {goto blank} as `␣' to emphasize its presence.
  It also shows a {goto quote} `\ {i "}\ ' in italics so it will not be
  confused with two {goto apostrophe apostrophes} `\ {q ''}\ '.
  To improve the appearance of Orson programs, this Report shows Roman letters
  in boldface, in italics, and in ordinary type.
  However, these are considered to be identical, so that `{b x}', `{i x}', and
  `x' are the same character.}

{label international}
{left {b 2.2. Internationalization.}}

{justify
  Some programming languages are intended to be international, using letters
  from many different alphabets {goto gos1996 {c [gos 1996].}}
  However, Orson uses only {goto unicode Roman} letters, and a few
  {goto unicode Greek} letters from mathematics {goto knu1986 {c [knu 1986].}}
  There are three reasons why.

  First, most programming languages (including Orson), use English words and
  phrases.
  They cannot be made international simply by letting them use letters from
  non-Roman alphabets.
  This would work only in programming languages like Common Lisp
  {goto ste1990 {c [ste 1990]}} and Scheme {goto spe2007 {c [spe 2007]}} that
  are not based on natural languages.

  Second, some alphabets have letters whose {goto unicode glyphs} look like
  those from other alphabets.
  For example, in many fonts, the glyph for the Roman letter `A' (U+0041) looks
  like the glyph for the Greek letter `A' (U+0391).
  Similarly, the glyph for the letter `LJ' (U+01C7) looks like the glyph for
  the Roman letter `L' (U+004C) followed by the glyph for the Roman letter `J'
  (U+004A).
  Using letters like these, it is possible to write confusing
  {goto nametoken names} that look {goto identical identical,} but are not.

  Third, English is perhaps the most widely spoken and written language
  {goto mcc1987 {c [mcc 1987],}} and all programmers know at least some
  mathematics.
  Programs should therefore be written using English names and mathematical
  symbols.
  No chauvinism is intended: the present status of English is due to historical
  accidents, not to any inherent superiority.}

{rule}

{label token}
{left {b 3. Tokens.}}

{narrow
 {display
I am sent in all haste to espy and to marke
How our letters and tokens are likely to warke.}
 {right
  {goto uda1935 {c [uda 1935]}}}}

{justify
  Orson groups the {goto character characters} of each {goto character line}
  in a program into {i tokens.}
  It considers a program to be a series of tokens, not a series of characters
  or a series of lines.
  If there is more than one way to group characters into a token, then Orson
  groups them to produce the token with the maximum number of characters.
  There is no {goto limit} on the number of characters in a token, but each
  token must fit on a single line.

  Tokens may be separated by zero or more {goto blank blanks} and
  {goto character newlines,} called {i whitespace.}
  Such whitespace is ignored, so that Orson programs may be {i indented} to
  reflect their logical structure.
  There are many ways to indent Orson programs.
  The way used in this Report is recommended, but not required.

  There are seven kinds of tokens, called
  {goto comment} tokens,
  {goto nametoken name} tokens,
  {goto inttoken integer} tokens,
  {goto realtoken real} tokens,
  {goto chartoken character} tokens,
  {goto stringtoken string} tokens, and
  {goto symboltoken symbol} tokens.
  These are described in the next few sections.}

{label comment}
{left {b 3.1. Comment tokens.}}

{justify
 {i Comments} are ignored, so they can be used to add explanatory text to a
 program.
 Each comment begins with an {goto exclamation exclamation mark,} is followed
 by zero or more {goto character visible} characters other than
 {goto character newlines,} and ends with a newline.
 For example:}

{narrow
 {display
!
!!
!  How commentators each dark passage shun — Edward Young (1683–1765).
!  Alphabetize by doing an inorder traversal of the binary tree {i "}木{i ".}
!  Warning! This procedure will delete all your files.}}

{justify
  A comment may appear anywhere that a newline may appear.
  Adding or removing a comment does not affect the meaning of an Orson program
  in any way.
  As a result, Orson cannot use comments as {i pragmas}
  {goto ker1988 {c [ker 1988]}} that advise how a program is to be
  {goto evaluate evaluated.}}

{label nametoken}
{left {b 3.2. Name tokens.}}

{justify
 {i Names} may be {goto bind bound} to {goto expression expressions} and
 {goto object objects,} along with their {goto type types.}
 Names may also appear as {goto namepart parts} of some types.
 There are three kinds of names, called {goto plain} names, {goto quoted}
 names, and {goto secret} names.}

{label plain}
{left {b 3.2.1. Plain names.}}

{justify
  A {i plain} {goto nametoken name} starts with a {goto lower} case 
  {goto unicode Roman} letter or a {goto unicode mathematical} letter.
  It is followed by zero or more {goto apostrophe apostrophes,}
  {goto digit digits,} mathematical letters, Roman letters, and
  {goto subscript subscripts.}
  In this Report, the Roman letters in plain names are written in italic type.
  For example, ∅, {i a,} {i b}₂, {i can}{q '}{i t,} Δ, {i equal,}
  {i fiftySeven,} {i g}{q ',} {i henryThe}8{i th,} {i isLetter,} and {i jump}
  are plain names.
  Some plain names are reserved for use as {goto symboltoken symbol} tokens.}

{label quoted}
{left {b 3.2.2. Quoted names.}}

{justify
  A {i quoted} {goto nametoken name} starts with a {goto quote quote,} is
  followed by zero or more {goto character visible} characters other than
  quotes, and ends with another quote.
  The quotes are considered to be part of the name.
  In this Report, the {goto unicode Roman} letters in quoted names are written
  in ordinary type.
  For example, {i "",} {i "}a{i ",} {i "}₂b{i ",} {i "}can{q '}t{i ",}
  {i "}Δ{i ",} {i "}={i ",} {i "}57{i ",} {i "}dg/dx{i ",}
  {i "}Henry\ {c viii}{i ",} {i "}это\ письмо?{i ",} and {i "}狘{i "} are
  quoted names.
  Quoted names should not be confused with {goto chartoken character} tokens or
  {goto stringtoken string} tokens, which are written in similar
  (but different) ways.}

{label secret}
{left {b 3.2.3. Secret names.}}

{justify
  A {i secret} {goto nametoken name} starts with an {goto upper} case
  {goto unicode Roman} letter.
  It is followed by zero or more {goto apostrophe apostrophes,}
  {goto digit digits,} {goto unicode mathematical} letters, Roman letters, and
  {goto subscript subscripts.}
  In this Report, the Roman letters in secret names are written in italic type.
  For example, {i A,} {i B}₂, {i Can}{q '}{i t,} {i Delta,} {i Equal,}
  {i FiftySeven,} {i G}{q ',} {i HenryThe}8{i th,} {i IsLetter,} and {i JUMP}
  are secret names.
  The {goto plain} names ∀ and Ω are not secret names, because they do not
  start with upper case Roman letters.
  The {goto quoted} name {i "}A{i "} is not a secret name, because it starts
  with a {goto quote quote.}}

{label identical}
{left {b 3.2.4. Identical names.}}

{justify
  Two {goto nametoken names} are {i identical} if they have the same
  characters, in the same order.
  {goto upper Upper} and {goto lower} case letters are considered to be
  different, and the {goto quote quotes} in a {goto quoted} name are considered
  to be part of the name.
  As a result, {i x}, {i X}, {i "}x{i ",} and {i "}X{i "} are four different
  names.

  There are two exceptions to this rule.
  The first is that two or more adjacent {goto blank blanks} in a quoted name
  are treated as a single blank.
  This lets quoted names be easily distinguished without having to count their
  blanks.
  For example, {i "}x␣y{i "}, {i "}x␣␣y{i "}, and {i "}x␣␣␣y{i "} are
  identical, but {i "}xy{i "}, {i "}␣xy{i "}, {i "}x␣y{i "}, and {i "}xy␣{i "}
  are different.

  The second exception is that otherwise identical {goto secret} names are
  treated as being different when they appear in different
  {goto progsecret {i prog}} clauses.
  This lets each {goto progclause {i prog}} clause have its own secret names,
  different from those in any other {i prog} clause.}

{label unique}
{left {b 3.2.5. Unique names.}}

{justify
  Orson sometimes creates {i unique} {goto nametoken names} that are not
  {goto identical} to any other names in a program.
  A unique name might consist of an {goto unspecified} character `¢' that can
  appear only in names created by Orson, followed by a number.
  Whenever a new unique name is needed, the number is incremented, resulting in
  ¢0, ¢1, ¢2, etc.
  Unique names are similar to the {i gensyms} of the programming language
  Common Lisp {goto ste1990 {c [ste 1990].}}}

{label inttoken}
{left {b 3.3. Integer tokens.}}

{justify
 {i Integer tokens} denote nonnegative {goto int integer}
 {goto constant constants.}
 They can be written in any radix from 2 to 36.
 A radix 10 integer token starts with a {goto digit digit,} and is followed by
 zero or more additional digits.
 For example, 0, 11, 7734, and 0123456789 are all radix 10 integer tokens.

 An integer token can also start with one or more digits that denote its radix,
 followed by a {goto sharp sharp,} followed by one or more digits and
 {goto unicode Roman} letters which denote an integer in that radix.
 Digits have the values 0 through 9, and Roman letters have the values 10
 through 35, with {goto upper} and {goto lower} case letters considered
 identical.
 If an integer token starts with a sharp, then radix 16 is assumed.
 For example, the integer token 7734 may be written in radix 2 as
 2#1111000110110, in radix 8 as 8#17066, in radix 10 as 7734 and 10#7734, or
 in radix 16 as 16#1E36, 16#1e36, #1E36, and #1e36.

 Integer tokens in any radix may include {goto underline underlines,} which
 are ignored.
 For example, 123456789 may also be written as 123_456_789, and 2#1111000110110
 may also be written as 2#0001_1110_0011_0110.}

{label realtoken}
{left {b 3.4. Real tokens.}}

{justify
 {i Real tokens} denote nonnegative {goto real} {goto constant constants.}
 They can be written only in radix 10.
 A real token is a series of one or more {goto digit digits,} followed by a
 {goto dotchar dot,} followed by one or more additional digits.
 It may also include {goto underline underlines,} which are ignored.
 For example, 0.5, 7734.40, and 3.141_592_654 are all real tokens.

 A real token can be followed by an optional {i scale factor.}
 A scale factor starts with the Roman letter {i e} or {i E,} followed by an
 optional {goto unicode sign} `+', `-', or `−', followed by a series of one or
 more digits.
 The scale factor indicates multiplication by a power of 10.
 For example, the real token 100000.0 may be also written as 1.0{i E}5,
 1.0{i E}+5, 1.0{i e}5, and 1.0{i e}+5.
 Similarly, the real token 0.00001 may also be written as 1.0{i E}-5,
 1.0{i E}−5, 1.0{i e}-5, and 1.0{i e}−5.}

{label chartoken}
{left {b 3.5. Character tokens.}}

{justify
 {i Character tokens} denote {goto char character} {goto constant constants.}
 A character token starts with an {goto apostrophe apostrophe,} followed by a
 {goto character visible} character other than an apostrophe, and ends with
 another apostrophe.
 For example, {q '␣', '!', '{i "}', '+', '7', 'A', 'b', 'φ', and '字'} are
 character tokens.
 A {goto slashed} character can appear between the apostrophes instead of an
 ordinary character.
 Character tokens should not be confused with {goto quoted} name tokens or with
 {goto stringtoken string} tokens, which are written in similar (but different)
 ways.}

{label stringtoken}
{left {b 3.6. String tokens.}}

{justify
 {i String tokens} denote {goto string} {goto constant constants.}
 A string token starts with two {goto apostrophe apostrophes,} followed by a
 series of zero or more {goto character visible} characters without two
 adjacent apostrophes, and ends with two more apostrophes.
 For example, {q '''',} {q ''␣'',} {q ''''',} {q ''+'',} {q ''7734'',}
 {q ''A'',} {q ''b₂'',} {q ''characters'',} {q ''Dogpack\ Asmodeus\ Bozart'',}
 {q ''Enter\ }{i "}刅{i "}{q \ to\ begin!'',} {q ''Φ(2π)'',}
 {q ''Georges'',} {q ''George's'',} {q ''Georges''',}  and {q ''письмена''}
 are string tokens.
 Any or all of the characters between the pairs of apostrophes can be
 {goto slashed} characters instead of ordinary characters.

 Orson appends a {goto nullchar null} character to the end of each string
 token, so it has one more character than is apparent, as in the programming
 language C {goto ker1988 {c [ker 1988].}}
 For example, the string token {q ''Ten␣chars''} really does have ten
 characters.
 The null character should not be confused with the {goto type}
 {goto null {i null.}}
 String tokens should not be confused with {goto chartoken character} tokens or
 with {goto quoted} name tokens, which are written in similar
 (but different) ways.}

{label slashed}
{left {b 3.7. Slashed characters.}}

{justify
  Any or all of the characters in {goto chartoken character} tokens and
  {goto stringtoken string} tokens can be written as {i slashed} characters.
  Slashed characters are often used to denote invisible characters that
  {goto must} not appear explicitly in Orson programs.
  There are two kinds of slashed characters.
  The first kind consists of a {goto backslash} followed by one of the
  characters shown below.}

{table
 {row
  {center {b \ \ Slashed\ \ }}
  {center {b \ \ Code\ \ }}
  {center {b \ \ Official Name\ \ }}
  {center {b \ \ Unofficial Name\ \ }}}
 {row
  {center {label nullchar} \\0}
  {center \ U+0000\ }
  {left \ {c control}\ }
  {left \ {i Null}\ }}
 {row
  {center \\A or \\a}
  {center \ U+0007\ }
  {left \ {c control}\ }
  {left \ {i Alert}\ }}
 {row
  {center \\B or \\b}
  {center \ U+0008\ }
  {left \ {c control}\ }
  {left \ {i Backspace}\ }}
 {row
  {center \\E or \\e}
  {center \ U+001B\ }
  {left \ {c control}\ }
  {left \ {i Escape}\ }}
 {row
  {center \\F or \\f}
  {center \ U+000C\ }
  {left \ {c control}\ }
  {left \ {i Formfeed}\ }}
 {row
  {center {label linefeed} \\N or \\n}
  {center \ U+000A\ }
  {left \ {c control}\ }
  {left \ {i Linefeed}\ }}
 {row
  {center \\R or \\r}
  {center \ U+000D\ }
  {left \ {c control}\ }
  {left \ {i Return}\ }}
 {row
  {center \\T or \\t}
  {center \ U+0009\ }
  {left \ {c control}\ }
  {left \ {i Horizontal tab}\ }}
 {row
  {center \\V or \\v}
  {center \ U+000B\ }
  {left \ {c control}\ }
  {left \ {i Vertical tab}\ }}
 {row
  {center {q \\'}}
  {center \ U+0027\ }
  {left \ {c apostrophe}\ }
  {left \ }}
 {row
  {center \\\\}
  {center \ U+005C\ }
  {left \ {c reverse solidus}\ }
  {left \ {i Backslash}\ }}}

{justify
  For example, the character tokens {q '\\T'} and {q '\\t'} both denote a
  horizontal tab, with the {goto unicode code} U+0009.
  The character token {q '\\''} denotes an apostrophe, with the code U+0027.
  The string token {q ''Hello␣world!\\n''} contains a linefeed, with the code
  U+000A, and the string token {q ''\\\\''} contains a backslash, with the
  code U+005C.

  The second kind of slashed character starts with a backslash and a
  {goto sharp sharp,} followed by a radix 16 {goto int integer} code between 0
  and 7FFFFFFF (2147483647).
  The code can contain {goto underline underlines,} which are ignored.
  For example, the character token {q '\\#3B1'} is equivalent to the character
  token {q 'α'}, with the code U+03B1.
  The string token {q ''Hello␣world!\\#0A''} contains a {goto linefeed}
  character, with the code U+000A.

  A character code may be followed by a backslash and an underline.
  This is sometimes necessary in a string token to separate the code from other
  characters.
  For example, the string token {q ''\\#7734''} has two characters:
  {q '\\#7734'} and {q '\\0'.}
  However, the string token {q ''\\#77\\_34''} has four characters:
  {q '\\#77', '3', '4', and '\\0'.}}

{label symboltoken}
{left {b 3.8. Symbol tokens.}}

{justify
 {i Symbols} are used as delimiters, operators, and syntactic markers.
 Some symbols, called {i reserved names,} are made up of {goto lower} case
 {goto unicode Roman} letters, as shown below.
 In this Report, reserved names appear in bold type.}

{narrow
 {b
  {layout
   {row
    {left also}
    {left \ \ \ \ }
    {left do}
    {left \ \ \ \ }
    {left in}
    {left \ \ \ \ }
    {left or}
    {left \ \ \ \ }
    {left then}}
   {row
    {left alt}
    {left \ \ \ \ }
    {left else}
    {left \ \ \ \ }
    {left load}
    {left \ \ \ \ }
    {left past}
    {left \ \ \ \ }
    {left tuple}}
   {row
    {left alts}
    {left \ \ \ \ }
    {left for}
    {left \ \ \ \ }
    {left mod}
    {left \ \ \ \ }
    {left proc}
    {left \ \ \ \ }
    {left type}}
   {row
    {left and}
    {left \ \ \ \ }
    {left form}
    {left \ \ \ \ }
    {left none}
    {left \ \ \ \ }
    {left prog}
    {left \ \ \ \ }
    {left var}}
   {row
    {left case}
    {left \ \ \ \ }
    {left gen}
    {left \ \ \ \ }
    {left not}
    {left \ \ \ \ }
    {left ref}
    {left \ \ \ \ }
    {left while}}
   {row
    {left catch}
    {left \ \ \ \ }
    {left if}
    {left \ \ \ \ }
    {left of}
    {left \ \ \ \ }
    {left row}
    {left \ \ \ \ }
    {left with}}}}}

{justify
  Although reserved names resemble {goto plain} names, they cannot be used as
  {goto nametoken names,} and should not be confused with them.
  For example, {b form} is a reserved name, but {i Form,} {i FORM,}
  {i form}{q ',} and {i "}form{i "} are not reserved names.
  Other symbols are made up of {goto unicode {c ascii}} mathematical and
  punctuation characters.}

{narrow
 {layout
  {row
   {left (\ \ \ }
   {left )\ \ \ }
   {left [\ \ \ }
   {left ]\ \ \ }
   {left \{\ \ \ }
   {left \}\ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }}
  {row
   {left <\ \ \ }
   {left <=\ \ \ }
   {left <>\ \ \ }
   {left =\ \ \ }
   {left >\ \ \ }
   {left >=\ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }}
  {row
   {left &\ \ \ }
   {left ⁎\ \ \ }
   {left +\ \ \ }
   {left -\ \ \ }
   {left /\ \ \ }
   {left <<\ \ \ }
   {left >>\ \ \ }
   {left |\ \ \ }
   {left ~\ \ \ }
   {left \ \ \ \ }}
  {row
   {left &=\ \ \ }
   {left ⁎=\ \ \ }
   {left +=\ \ \ }
   {left -=\ \ \ }
   {left /=\ \ \ }
   {left <<=\ \ \ }
   {left >>=\ \ \ }
   {left |=\ \ \ }
   {left ~=\ \ \ }
   {left \ \ \ \ }}
  {row
   {left $\ \ \ }
   {left ,\ \ \ }
   {left .\ \ \ }
   {left :\ \ \ }
   {left :-\ \ \ }
   {left :=\ \ \ }
   {left ;\ \ \ }
   {left ?\ \ \ }
   {left @\ \ \ }
   {left {q ^}\ \ \ }}}}

{justify
  Still other symbols contain {goto unicode Unicode} mathematical and
  punctuation characters.}

{narrow
 {layout
  {row
   {left :−\ \ \ }
   {left ¬\ \ \ }
   {left ↑\ \ \ }
   {left ↓\ \ \ }
   {left ∧\ \ \ }
   {left ∨\ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }}
  {row
   {left ×\ \ \ }
   {left ←\ \ \ }
   {left →\ \ \ }
   {left −\ \ \ }
   {left ∘\ \ \ }
   {left ∙\ \ \ }
   {left ∩\ \ \ }
   {left ∪\ \ \ }
   {left ⊓\ \ \ }
   {left ⊔\ \ \ }
   {left ⊕\ \ \ }
   {left ⊖\ \ \ }
   {left ⊗\ \ \ }
   {left ⊘\ \ \ }
   {left ⊙\ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }}
  {row
   {left ×=\ \ \ }
   {left ←=\ \ \ }
   {left →=\ \ \ }
   {left −=\ \ \ }
   {left ∘=\ \ \ }
   {left ∙=\ \ \ }
   {left ∩=\ \ \ }
   {left ∪=\ \ \ }
   {left ⊓=\ \ \ }
   {left ⊔=\ \ \ }
   {left ⊕=\ \ \ }
   {left ⊖=\ \ \ }
   {left ⊗=\ \ \ }
   {left ⊘=\ \ \ }
   {left ⊙=\ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }
   {left \ \ \ \ }}
  {row
   {left ∊\ \ \ }
   {left ∍\ \ \ }
   {left ≠\ \ \ }
   {left ≡\ \ \ }
   {left ≢\ \ \ }
   {left ≤\ \ \ }
   {left ≥\ \ \ }
   {left ≺\ \ \ }
   {left ≻\ \ \ }
   {left ≼\ \ \ }
   {left ≽\ \ \ }
   {left ⊂\ \ \ }
   {left ⊃\ \ \ }
   {left ⊆\ \ \ }
   {left ⊇\ \ \ }
   {left ⊏\ \ \ }
   {left ⊐\ \ \ }
   {left ⊑\ \ \ }
   {left ⊒\ \ \ }}}}

{justify
  Some {c ascii} symbols are synonyms for Unicode symbols.
  They allow writing Orson programs in {c ascii} on older computers that do not
  support Unicode.
  For example, `:-' is a synonym for `:−', {b and} is a synonym for `∧', and
  {b or} is a synonym for `∨'.
  The standard {goto prelude} also defines the {goto quoted} names of some
  {goto le operators,} like {i "}<={i "} and {i "}≤{i ",} to be synonyms.}

{rule}

{label type}
{left {b 4. Types.}}

{narrow
 {justify
   The higher its type, always the seldomer doth a thing succeed.}
 {right
  {goto nie1954 {c [nie 1954]}}}}

{justify
  A {i type} is a {goto constant} {goto object} that may describe another
  object.
  An object described by the type is said to {i have} the type, or to be {i of}
  the type.
  If an {goto expression} {goto evaluate evaluates} to an object of some type,
  then the expression is also said to have that type, or to be of that type.
  Every object has a type, and most objects have many types.
  Since types are themselves objects, types also have types.}

{label object}
{left {b 4.1. Objects.}}

{justify
  {i Objects} are the data that are manipulated during
  {goto evaluate evaluation} to perform computations.
  An object may exist during the {goto transform transformation} phase of
  evaluation, or during the {goto execute execution} phase, or during both
  phases.
  Each object is also either a {goto type} or an instance.
  A {i type} is an object that may describe other objects.
  An {i instance} is an object that does not describe other objects, but which
  is described by a type.}

{justify
  {b Transformation objects.}
  A {i transformation object} exists during transformation.
  It is either a {i transformation type} or a {i transformation instance.}

  Transformation types include
  {goto altsclause alternate} form types,
  {goto char character} types,
  {goto gentype generic} form types,
  {goto int integer} types,
  {goto joker} types,
  the {goto {i list}} type,
  the {goto {i null}} type,
  {goto formtype plain} form types,
  {goto proctype procedure} types,
  {goto real} types,
  {goto {i ref}} pointer types,
  {goto {i row}} pointer types,
  {goto skolem Skolem} types,
  the {goto {i stream}} type,
  the {goto {i string}} type,
  {goto symbol} types,
  {goto tupleclause tuple} types,
  {goto typetype type} types,
  {goto vartype variable} types, and
  the {goto void {i void}} type.

  Transformation instances include
  {goto altclause alternate} forms,
  character {goto constant constants,}
  {goto genclause generic} forms,
  integer constants,
  {goto list lists,}
  the {i null} constant {goto null {i nil,}}
  {goto formclause plain} forms,
  real constants,
  string constants, and
  the {i void} constant {goto void {i skip.}}}

{justify
  {b Execution objects.}
  An {i execution object} exists during execution.
  It is either an {i execution type} or an {i execution instance.}

  Execution types include
  character types,
  integer types,
  the {i null} type,
  procedure types,
  real types,
  {i ref} pointer types,
  {i row} pointer types,
  the {i stream} type,
  the {i string} type,
  tuple types,
  variable types, and
  the {i void} type.

  Execution instances include
  characters,
  character constants,
  integers,
  integer constants,
  the {i null} constant {i nil,}
  {goto procclause procedures,}
  reals,
  real constants,
  {i ref} pointers,
  {i row} pointers,
  streams,
  strings,
  string constants,
  tuples,
  variables, and
  the {i void} constant {i skip.}}

{label subtype}
{left {b 4.2. Subtypes.}}

{justify
  Suppose that {i l} and {i r} are {goto type types.}
  If every {goto object} of type {i l} is also an object of type {i r,} then
  {i l} is a {i subtype} of {i r.}
  As a result, every type is a subtype of itself.
  This Report uses the notation {i l}\ ⊆\ {i r} to mean that {i l} is a subtype
  of {i r.}
  It suggests that a type is mathematically a set of objects.
  An object has the type if it is a member of the set.}

{label cotype}
{left {b 4.3. Cotypes.}}

{justify
  Suppose that {i l} and {i r} are {goto type types.}
  Also suppose that there is a situation in which an {goto expression} or
  {goto object} of type {i r} is expected, but one of type {i l} is provided
  instead.
  Then Orson tries to convert the expression or object of type {i l} to a new
  expression or object, whose type is a {goto subtype} of {i r.}
  It is an {goto errors error} if the expression or object cannot be converted.

  Converting an expression or object in this way is called {i coercion,} and
  the expression or object is said to be {i coerced.}
  If an expression or object of type {i l} can be coerced to have a type that
  is a subtype of {i r,} then {i l} is said to be a {i cotype} of {i r.}
  This Report uses the notation {i l}\ ⊑\ {i r} to mean that {i l} is a cotype
  of {i r.}
  This is similar to the notation used for subtypes.

  Suppose that {i e} is an expression or object of type {i l,} and that {i l}
  is a cotype of {i r.}
  Then this Report uses the notation {i e}\{{i r}\} to mean the expression or
  object that results when {i e} is coerced to a subtype of {i r.}
  This is also the notation used for {goto postbrace casts,} which are similar
  to coercions.
  Orson computes {i e}\{{i r}\} either by {i restrictive coercion} or by
  {i permissive coercion.}}

{justify
  {b Restrictive coercion.}
  Restrictive coercion is used when the expected type is an
  {goto object execution} type.
  It works in the following way.
  Suppose that an expression or object {i e} of type {i l} is provided, but one
  of type {i r} is expected, where {i l} is a subtype of {i r.}
  Then {i e}\{{i r}\} is simply {i e,} but with the type {i r.}
  Now suppose that {i l} is a cotype of {i r} instead.
  Then {i e}\{{i r}\} is a new expression or object, whose type is also {i r.}
  In either case, {i e} is coerced to {i exactly} the expected type {i r.}

  For example, suppose that {i e} has the type {goto int {i int,}} and is
  provided where an expression of type {i int} is also expected.
  Then {i e}\{{i int}\} is simply {i e,} with its original type {i int.}
  Now suppose that {i e} has the {goto vartype variable} type {b var}\ {i int}
  instead.
  Then {i e}\{{i int}\} is a new expression in which the variable {i e} is
  coerced to its value of type {i int.}}

{justify
  {b Permissive coercion.}
  Permissive coercion is used when the expected type is not an execution type.
  It works in the following way.
  Suppose that an expression or object {i e} of type {i l} is provided, but one
  of type {i r} is expected, where {i l} is a subtype of {i r.}
  Then {i e}\{{i r}\} is simply {i e,} with its original type {i l.}
  Now suppose that {i l} is a cotype of {i r} instead.
  Then {i e}\{{i r}\} is a new expression or object, whose type is a subtype of
  {i r.}
  In either case, {i e} is coerced to a {i subtype} of the expected type {i r.}

  For example, suppose that {i e} has the type {i int,} and is provided where
  an expression of the {goto joker} type {goto {i inj}} is expected.
  Then {i e}\{{i inj}\} is simply {i e,} with its original type {i int.}
  Now suppose that {i e} has the variable type {b var}\ {i int} instead.
  Then {i e}\{{i inj}\} is a new expression in which the variable {i e} is
  coerced to its value of type {i int.}}

{label compatible}
{left {b 4.4. Compatibility.}}

{justify
  Suppose that {i l} and {i r} are {goto type types.}
  If {i l} is a {goto subtype} of {i r,} or {i l} is a {goto cotype} of {i r,}
  then {i l} is said to be {i compatible} with {i r.}
  Formal {goto rule rules} decide if one type is compatible with another.
  There are at least two different ways that these rules might work, called
  {i identifier compatibility} and {i structure compatibility.}

  In identifier compatibility, each type is given a unique {i identifier} when
  it is created.
  Two types are then compatible if they have equal identifiers.
  One way to implement identifiers is to require that all types be given names,
  and then use the names as identifiers.
  Another way is to use the memory addresses of the objects that represent
  types.

  In structure compatibility, a recursive algorithm decides if one type is
  compatible with another.
  If two types are so simple that they have no parts, then they are directly
  tested for compatibility.
  Otherwise, the types are compatible if each part of the first type is
  compatible with a corresponding part of the second type.

  Identifier compatibility can be implemented very efficiently as an equality
  test on type identifiers.
  Unfortunately, if it is used, then apparently identical types created in
  different parts of a program can never be compatible, because they will
  always have different identifiers.
  As a result, each type has to be created exactly once, typically at the
  beginning of the program.

  Orson requires that it be possible to create new types anywhere in a program.
  It also requires that apparently identical types behave the same way, no
  matter where they are created.
  In other words, it requires that types behave like all other
  {goto object objects.}
  Orson therefore uses structure compatibility, although it also uses a kind of
  identifier compatibility with {goto skolem Skolem} types.

  Under structure compatibility, simply {goto bind binding} a
  {goto nametoken name} to a type does not create a new type.
  It only gives the type a new name.
  For example, the standard {goto prelude} binds the names {goto {i bool}} and
  {goto int {i int}0} to the same {goto int integer} type.
  As a result, {i bool} and {i int}0 are two different names for the same type,
  and can be used interchangeably.}

{label rule}
{left {b 4.5. Rules.}}

{justify
  In this Report, {goto compatible compatibility} rules for {goto type types}
  are written in a formal notation similar to that used in type theory
  {goto car1997 {c [car 1997].}}
  If the {i p}'s and {i q}'s are logical {i statements} about types, and {bi r}
  is an identifying number, then this is a compatibility rule.}

{narrow
 {over
  {center {i p}{- 1}, {i p}{- 2} ..., {i p}{-i j}}
  {left \ {bi r}}
  {center {i q}{- 1}, {i q}{- 2} ..., {i q}{-i k}}}}

{justify
  The {i q}'s are called {i antecedents,} and the {i p}'s are called
  {i consequents.}
  The rule {bi r} says that if the {i q}'s are true, then the {i p}'s are also
  true.

  Some rules apply to all types.
  For example, rule {b 0} says that every type {i t} is a {goto subtype} of
  itself.
  Rule {b 1} says that a type {i t} is a {goto cotype} of a type {i T} if {i t}
  is a subtype of {i T.}}

{narrow
 {label rule00}
 {label rule01}
 {layout
  {row
   {over
    {center {i t} ⊆ {i t}}
    {left \ {b 0}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊑ {i T}}
    {left \ {b 1}}
    {center {i t} ⊆ {i T}}}}}}

{justify
  Other rules apply only to specific types.
  For example, rule {bc i} says that an {goto prebracket array} type is a
  subtype of another array type if both types have the same length
  {i k,} and the first type's base {i t} is a subtype of the second type's
  base {i T.}
  Rule {bc ii} says that the {goto int integer} type {goto int {i int}0} is a
  subtype of the {goto joker} type {goto inj {i inj.}}
  Rule {bc iii} says that a {goto vartype variable} type is a subtype of
  another variable type if the first type's base {i t} is a subtype of the
  second type's base {i T.}}

{narrow
 {label rulei}
 {label ruleii}
 {label ruleiii}
 {layout
  {row
   {over
    {center [{i k}] {i t} ⊆ [{i k}] {i T}}
    {left \ {bc i}}
    {center {i t} ⊆ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center {i int}0 ⊆ {i inj}}
    {left \ {bc ii}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {b var} {i t} ⊆ {b var} {i T}}
    {left \ {bc iii}}
    {center {i t} ⊆ {i T}}}}}}

{justify
  Rules like these are used to construct {i proofs.}
  The first step of a proof is a set of one or more statements to be proved.
  Suppose there is a rule whose consequents match some of these statements.
  Then the next step in the proof is {i deduced} by replacing the matched
  statements with the rule's corresponding antecedents, and deleting redundant
  statements.
  The rule is then said to have been {i applied.}
  Repeatedly applying rules produces a tower of steps, each labeled by the
  number of the rule that deduced it, like this.}

{narrow
 {over
  {center [10] {b var} {i int}0 ⊆ [10] {b var} {i inj}}
  {left \ {goto rulei {c i}}}
  {center {b var} {i int}0 ⊆ {b var} {i inj}}
  {left \ {goto ruleiii {c iii}}}
  {center {i int}0 ⊆ {i inj}}
  {left \ {goto ruleii {c ii}}}
  {center {i true}}}}

{justify
  A statement is true if it is possible to construct a finite tower of steps in
  this way, starting with the statement on top, and ending with {i true} on the
  bottom.
  If it is not possible to construct such a tower, then the statement is
  false.

  The following table summarizes all rules used in this Report.
  It shows the identifying number of each rule, the section in which it
  appears, and a brief description of what it does.}

{table
 {row
  {center {b \ Section\ }}
  {center {b \ Rule\ }}
  {center {b \ Description\ }}}
 {row
  {left \ {goto rule 4.5.}}
  {center {goto rule00 0}}
  {left \ Every {goto type} is a subtype of itself.}}
 {row
  {left \ {goto rule 4.5.}}
  {center {goto rule01 1}}
  {left \ A type is a cotype if it is a subtype.}}
 {row
  {left \ {goto subname 4.6.2.}}
  {center {goto rule02 2}}
  {left
    \ Every {goto nametoken name} is a {goto namepart subname} of itself.}}
 {row
  {left \ {goto subname 4.6.2.}}
  {center {goto rule03 3}}
  {left \ Every name is a subname of the {goto missing} name ⬚.}}
 {row
  {left \ {goto formtype 5.9.1.}}
  {center {goto rule04 4}}
  {left
    \ How a {goto formtype plain} form type is a subtype of a plain form
    type.}}
 {row
  {left \ {goto skolem 5.9.2.4.}}
  {center {goto rule05 5}}
  {left \ How a {goto skolem Skolem} type is a subtype of a type.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule06 6}}
  {left \ Add a {goto genrule separator} `|'.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule07 7}}
  {left \ Remove a replacing {goto gentype generic} prefix.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule08 8}}
  {left \ Remove a replacing generic prefix.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule09 9}}
  {left \ Remove a {goto skolem Skolemizing} generic prefix.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule10 10}}
  {left \ Remove a Skolemizing generic prefix.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule11 11}}
  {left \ Replace a {goto gentype generic} name by a type.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule12 12}}
  {left \ Replace a generic name by a type.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule13 13}}
  {left \ Move a generic form type from the left to the right of `|'.}}
 {row
  {left \ {goto gensubtype 5.9.2.7.}}
  {center {goto rule14 14}}
  {left \ Move a generic form type from the left to the right of `|'.}}
 {row
  {left \ {goto ref 5.9.3.1.}}
  {center {goto rule15 15}}
  {left \ How a {goto {i ref}} type is a subtype of a {i ref} type.}}
 {row
  {left \ {goto row 5.9.3.2.}}
  {center {goto rule16 16}}
  {left \ How a {goto {i row}} type is a subtype of a {i row} type.}}
 {row
  {left \ {goto row 5.9.3.2.}}
  {center {goto rule17 17}}
  {left \ How a {i ref} type is a cotype of a {i row} type.}}
 {row
  {left \ {goto proctype 5.9.4.}}
  {center {goto rule18 18}}
  {left
    \ How a {goto proctype procedure} type is a subtype of another procedure
    type.\ }}
 {row
  {left \ {goto typetype 5.9.5.}}
  {center {goto rule19 19}}
  {left \ How a {goto typetype type} type is a subtype of another type type.}}
 {row
  {left \ {goto vartype 5.9.6.}}
  {center {goto rule20 20}}
  {left
    \ How a {goto vartype variable} type is a subtype of another variable
    type.}}
 {row
  {left \ {goto vartype 5.9.6.}}
  {center {goto rule21 21}}
  {left \ How a variable type is a cotype of a type.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule22 22}}
  {left \ How an alternate form type is {goto subsume subsumed} by a type.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule23 23}}
  {left \ How an alternate form type is subsumed by a type.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule24 24}}
  {left \ How a type is subsumed by an alternate form type.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule25 25}}
  {left \ How a type is subsumed by an alternate form type.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule26 26}}
  {left \ Add a separator `|'.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule27 27}}
  {left \ Remove a replacing generic prefix.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule28 28}}
  {left \ Remove a Skolemizing generic prefix.}}
 {row
  {left \ {goto subsume 5.10.1.2.}}
  {center {goto rule29 29}}
  {left \ How a plain form type is subsumed by a plain form type.}}
 {row
  {left \ {goto altsclause 5.10.2.2.}}
  {center {goto rule30 30}}
  {left
    \ How an {goto altsclause alternate} form type is a subtype of a type.}}
 {row
  {left \ {goto altsclause 5.10.2.2.}}
  {center {goto rule31 31}}
  {left \ How an alternate form type is a subtype of a type.}}
 {row
  {left \ {goto altsclause 5.10.2.2.}}
  {center {goto rule32 32}}
  {left \ How a type is a subtype of an alternate form type.}}
 {row
  {left \ {goto altsclause 5.10.2.2.}}
  {center {goto rule33 33}}
  {left \ How a type is a subtype of an alternate form type.}}
 {row
  {left \ {goto tupleclause 5.10.2.13.\ }}
  {center {goto rule34 34}}
  {left \ How a {goto tupleclause tuple} type is a subtype of a tuple type.}}
 {row
  {left \ {goto char 7.1.2.}}
  {center {goto rule35 35}}
  {left \ How a {goto char character} type is a cotype of a character type.}}
 {row
  {left \ {goto char 7.1.2.}}
  {center {goto rule36 36}}
  {left \ How a character type is a cotype of an integer type.}}
 {row
  {left \ {goto int 7.1.3.}}
  {center {goto rule37 37}}
  {left \ How an integer type is a cotype of a type.}}
 {row
  {left \ {goto null 7.1.5.}}
  {center {goto rule38 38}}
  {left \ How the {goto {i null}} type is a subtype of a {i ref} type.}}
 {row
  {left \ {goto null 7.1.5.}}
  {center {goto rule39 39}}
  {left \ How the {i null} type is a subtype of a {i row} type.}}
 {row
  {left \ {goto null 7.1.5.}}
  {center {goto rule40 40}}
  {left \ How the {i null} type is a subtype of a Skolem type.}}
 {row
  {left \ {goto null 7.1.5.}}
  {center {goto rule41 41}}
  {left \ How the {i null} type is a subtype of a Skolem type.}}
 {row
  {left \ {goto real 7.1.6.}}
  {center {goto rule42 42}}
  {left \ How a {goto real} type is a cotype of a type.}}
 {row
  {left \ {goto alj 7.2.1.}}
  {center {goto rule43 43}}
  {left
    \ How a type is a subtype of the {goto joker} type {goto alj {i alj.}}}}
 {row
  {left \ {goto cha 7.2.2.}}
  {center {goto rule44 44}}
  {left \ How a type is a subtype of the joker type {goto cha {i cha.}}}}
 {row
  {left \ {goto exe 7.2.3.}}
  {center {goto rule45 45}}
  {left \ How a type is a subtype of the joker type {goto exe {i exe.}}}}
 {row
  {left \ {goto exe 7.2.3.}}
  {center {goto rule46 46}}
  {left \ How a type is a subtype of the joker type {i exe.}}}
 {row
  {left \ {goto foj 7.2.4.}}
  {center {goto rule47 47}}
  {left \ How a type is a subtype of the joker type {goto foj {i foj.}}}}
 {row
  {left \ {goto foj 7.2.4.}}
  {center {goto rule48 48}}
  {left \ How a type is a subtype of the joker type {i foj.}}}
 {row
  {left \ {goto foj 7.2.4.}}
  {center {goto rule49 49}}
  {left \ How a type is a subtype of the joker type {i foj.}}}
 {row
  {left \ {goto gej 7.2.5.}}
  {center {goto rule50 50}}
  {left \ How a type is a subtype of the joker type {goto gej {i gej.}}}}
 {row
  {left \ {goto inj 7.2.6.}}
  {center {goto rule51 51}}
  {left \ How a type is a subtype of the joker type {goto inj {i inj.}}}}
 {row
  {left \ {goto met 7.2.7.}}
  {center {goto rule52 52}}
  {left \ How a type is a subtype of the joker type {goto met {i met.}}}}
 {row
  {left \ {goto met 7.2.7.}}
  {center {goto rule53 53}}
  {left \ How a type is a subtype of the joker type {i met.}}}
 {row
  {left \ {goto mut 7.2.8.}}
  {center {goto rule54 54}}
  {left \ How a type is a subtype of the joker type {goto mut {i mut.}}}}
 {row
  {left \ {goto mut 7.2.8.}}
  {center {goto rule55 55}}
  {left \ How a type is a subtype of the joker type {i mut.}}}
 {row
  {left \ {goto mut 7.2.8.}}
  {center {goto rule56 56}}
  {left \ How a type is a subtype of the joker type {i mut.}}}
 {row
  {left \ {goto mut 7.2.8.}}
  {center {goto rule57 57}}
  {left \ How a type is a subtype of the joker type {i mut.}}}
 {row
  {left \ {goto num 7.2.9.}}
  {center {goto rule58 58}}
  {left \ How a type is a subtype of the joker type {goto num {i num.}}}}
 {row
  {left \ {goto num 7.2.9.}}
  {center {goto rule59 59}}
  {left \ How a type is a subtype of the joker type {i num.}}}
 {row
  {left \ {goto obj 7.2.10.}}
  {center {goto rule60 60}}
  {left \ How a type is a subtype of the joker type {goto obj {i obj.}}}}
 {row
  {left \ {goto plj 7.2.11.}}
  {center {goto rule61 61}}
  {left \ How a type is a subtype of the joker type {goto plj {i plj.}}}}
 {row
  {left \ {goto pro 7.2.12.}}
  {center {goto rule62 62}}
  {left \ How a type is a subtype of the joker type {goto pro {i pro.}}}}
 {row
  {left \ {goto rej 7.2.13.}}
  {center {goto rule63 63}}
  {left \ How a type is a subtype of the joker type {goto rej {i rej.}}}}
 {row
  {left \ {goto sca 7.2.14.}}
  {center {goto rule64 64}}
  {left \ How a type is a subtype of the joker type {goto sca {i sca.}}}}
 {row
  {left \ {goto sca 7.2.14.}}
  {center {goto rule65 65}}
  {left \ How a type is a subtype of the joker type {i sca.}}}
 {row
  {left \ {goto sca 7.2.14.}}
  {center {goto rule66 66}}
  {left \ How a type is a subtype of the joker type {i sca.}}}
 {row
  {left \ {goto sca 7.2.14.}}
  {center {goto rule67 67}}
  {left \ How a type is a subtype of the joker type {i sca.}}}
 {row
  {left \ {goto str 7.2.15.}}
  {center {goto rule68 68}}
  {left \ How a type is a subtype of the joker type {goto str {i str.}}}}
 {row
  {left \ {goto str 7.2.15}}
  {center {goto rule69 69}}
  {left \ How a type is a subtype of the joker type {i str.}}}
 {row
  {left \ {goto sym 7.2.16.}}
  {center {goto rule70 70}}
  {left \ How a type is a subtype of the joker type {goto sym {i sym.}}}}
 {row
  {left \ {goto tup 7.2.17.}}
  {center {goto rule71 71}}
  {left \ How a type is a subtype of the joker type {goto tup {i tup.}}}}
 {row
  {left \ {goto tup 7.2.17.}}
  {center {goto rule72 72}}
  {left \ How a type is a subtype of the joker type {i tup.}}}
 {row
  {left \ {goto prebracket 7.3.34.}}
  {center {goto rule73 73}}
  {left \ How an array type is a subtype of an array type.}}
 {row
  {left \ {goto prebracket 7.3.34.}}
  {center {goto rule74 74}}
  {left \ How an array type is a subtype of an array joker type.}}
 {row
  {left \ {goto prebracket 7.3.34.}}
  {center {goto rule75 75}}
  {left \ How an array joker type is a subtype of an array joker type.}}
 {row
  {left \ {goto slot 7.3.82.}}
  {center {goto rule76 76}}
  {left \ How a tuple type is a subtype of a {goto slot} joker type.}}
 {row
  {left \ {goto slot 7.3.82.}}
  {center {goto rule77 77}}
  {left \ How a tuple type is a subtype of a slot joker type.}}
 {row
  {left \ {goto slot 7.3.82.}}
  {center {goto rule78 78}}
  {left \ How a slot joker type is a subtype of a slot joker type.}}}

{label namepart}
{left {b 4.6. Names as parts of types.}}

{justify
  Some {goto type types} have {goto nametoken names} as parts.
  For example, the {goto tupleclause tuple} type
  ({b tuple}\ {i real}\ {i re,}\ {i real}\ {i im}) might describe a complex
  number.
  It has the type {goto {i real}} and the names {i re} and {i im} as its parts.
  When Orson tests if one type is a {goto subtype} of another, it compares both
  their type parts and their name parts.
  For example, the tuple type ({b tuple}\ {i real}\ {i re,}\ {i real}\ {i im})
  is not a subtype of the tuple type ({b tuple}\ {i real}\ ρ,\ {i real}\ θ) or
  vice versa, because they have different names as parts.}

{label missing}
{left {b 4.6.1. Missing names.}}

{justify
  {goto nametoken Names} can sometimes be omitted from {goto type types} in
  which they would otherwise appear as {goto namepart parts.}
  A type with omitted names describes an {goto object} with unused parts.
  For example, the {goto tupleclause tuple} type
  ({b tuple}\ {i real}\ {i re,}\ {i real}) describes a tuple with two
  {goto {i real}} slots, but only the slot with the name {i re} is used.

  When a name is omitted from a type, it is convenient to imagine that the
  {i missing name} appears in its place.
  In this Report, the missing name may appear as a dotted box ⬚.
  For example, it is convenient to imagine that
  ({b tuple}\ {i real}\ {i re,}\ {i real}) is actually
  ({b tuple}\ {i real}\ {i re,}\ {i real}\ ⬚).}

{label subname}
{left {b 4.6.2. Subnames.}}

{justify
  Since some {goto type types} can contain {goto nametoken names} as
  {goto namepart parts,} it is convenient to define {i subnames} by analogy
  with {goto subtype subtypes.}
  If {i l} and {i r} are names, then the notation {i l}\ ⊆\ {i r} means that
  {i l} is a subname of {i r.}
  This is the same notation used for subtypes.
  Subnames are described by {goto rule rules} {b 2} and {b 3.}}

{narrow
 {label rule02}
 {label rule03}
 {layout
  {row
   {over
    {center {i l} ⊆ {i l}}
    {left \ {b 2}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i l} ⊆ ⬚}
    {left \ {b 3}}
    {center {i true}}}}}}

{justify
  Rule {b 2} says that a name is a subname of another name if both names are
  {goto identical identical.}
  Rule {b 3} says that any name is a subname of the {goto missing} name ⬚.
  However, the missing name is not a subname of any name other than itself.

  Suppose that a type is tested to decide if it is a subtype of another type,
  and that both types have names as parts.
  Then the subname relation decides if the names match each other, with the
  missing name ⬚ matching any name.
  For example, the two {goto tupleclause tuple} types
  ({b tuple}\ {i real}\ {i re,}\ {i real}\ {i im}) and
  ({b tuple}\ {i real}\ ρ,\ {i real}\ θ)
  are subtypes of ({b tuple}\ {i real,}\ {i real}).}

{label distinct}
{left {b 4.6.3. Distinct names.}}

{justify
  If a {goto type} contains two or more {goto nametoken names} as
  {goto namepart parts,} then each name {goto must} be {i distinct} from the
  other names in that type.
  Two names are distinct if at least one of them is the {goto missing} name ⬚.
  If neither name is missing, then they are distinct if they are not
  {goto identical identical.}}

{label joker}
{left {b 4.7. Jokers.}}

{justify
  A {i joker} is a {goto type} that describes infinitely many
  {goto object objects,} all of which share certain properties.
  A type is a {goto subtype} of a joker if all objects of that type have the
  properties described by the joker.
  For example, the joker {goto {i inj}} describes all integers, so that any
  {goto int integer} type is its subtype.
  Similarly, the joker {goto {i rej}} describes all reals, so that any
  {goto real} type is its subtype.

  Any joker may have subtypes that are not described in this Report.
  As a result, if types are considered to be {goto subtype sets} of objects,
  then no joker is necessarily the union of two or more other types.
  For example, the joker {goto {i num}} describes all numbers, so that {i inj}
  and {i rej} are its subtypes.
  However, Orson may also provide {goto unspecified} numeric types along with
  integer and real types, so {i num} is not necessarily the union of {i inj}
  and {i rej.}

  The name {i joker} comes from card games {goto usp1941 {c [usp 1941]}} in
  which joker cards are said to be ``wild,'' so they match cards in somewhat
  the same way that jokers match types.
  Jokers, and all types that have jokers as parts, are
  {goto object transformation} objects.}

{label typesize}
{left {b 4.8. Sizes.}}

{justify
  Each {goto type} {i t} has a {i size,} written as {i size}({i t}).
  The size of an {goto object execution} type without {goto joker jokers} is
  the number of bytes needed to represent an {goto object instance} of that
  type in memory (it may be 0).
  The size of any other type is −1.
  If {i l} and {i r} are both execution types without jokers, and {i l} is a
  {goto subtype} of {i r,} then {i l} and {i r} have equal sizes.}

{rule}

{label expression}
{left {b 5. Expressions.}}

{narrow
 {justify
   Making useful objects is dreary work, but making them according to the
   mysterious laws of formal expression is halfway to happiness.}
 {right
  {goto bel1981 {c [bel 1981]}}}}

{justify
  Orson's {i expressions} are written with the infix, prefix, and postfix
  operators in the following table.
  Rows of the table are in order of increasing precedence, and operators in the
  same row have equal precedence.
  For example, the infix operators `+' and `−' have equal precedence, but both
  have higher precedence than the infix operator `\ <\ '.
  The table also includes notations like `\ [\ ]\ ' that do not look like
  operators, but which are discussed along with them.
  {goto clause Clauses} are {goto unit units} that do not involve operators, so
  they do not appear in the table.}

{table
 {row
  {center {b \ Section\ }}
  {center {b Name}}
  {center {b Place}}
  {center {b Operators}}}
 {row
  {left {goto sequence \ 5.1.}}
  {left \ Sequence}
  {left \ Infix}
  {left {b \ also}}}
 {row
  {left {goto subsequence \ 5.2.}}
  {left \ Subsequence\ }
  {left \ Infix}
  {left \ ;}}
 {row
  {left {goto assignment \ 5.3.}}
  {left \ Assignment}
  {left \ Infix}
  {display
 &=  ⁎=  /=  :=  <<=  >>=  +=  -=  |=  ~=  ×=  −=  
 ∘=  ∙=  ∩=  ∪=  ⊓=  ⊔=  ⊕=  ⊖=  ⊗=  ⊘=  ⊙=}}
 {row
  {left {goto disjunction \ 5.4.}}
  {left \ Disjunction}
  {left \ Infix}
  {display
 ∨  {b or}}}
 {row
  {left {goto conjunction \ 5.5.}}
  {left \ Conjunction}
  {left \ Infix}
  {display
 ∧  {b and}}}
 {row
  {left {goto comparison \ 5.6.}}
  {left \ Comparison\ }
  {left \ Infix}
  {display
 <  <=  <>  =  >  >=  ∊  ∍  ≠  ≡  ≢  ≤  ≥  
 ≺  ≻  ≼  ≽  ⊂  ⊃  ⊆  ⊇  ⊏  ⊐  ⊑  ⊒}}
 {row
  {left {goto sum \ 5.7.}}
  {left \ Sum}
  {left \ Infix}
  {display
 +  -  |  ~  −  ∘  ∪  ⊔  ⊕  ⊖}}
 {row
  {left {goto product \ 5.8.}}
  {left \ Product}
  {left \ Infix}
  {display
 &  ⁎  /  <<  >>  ←  →  ×  ∙  ∩  ⊓  ⊗  ⊘  ⊙  {b mod}}}
 {row
  {left {goto term \ 5.9.}}
  {left \ Term}
  {left \ Prefix}
  {display
 +  -  [ ]  \{ \}  ~  −  ¬  ⊕  ⊖  {b not}  {b ref}  {b row}  {b type}  {b var} }}
 {row
  {left {goto unit \ 5.10.}}
  {left \ Unit}
  {left \ Postfix\ }
  {display
 ( )  .  @  [ ]  ^  \{ \}  ↑  ↓}}}

{justify
  Most expressions {goto abbreviate} {goto call calls} to {goto call methods}
  whose {goto quoted} names are {goto bind bound} by the standard
  {goto prelude prelude.}
  For example, 
  the {goto sum} {i l}\ +\ {i r} abbreviates {i "}+{i "}({i l,}\ {i r}),
  the {goto term} −\ {i r} abbreviates {i "}−{i "}({i r}), and the unit
  {i l}\ ↑ abbreviates {i "}↑{i "}({i l}).
  Operators that abbreviate calls can be redefined by {goto bind rebinding}
  their {goto nametoken names.}

  Other expressions abbreviate calls to methods whose names are not bound by
  the standard prelude.
  They can be used only after the names are bound to methods.
  For example, binding {i "}⊕{i "} to an appropriate method allows using
  expressions like {i l}\ ⊕\ {i r} and ⊕\ {i r.}
  They abbreviate {i "}⊕{i "}({i l,}\ {i r}) and {i "}⊕{i "}({i r}),
  respectively.

  The infix {goto sequence} operator, the {goto assignment} operators, and the
  {goto comparison} operators do not associate.
  All other infix operators associate to the left, so that
  {i l}\ +\ {i m}\ −\ {i r} abbreviates ({i l}\ +\ {i m})\ −\ {i r,} which in
  turn abbreviates {i "}−{i "}({i "}+{i "}({i l,}\ {i m}),\ {i r}).
  All the prefix operators associate to the right, so that ~\ −\ {i r}
  abbreviates ~\ (−\ {i r}), which in turn abbreviates
  {i "}~{i "}({i "}−{i "}({i r})).
  All the postfix operators associate to the left, so that {i l}↑[] abbreviates
  ({i l}↑)[], which in turn abbreviates {i "}␣[]{i "}({i "}↑{i "}({i l})).}

{label sequence}
{left {b 5.1. Sequences.}}

{justify
  A {i sequence} may be a {goto subsequence subsequence.}
  If {i l} and {i r} are subsequences, then {i l}\ {b also}\ {i r} is a
  sequence as well.
  It {goto abbreviate abbreviates} this {goto withclause {i with}} clause,
  where {i u} is a {goto unique} name that appears nowhere else.}

{narrow
 {left
  ({b with} {i u} :− ({i l}) {b do} {i r} ; {i u})}}

{justify
  As a result of the abbreviation, {i l}\ {b also}\ {i r} first
  {goto evaluate evaluates} {i l,} then evaluates {i r,} and finally returns
  the {goto object} to which {i l} evaluates.
  The type of the sequence is the {goto type} of {i l.}
  Since {i r} is {goto execute executed} only for its side effects, it
  {goto must} have an {goto object execution} type.
  For example, if {i v} is an {goto int integer} {goto vartype variable,} then
  {i v}\ {b also}\ {i v}\ +=\ 1 {goto plusequal increments} {i v} and returns
  {i v}'s previous value.

  To improve readability, Orson prohibits writing a sequence with two or more
  {b also} operators, like {i l}\ {b also}\ {i m}\ {b also}\ {i r.}
  This prohibition can be avoided by using parentheses, but there is no need to
  do so, since an equivalent sequence can be written more clearly using one
  {b also} operator and a subsequence.
  For example, ({i l}\ {b also}\ {i m})\ {b also}\ {i r} and
  {i l}\ {b also}\ ({i m}\ {b also}\ {i r}) can be written as
  ({i l}\ {b also}\ {i m}\ ;\ {i r}).}

{label subsequence}
{left {b 5.2. Subsequences.}}

{justify
  A {i subsequence} can be an {goto assignment assignment.}
  If the {i e}'s are two or more assignments, then the following is also a
  subsequence.
  There can be an extra {goto semicolon} after the last {i e.}}

{narrow
 {left
  {i e}{- 1} ; {i e}{- 2} ... ; {i e}{-i k}}}

{justify
  The subsequence {goto evaluate evaluates} its assignments, one at a time, in
  order of appearance.
  It returns the {goto object} to which its last assignment evaluates.
  The {goto type} of the subsequence is the type of its last assignment.
  For example, if {i v} is an {goto int integer} {goto vartype variable,} then
  ({i v}\ +=\ 1\ ;\ {i v}) {goto plusequal increments} {i v} and returns
  {i v}'s new value.

  Each subsequence {goto transform transforms} to a new subsequence that is
  made by transforming its assignments, one at a time, in order of appearance.
  If any assignment except the last transforms to a {goto constant constant,}
  then it is omitted from the new subsequence.
  After transformation, if the new subsequence has only one assignment, then
  that assignment can have any type.
  If it has more than one assignment, then all the assignments {goto must} have
  {goto object execution} types.

  The transformed subsequence is {goto execute executed} by executing its
  assignments, one at a time, in order of appearance.
  All the assignments except the last one are executed for their side effects.
  The subsequence finally {goto execute executes} to the object returned by
  its last assignment.}

{label assignment}
{left {b 5.3. Assignments.}}

{justify
  An {i assignment} can be a {goto disjunction disjunction.}
  If {i l} and {i r} are disjunctions, then the {goto expression expressions}
  in the following table are also assignments.
  Some assignments {goto abbreviate} {goto call calls} to forms whose
  {goto quoted} names are {goto bind bound} by the standard
  {goto prelude prelude.}
  These forms are described in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b \ \ Assignment\ \ }}
  {center {b Call}}}
 {row
  {left {goto ampequal \ \ 7.3.4.}}
  {center {i l} &= {i r}}
  {center {i "}&={i "}({i l,}\ {i r})}}
 {row
  {left {goto starequal \ \ 7.3.6.}}
  {center {i l} ⁎= {i r}}
  {center {i "}⁎={i "}({i l,}\ {i r})}}
 {row
  {left {goto starequal \ \ 7.3.6.}}
  {center {i l} ×= {i r}}
  {center {i "}×={i "}({i l,}\ {i r})}}
 {row
  {left {goto plusequal \ \ 7.3.8.}}
  {center {i l} += {i r}}
  {center {i "}+={i "}({i l,}\ {i r})}}
 {row
  {left {goto dashequal \ \ 7.3.10.}}
  {center {i l} -= {i r}}
  {center {i "}-={i "}({i l,}\ {i r})}}
 {row
  {left {goto dashequal \ \ 7.3.10.}}
  {center {i l} −= {i r}}
  {center {i "}−={i "}({i l,}\ {i r})}}
 {row
  {left {goto slashequal \ \ 7.3.13.}}
  {center {i l} /= {i r}}
  {center {i "}/={i "}({i l,}\ {i r})}}
 {row
  {left {goto colonequal \ \ 7.3.14.}}
  {center {i l} := {i r}}
  {center {i "}:={i "}({i l,}\ {i r})}}
 {row
  {left {goto leftequal \ \ 7.3.19.}}
  {center {i l} <<= {i r}}
  {center {i "}<<={i "}({i l,}\ {i r})}}
 {row
  {left {goto leftequal \ \ 7.3.19.}}
  {center {i l} ←= {i r}}
  {center {i "}←={i "}({i l,}\ {i r})}}
 {row
  {left {goto rightequal \ \ 7.3.29.}}
  {center {i l} >>= {i r}}
  {center \ \ \ \ {i "}>>={i "}({i l,}\ {i r})\ \ \ \ }}
 {row
  {left {goto rightequal \ \ 7.3.29.}}
  {center {i l} →= {i r}}
  {center {i "}→={i "}({i l,}\ {i r})}}
 {row
  {left {goto barequal \ \ 7.3.37.}}
  {center {i l} |= {i r}}
  {center {i "}|={i "}({i l,}\ {i r})}}
 {row
  {left {goto tildeequal \ \ 7.3.39.}}
  {center {i l} ~= {i r}}
  {center {i "}~={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ∘= {i r}}
  {center {i "}∘={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} {t ∙}= {i r}}
  {center {i "}{t ∙}={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ∩= {i r}}
  {center {i "}∩={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ∪= {i r}}
  {center {i "}∪={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊓= {i r}}
  {center {i "}⊓={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊔= {i r}}
  {center {i "}⊔={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊕= {i r}}
  {center {i "}⊕={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊖= {i r}}
  {center {i "}⊖={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊗= {i r}}
  {center {i "}⊗={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊘= {i r}}
  {center {i "}⊘={i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊙= {i r}}
  {center {i "}⊙={i "}({i l,}\ {i r})}}}

{justify
  By convention, the names of assignment operators are bound to forms that
  change the values of {goto vartype variables} as side effects.
  This Report also uses the word {i assignment} to mean an expression that is
  not a {goto sequence} or a {goto subsequence subsequence,} whether it uses an
  assignment operator or not.
  This is consistent with the terminology of Orson's {goto syntax syntax.}

  Assignment operators do not associate, so an assignment like
  {i l}\ :=\ {i m}\ :=\ {i r} is prohibited.
  This prohibition may be avoided by using parentheses, as in
  {i l}\ :=\ ({i m}\ :=\ {i r}).
  However, it is not useful, because the standard prelude binds the names of
  assignment operators to forms whose calls {goto evaluate} to
  {goto void {i skip.}}}

{label disjunction}
{left {b 5.4. Disjunctions.}}

{justify
  A {i disjunction} can be a {goto conjunction conjunction.}
  If the {i e}'s are two or more conjunctions that {goto evaluate} to
  {goto int integers,} then this {goto expression} is also a disjunction.
  The {goto symboltoken symbol} {b or} may appear instead of the symbol `∨'.}

{narrow{orson
e{- 1} ∨  e{- 2} ... ∨ e{-i k}}}

{justify
  The disjunction {goto abbreviate abbreviates} the following nested
  {goto ifclause {i if}} clauses and {goto withclause {i with}} clauses, in
  which {i u} is a {goto unique} name that appears nowhere else.
  The {i with} clauses ensure that each {i e} is evaluated at most once.}

{narrow{orson
(with u :− e{- 1}
 do (if u{- \ }
     then u{- \ }
     else (with u :− e{- 2}
           do (if u{- \ }
               then u{- \ }
               else ...
                    (with u :− e{- {i k}−1}
                     do (if u{- \ }
                         then u{- \ }
                         else e{-i k})) ... ))))}}

{justify
  As a result of the abbreviation, the disjunction evaluates the {i e}'s one at
  a time, in order of appearance.
  If some {i e} evaluates to an integer other than 0, then the disjunction
  immediately evaluates to that integer, without evaluating the remaining
  {i e}'s.
  If all the {i e}'s evaluate to 0, then the disjunction also evaluates to 0.}

{label conjunction}
{left {b 5.5. Conjunctions.}}

{justify
  A {i conjunction} can be a {goto comparison comparison.}
  If the {i e}'s are two or more comparisons that {goto evaluate} to
  {goto int integers,} then this {goto expression} is also a conjunction.
  The {goto symboltoken symbol} {b and} may appear instead of the symbol `∧'.}

{narrow{orson
e{- 1} ∧ e{- 2} ... ∧ e{-i k}}}

{justify
  The conjunction {goto abbreviate abbreviates} this nested
  {goto ifclause {i if}} clause.}

{narrow
 {left
  ({b if} {i e}{- 1}
   {b then} ({b if} {i e}{- 2}
             {b then} ...
                      ({b if} {i e}{- {i k}−1}
                       {b then} {i e}{-i k}
                       {b else} 0)
                      ...
             {b else} 0)
   {b else} 0)}}

{justify
  As a result of the abbreviation, the conjunction evaluates the {i e}'s one at
  a time, in order of appearance.
  If some {i e} evaluates to 0, then the conjunction immediately evaluates to
  0, without evaluating the remaining {i e}'s.
  If no {i e}'s evaluate to 0, then the conjunction evaluates to the integer
  that is returned by the last {i e.}}

{label comparison}
{left {b 5.6. Comparisons.}}

{justify
  A {i comparison} can be a {goto sum sum.}
  If the {i e}'s are two or more sums, and the ◇'s are one or more comparison
  operators `<', `<=', `<>', `=', `>', `>=', `∊', `∍', `≠', `≡', `≢', `≤', `≥',
  `≺', `≻', `≼', `≽', `⊂', `⊃', `⊆', `⊇', `⊏', `⊐', `⊑', or `⊒', then this
  {goto expression} is also a comparison.}

{narrow{orson
e{- 1} ◇{- 1} e{- 2} ◇{- 2} e{- 3} ... ◇{- k−1} e{- k}}}

{justify
  The comparison {goto abbreviate abbreviates} a {goto call} to a
  {goto call method} whose {goto quoted} name is constructed by concatenating
  the names of the comparison operators, separated by {goto unicode blanks.}}

{narrow
 {left
  {i "}◇{- 1}␣◇{- 2} ... ␣◇{- {i k}−1}{i "}({i e}{- 1}, {i e}{- 2}, {i e}{- 3} ..., {i e}{-i k})}}

{justify
  For example, {i l}\ >\ {i r} abbreviates {i "}>{i "}({i l,}\ {i r}) and
  {i l}\ <\ {i m}\ ≤\ {i r} abbreviates {i "}<␣≤{i "}({i l,}\ {i m,}\ {i r}).
  The following table shows the comparison operators whose quoted names are
  {goto bind bound} to forms by the standard {goto prelude prelude.}
  These forms are discussed in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b \ \ Comparison\ \ }}
  {center {b \ \ Call\ \ }}}
 {row
  {left {goto lt \ \ 7.3.15.}}
  {center {i l} < {i r}}
  {center {i "}<{i "}({i l,}\ {i r})}}
 {row
  {left {goto le \ \ 7.3.20.}}
  {center {i l} <= {i r}}
  {center {i "}<={i "}({i l,}\ {i r})}}
 {row
  {left {goto le \ \ 7.3.20.}}
  {center {i l} ≤ {i r}}
  {center {i "}≤{i "}({i l,}\ {i r})}}
 {row
  {left {goto ne \ \ 7.3.23.}}
  {center {i l} <> {i r}}
  {center {i "}<>{i "}({i l,}\ {i r})}}
 {row
  {left {goto ne \ \ 7.3.23.}}
  {center {i l} ≠ {i r}}
  {center {i "}≠{i "}({i l,}\ {i r})}}
 {row
  {left {goto eq \ \ 7.3.24.}}
  {center {i l} = {i r}}
  {center {i "}={i "}({i l,}\ {i r})}}
 {row
  {left {goto gt \ \ 7.3.25.}}
  {center {i l} > {i r}}
  {center {i "}>{i "}({i l,}\ {i r})}}
 {row
  {left {goto ge \ \ 7.3.30.}}
  {center {i l} >= {i r}}
  {center {i "}>={i "}({i l,}\ {i r})}}
 {row
  {left {goto ge \ \ 7.3.30.}}
  {center {i l} ≥ {i r}}
  {center {i "}≥{i "}({i l,}\ {i r})}}
 {row
  {left {goto ltlt \ \ 7.3.16.}}
  {center {i l} < {i m} < {i r}}
  {center {i "}<␣<{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto ltle \ \ 7.3.17.}}
  {center {i l} < {i m} <= {i r}}
  {center {i "}<␣<={i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto ltle \ \ 7.3.17.}}
  {center {i l} < {i m} ≤ {i r}}
  {center {i "}<␣≤{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto lelt \ \ 7.3.21.}}
  {center {i l} <= {i m} < {i r}}
  {center {i "}<=␣<{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto lelt \ \ 7.3.21.}}
  {center {i l} ≤ {i m} < {i r}}
  {center {i "}≤␣<{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto lele \ \ 7.3.22.}}
  {center {i l} <= {i m} <= {i r}}
  {center {i "}<=␣<={i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto lele \ \ 7.3.22.}}
  {center {i l} ≤ {i m} ≤ {i r}}
  {center {i "}≤␣≤{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gtgt \ \ 7.3.26.}}
  {center {i l} > {i m} > {i r}}
  {center \ \ \ \ {i "}>␣>{i "}({i l,}\ {i m,}\ {i r})\ \ \ \ }}
 {row
  {left {goto gtge \ \ 7.3.27.}}
  {center {i l} > {i m} >= {i r}}
  {center {i "}>␣>={i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gtge \ \ 7.3.27.}}
  {center {i l} > {i m} ≥ {i r}}
  {center {i "}>␣≥{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gegt \ \ 7.3.31.}}
  {center {i l} >= {i m} > {i r}}
  {center {i "}>=␣>{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gegt \ \ 7.3.31.}}
  {center {i l} ≥ {i m} > {i r}}
  {center {i "}≥␣>{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gege \ \ 7.3.32.}}
  {center {i l} >= {i m} >= {i r}}
  {center {i "}>=␣>={i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto gege \ \ 7.3.32.}}
  {center {i l} ≥ {i m} ≥ {i r}}
  {center {i "}≥␣≥{i "}({i l,}\ {i m,}\ {i r})}}
 {row
  {left {goto issubsumed \ \ 7.3.72.}}
  {center {i l} ≼ {i r}}
  {center {i "}≼{i "}({i l,}\ {i r})}}
 {row
  {left {goto issubtype \ \ 7.3.73.}}
  {center {i l} ⊆ {i r}}
  {center {i "}⊆{i "}({i l,}\ {i r})}}
 {row
  {left {goto iscotype \ \ 7.3.63.}}
  {center {i l} ⊑ {i r}}
  {center {i "}⊑{i "}({i l,}\ {i r})}}}

{label sum}
{left {b 5.7. Sums.}}

{justify
  A {i sum} can be a {goto product product.}
  If {i l} is a product and {i r} is a sum, then the
  {goto expression expressions} in the following table are also sums.
  A few sums {goto abbreviate} {goto call calls} to forms whose {goto quoted}
  names are {goto bind bound} by the standard {goto prelude prelude.}
  These forms are described in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b \ \ \ \ Sum\ \ \ \ }}
  {center {b \ \ \ \ Call\ \ \ \ }}}
 {row
  {left {goto plus \ \ 7.3.7.}}
  {center {i l} + {i r}}
  {center {i "}+{i "}({i l,} {i r})}}
 {row
  {left {goto dash \ \ 7.3.9.}}
  {center {i l} - {i r}}
  {center {i "}-{i "}({i l,} {i r})}}
 {row
  {left {goto dash \ \ 7.3.9.}}
  {center {i l} − {i r}}
  {center {i "}−{i "}({i l,} {i r})}}
 {row
  {left {goto bar \ \ 7.3.36.}}
  {center {i l} | {i r}}
  {center {i "}|{i "}({i l,} {i r})}}
 {row
  {left {goto tilde \ \ 7.3.38.}}
  {center {i l} ~ {i r}}
  {center {i "}~{i "}({i l,} {i r})}}
 {row
  {left \ }
  {center {i l} ∘ {i r}}
  {center {i "}∘{i "}({i l,} {i r})}}
 {row
  {left \ }
  {center {i l} ∪ {i r}}
  {center {i "}∪{i "}({i l,} {i r})}}
 {row
  {left \ }
  {center {i l} ⊔ {i r}}
  {center {i "}⊔{i "}({i l,} {i r})}}
 {row
  {left \ }
  {center {i l} ⊕ {i r}}
  {center {i "}⊕{i "}({i l,} {i r})}}
 {row
  {left \ }
  {center {i l} ⊖ {i r}}
  {center {i "}⊖{i "}({i l,} {i r})}}}

{label product}
{left {b 5.8. Products.}}

{justify
  A {i product} can be a {goto term term.}
  If {i l} is a term and {i r} is a product, then the
  {goto expression expressions} in the following table are also products.
  Some products {goto abbreviate} {goto call calls} to forms whose
  {goto quoted} names are {goto bind bound} by the standard
  {goto prelude prelude.}
  These forms are described in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b \ \ \ \ Product\ \ \ \ }}
  {center {b \ \ \ \ Call\ \ \ \ }}}
 {row
  {left {goto ampersand \ \ 7.3.3.}}
  {center {i l} & {i r}}
  {center {i "}&{i "}({i l,}\ {i r})}}
 {row
  {left {goto star \ \ 7.3.5.}}
  {center {i l} ⁎ {i r}}
  {center {i "}⁎{i "}({i l,}\ {i r})}}
 {row
  {left {goto star \ \ 7.3.5.}}
  {center {i l} × {i r}}
  {center {i "}×{i "}({i l,}\ {i r})}}
 {row
  {left {goto slash \ \ 7.3.12.}}
  {center {i l} / {i r}}
  {center {i "}/{i "}({i l,}\ {i r})}}
 {row
  {left {goto left \ \ 7.3.18.}}
  {center {i l} << {i r}}
  {center {i "}<<{i "}({i l,}\ {i r})}}
 {row
  {left {goto left \ \ 7.3.18.}}
  {center {i l} ← {i r}}
  {center {i "}←{i "}({i l,}\ {i r})}}
 {row
  {left {goto right \ \ 7.3.28.}}
  {center {i l} >> {i r}}
  {center {i "}>>{i "}({i l,}\ {i r})}}
 {row
  {left {goto right \ \ 7.3.28.}}
  {center {i l} → {i r}}
  {center {i "}→{i "}({i l,}\ {i r})}}
 {row
  {left {goto mod \ \ 7.3.42.}}
  {center {i l} {b mod} {i r}}
  {center {i "}mod{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} {t ∙} {i r}}
  {center {i "}{t ∙}{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ∩ {i r}}
  {center {i "}∩{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊓ {i r}}
  {center {i "}⊓{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊗ {i r}}
  {center {i "}⊗{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊘ {i r}}
  {center {i "}⊘{i "}({i l,}\ {i r})}}
 {row
  {left \ }
  {center {i l} ⊙ {i r}}
  {center {i "}⊙{i "}({i l,}\ {i r})}}}

{label term}
{left {b 5.9. Terms.}}

{justify
  A {i term} can be a {goto unit unit.}
  Suppose
  that the {i g}'s are terms,
  that the {i l}'s are {goto assignment assignments,}
  that the {i m}'s are assignments,
  that the {i n}'s are {goto distinct} {goto nametoken names,}
  that {i r} is a term,
  that the {i t}'s are terms,
  and
  that {i y} is a term.
  Then the {goto expression expressions} in the following table are also terms.
  Some terms {goto abbreviate} {goto call calls} to forms whose {goto quoted}
  names are {goto bind bound} by the standard {goto prelude prelude.}
  These forms are described in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b Term}}
  {center {b Call}}}
 {row
  {left {goto plus \ \ 7.3.7.}}
  {left + {i r}}
  {left {i "}+{i "}({i r})}}
 {row
  {left {goto dash \ \ 7.3.9.}}
  {left - {i r}}
  {left {i "}-{i "}({i r})}}
 {row
  {left {goto dash \ \ 7.3.9.}}
  {left − {i r}}
  {left {i "}−{i "}({i r})}}
 {row
  {left {goto prebracket \ \ 7.3.34.}}
  {left [{i l}{- 1}, {i l}{- 2} ..., {i l}{-i j}] {i r}}
  {left {i "}[]␣{i "}({i l}{- 1}, {i l}{- 2} ..., {i l}{-i j}, {i r})}}
 {row
  {left \ }
  {left
    [{i l}{- 1}, {i l}{- 2} ..., {i l}{-i j} :
     {i m}{- 1}, {i m}{- 2} ..., {i m}{-i k}] {i r}}
  {left
    {i "}[]␣{i "}({i l}{- 1}, {i l}{- 2} ..., {i l}{-i j},
          (: {i m}{- 1}, {i m}{- 2} ..., {i m}{-i k}),
          {i r})}}
 {row
  {left \ }
  {left \{{i l}{- 1}, {i l}{- 2} ..., {i l}{-i j}\} {i r}}
  {left {i "}\{\}␣{i "}({i l}{- 1}, {i l}{- 2} ..., {i l}{-i j}, {i r})}}
 {row
  {left \ }
  {left
    \{{i l}{- 1}, {i l}{- 2} ..., {i l}{-i j} :
      {i m}{- 1}, {i m}{- 2} ..., {i m}{-i k}\} {i r}}
  {left
    {i "}\{\}␣{i "}({i l}{- 1}, {i l}{- 2} ..., {i l}{-i j},
            (: {i m}{- 1}, {i m}{- 2} ..., {i m}{-i k}),
            {i r})}}
 {row
  {left {goto tilde \ \ 7.3.38.}}
  {left ~ {i r}}
  {left {i "}~{i "}({i r})}}
 {row
  {left {goto formtype \ \ 5.9.1.}}
  {left
   {b form}
    ({i t}{- 1} {i n}{- 1},
     {i t}{- 2} {i n}{- 2} ...,
     {i t}{-i k} {i n}{-i k}) {i y}}
  {left \ }}
 {row
  {left {goto gentype \ \ 5.9.2.}}
  {orson
gen ({i g}{- 11} {i n}{- 11}, {i g}{- 12} {i n}{- 12} ..., {i g}{- 1{i j}{= 1}} {i n}{- 1{i j}{= 1}})
  gen ({i g}{- 21} {i n}{- 21}, {i g}{- 22} {i n}{- 22} ..., {i g}{- 2{i j}{= 2}} {i n}{- 2{i j}{= 2}})
    ⋮
    gen ({i g}{- {i i}1} {i n}{- {i i}1}, {i g}{- {i i}2} {i n}{- {i i}2} ..., {i g}{- {i ij{= i}}} {i n}{- {i ij{= i}}})
      form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{-i k} n{-i k}) {i y}}
  {left \ }}
 {row
  {left {goto proctype \ \ 5.9.4.}}
  {left
   {b proc}
    ({i t}{- 1} {i n}{- 1},
     {i t}{- 2} {i n}{- 2} ...,
     {i t}{-i k} {i n}{-i k}) {i y}}
  {left \ }}
 {row
  {left {goto not \ \ 7.3.43.}}
  {left {b not} {i r}}
  {left {i "}not{i "}({i r})}}
 {row
  {left {goto not \ \ 7.3.43.}}
  {left ¬ {i r}}
  {left {i "}¬{i "}({i r})}}
 {row
  {left {goto ref \ \ 5.9.3.1.}}
  {left {b ref} {i r}}
  {left \ }}
 {row
  {left {goto row \ \ 5.9.3.2.}}
  {left {b row} {i r}}
  {left \ }}
 {row
  {left {goto typetype \ \ 5.9.5.}}
  {left {b type} {i r}}
  {left \ }}
 {row
  {left {goto vartype \ \ 5.9.6.}}
  {left {b var} {i r}}
  {left \ }}}

{justify
  A {goto symboltoken colon} lets some terms have the {i m}'s as optional
  arguments.
  These arguments become the elements of a {goto list list,} which in turn is
  passed as an argument to a form.
  The form then obtains the optional arguments from the list.}

{label formtype}
{left {b 5.9.1. Plain form types.}}

{justify
  A {goto formclause plain} form is a {goto call method} whose {goto call}
  {goto transform transforms} to an {goto expression} or an
  {goto object object,} and its {goto type type.}
  A {i plain form type} is a {goto term} that transforms to the type of a plain
  form.
  Plain forms are {goto object transformation} instances, and plain form types
  are transformation {goto object types.}
  Each plain form type looks like this.}

{narrow{orson
form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- k} n{- k}) y}}

{justify
  There are zero or more {i t}\ {i n} pairs in the plain form type, called
  {i parameters.}
  Each {i t} is a term that transforms to a type called a {i parameter type,}
  and each {i n} is a {goto namepart name} called a {i parameter name.}
  The parameter names {goto must} be {goto distinct} from each other, and any
  or all of them may be {goto missing missing.}
  The parameters describe the arguments with which the plain form can be
  called.
  A parameter with the missing name ⬚ describes an unused argument.
  There may be a {goto limit} on the number of parameters in a plain form type.
  The term {i y} transforms to a type called the {i yield type.}
  It describes the expression or object to which the plain form call
  transforms.

  {goto rule Rule} {b 4} shows how a plain form type can be a {goto subtype} of
  another plain form type.}

{narrow
 {label rule04}
 {over
  {center
   {b form} ({i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) {i y} ⊆ {b form} ({i T}{- 1} {i N}{- 1}, {i T}{- 2} {i N}{- 2} ..., {i T}{-i k} {i N}{-i k}) {i Y}}
  {left \ {b 4}}
  {center
   {i T}{- 1} ⊆ {i t}{- 1}, {i n}{- 1} ⊆ {i N}{- 1}, {i T}{- 2} ⊆ {i t}{- 2}, {i n}{- 2} ⊆ {i N}{- 2} ..., {i T}{-i k} ⊆ {i t}{-i k}, {i n}{-i k} ⊆ {i N}{-i k}, {i y} ⊆ {i Y}}}}

{justify
  In the rule, both plain form types have the same number of parameters, {i k.}
  Parameter types are compared in reverse {goto car1997 {c [car 1997],}} so
  that each parameter type {i T} on the right is a subtype of its corresponding
  parameter type {i t} on the left.
  Each parameter name {i n} on the left is a {goto subname} of its
  corresponding parameter name {i N} on the right.
  The yield type {i y} on the left is a subtype of the yield type {i Y} on the
  right.

  For example, this {goto rule proof} shows that the plain form type
  {b form}\ ({i inj}\ {i k})\ {i int} is a subtype of the plain form type
  {b form}\ ({i int})\ {i inj,} whose parameter name is the missing name ⬚.
  The form types use the integer type {goto int {i int,}} and the {goto joker}
  type {goto inj {i inj.}}}

{narrow
 {over
  {center {b form} ({i inj} {i k}) {i int} ⊆ {b form} ({i int} ⬚) {i inj}}
  {left \ {goto rule04 4}}
  {center {i int} ⊆ {i inj,} {i k} ⊆ ⬚}
  {left \ {goto rule03 3}}
  {center {i int} ⊆ {i inj}}
  {left \ {goto rule51 51}}
  {center {i true}}}}

{justify
  A plain form type can also be a subtype of an {goto altsclause alternate}
  form type or a {goto gentype generic} form type, and vice versa.}

{label gentype}
{left {b 5.9.2. Generic form types.}}

{justify
  A {goto genclause generic} form is a {goto call method} whose {goto call}
  {goto transform transforms} to an {goto expression} or an
  {goto object object,} and its {goto type type.}
  A {i generic form type} is a {goto term} that transforms to the type of a
  generic form.
  Generic forms are {goto object transformation} instances, and generic form
  types are transformation {goto object types.}
  Generic form types resemble {goto formtype plain} form types, but they have
  one or more {i generic prefixes,} each of which begins with {b gen.}}

{narrow
 {orson
gen (g{- 11} n{- 11}, g{- 12} n{- 12} ..., g{- 1j{= 1}} n{- 1j{= 1}})
  gen (g{- 21} n{- 21}, g{- 22} n{- 22} ..., g{- 2j{= 2}} n{- 2j{= 2}})
    ⋮
    gen (g{- i1} n{- i1}, g{- i2} n{- i2} ..., g{- ij{= i}} n{- ij{= i}})
      form (t{- 1} m{- 1}, t{- 2} m{- 2} ..., t{- k} m{- k}) y}}

{justify
  Each generic prefix has one or more {i g}\ {i n} pairs, called
  {i generic parameters.}
  Each {i g} is a term that transforms to a {goto typetype type} type called a
  {i generic type,} and each {i n} is a {goto namepart name} called a
  {i generic name.}
  None of the generic names may be {goto missing missing.}
  There may be {goto limit limits} on the number of generic prefixes and on the
  number of generic parameters in a generic form type.

  In the plain form type that follows the generic prefixes, there are zero or
  more {i t}\ {i m} pairs, called {i parameters.}
  Each {i t} is a term that transforms to a type called a {i parameter type,}
  and each {i m} is a name called a {i parameter name.}
  Any or all of the parameter names may be missing.
  There may be a limit on the number of parameters in a generic form type.
  The term {i y} transforms to a type called the {i yield type.}

  Each generic prefix declares generic names that appear as {goto unit units}
  in the rest of the generic form type.
  The generic parameter {i g}\ {i n} declares that the generic name {i n} has
  the generic type {i g.}
  A generic name {i n} may optionally appear as a unit in one or more generic
  types of the generic prefixes following the one that declares it.
  It {goto must} appear as a unit in one or more parameter types, and it may
  optionally appear as a unit in the yield type.
  All generic names and parameter names together in a generic form type must be
  {goto distinct} from each other.

  Just as in a plain form type, the parameters describe the arguments on which
  the generic form can be called, and the yield type describes the expression
  or object to which the call transforms.
  A parameter with the missing name ⬚ describes an unused argument.
  Unlike a plain form type, however, the generic names and their types describe
  relationships between parts of the arguments' types.
  The generic form can be called only on arguments whose types have these
  relationships to each other.

  For example, the standard {goto prelude} {goto bind binds} the {goto quoted}
  name {i "}:={i "} to a generic form that implements an
  {goto colonequal assignment} operator.
  Its type is equivalent to the following.}

{narrow
 {orson
gen (type mut a)
 gen (type a b)
  form (var a l, b r) void}}

{justify
  When the generic form is called, the parameter name {i l} must be bound to an
  expression of a {goto vartype variable} type.
  The variable type's base type {i a} must have the type {b type}\ {i mut,}
  where the {goto joker} {goto {i mut}} describes {goto object execution}
  instances that can be the values of variables.
  In other words, the variable can have any base type.
  The parameter name {i r} must be bound to an expression whose type {i b} has
  the type {b type}\ {i a.}
  In other words, its type must be a {goto subtype} of the variable type's
  base type.
  As a result, the generic form can be called with arguments of any compatible
  types, like {b var}\ {i int} and {goto int {i int.}}
  However, it is an {goto errors error} to call it with arguments of
  incompatible types, like {b var}\ {i int} and {goto string {i string.}}

  Unlike other types, generic form types contain {goto bind unbound} generic
  names like {i a} and {i b.}
  Additional formal mechanisms are therefore needed to describe how generic
  form types are {goto gentransform transformed,} how they can be
  {goto gensubtype subtypes} of other types, and how their generic names can
  be bound.
  These mechanisms involve {goto freedom freedom,} {goto replace replacement,}
  {goto binder binders,} and {goto skolem Skolemization.}}

{label freedom}
{left {b 5.9.2.1. Freedom.}}

{justify
  An appearance of a {goto nametoken name} in a {goto type} is {i free} if the
  name can be {goto replace replaced} by another type.
  Such replacement can occur during {goto rule proofs} and during
  {goto transform transformations.}
  Each appearance of a name is either free or not free. The following criteria
  determine if it is {i not} free.

  Only names that appear as {goto unit units} can be free.
  Specifically, the name of a {goto hook} that denotes a type is not free, and
  the name in a {goto symbol} type is not free.
  Parameter names in a {goto gentype generic} form type, parameter names in a
  {goto formtype plain} form type, parameter names in a
  {goto proctype procedure} type, and slot names in a {goto tupleclause tuple}
  type, are also not free.

  Suppose there is a generic form type with at least one generic prefix γ.
  Also suppose that γ declares a generic parameter {i g}\ {i n.}
  Then the name {i n} is not free in the generic prefixes that follow γ, nor is
  it free in the plain form type that appears after all the generic prefixes.
  For example, in
  {b gen}\ ({b type}\ {i a}\ {i b})\ {b gen}\ ({b type}\ {i b}\ {i c})\ {b form}\ ({i a,}\ {i b,}\ {i c})\ {i d,}
  the names {i a} and {i d} are free, but the names {i b} and {i c} are not
  free.}

{label replace}
{left {b 5.9.2.2. Replacement.}}

{justify
  If the {i a}'s are one or more {goto distinct} {goto nametoken names,} then
  the following notation stands for a {goto rule statement} {i s} in which each
  name appears {goto freedom free} zero or more times.}

{narrow{orson
s⟨a{- 1}, a{- 2} ..., a{-i k}⟩}}

{justify
  Also, this notation stands for a statement which is like {i s,} except that
  all free appearances of the {i a}'s are simultaneously replaced by
  {goto type types,} the {i b}'s.}

{narrow{orson
s⟨b{- 1}, b{- 2} ..., b{-i k}⟩}}

{justify
  It is convenient to abbreviate these notations as {i s}⟨{bi a}⟩ and
  {i s}⟨{bi b}⟩, respectively.
  The bold italic letter {bi a} stands for the {i a}'s, and the bold italic
  letter {bi b} stands for the {i b}'s.

  Notations like these describe how free names in statements are replaced by
  types.
  For example, suppose that {i s}⟨{i a,}\ {i z}⟩ is
  {b gen}\ ({b type}\ {i a}\ {i z})\ {b form}\ ({i z}\ {i n})\ {i a}\ ⊆\ {i t,}
  a statement about a {goto gentype generic} form type.
  Then the name {i a} appears free twice, so it can be replaced, but the name
  {i z} appears free zero times, so it cannot be replaced.
  As a result, {i s}⟨{i int,}\ {i real}⟩ is the new statement
  {b gen}\ ({b type}\ {i int}\ {i z})\ {b form}\ ({i z}\ {i n})\ {i int}\ ⊆\ {i t,}
  in which {i a} is replaced by the type {goto int {i int,}} but {i z} is not
  replaced by the type {goto real {i real.}}}

{label binder}
{left {b 5.9.2.3. Binders.}}

{justify
  A {i binder} is a {goto rule statement} {i n}\ ⇒\ {i t} asserting that the
  {goto gentype generic} {goto nametoken name} {i n} will be {goto bind bound}
  to a {goto type} {i t,} and that {i n}'s {goto typetype type} will be
  {b type}\ {i t.}
  The name {i n} on the left side of the arrow is not {goto freedom free.}
  However, names on the right side of the arrow, that appear as
  {goto unit units} in {i t,} may be free.
  If they are free, then they may be {goto replace replaced} by types.
  For example, if {i b}⟨{i n}⟩ is the binder {i n}\ ⇒\ {i n,} then
  {i b}⟨{i int}⟩ is the binder {i n}\ ⇒\ {i int,} in which the free appearance
  of {i n} is replaced by the type {goto int {i int.}}}

{label skolem}
{left {b 5.9.2.4. Skolemization.}}

{justify
  When a {goto gentype generic} form {goto type} is
  {goto gentransform transformed,} or when it is {goto rule proved} to be a
  {goto subtype} of another type, its generic {goto nametoken names} may be
  temporarily {goto replace replaced} by Skolemized types.
  These are named for Thoralf Skolem (1887–1963), a Norwegian mathematician who
  showed how to replace certain variables of logical formulas in a similar way
  {goto end1972 {c [end 1972].}}
  Before describing Skolemized types, it is first necessary to describe
  Skolemizable types and Skolem types.}

{justify
  {b Skolemizable types.}
  A type is {i Skolemizable} if it has at least one subtype that is different
  from itself.
  For example, the {goto joker} type {goto {i obj}} is Skolemizable, because it
  has infinitely many subtypes, all but one of which are different from itself.
  However, the {goto int integer} type {goto int {i int}0} is not Skolemizable,
  because its only subtype is itself.}

{justify
  {b Skolem types.}
  If {i k} is an integer {goto constant constant,} and {i t} is a Skolemizable
  type, then ə({i k,}\ {i t}) is a {i Skolem type.}
  The constant {i k} is called the Skolem type's
  {goto compatible {i identifier,}} and the type {i t} is called its
  {i base} type.
  Each Skolem type denotes an arbitrary subtype of its base type.
  There is no need for a Skolem type whose base type is not Skolemizable,
  because it would be equivalent to its base type.

  Suppose that two Skolem types have the same base type.
  If they also have the same identifier, then they denote the same subtype of
  their base type.
  If they have different identifiers, then they may still denote the same
  subtype, or they may denote different subtypes.
  In either case, there is no way to tell exactly which subtypes they
  denote.

  Since a Skolem type denotes an arbitrary subtype of its base type, it is also
  a subtype of any other type for which its base type is a subtype, as in
  {goto rule} {b 5.}}

{narrow
 {label rule05}
 {over
  {center ə({i k,} {i t}) ⊆ {i T}}
  {left \ {b 5}}
  {center {i t} ⊆ {i T}}}}

{justify
  Skolem types are themselves Skolemizable.
  This is because each Skolem type ə({i k,}\ {i t}) has a subtype
  ə({i j,}\ ə({i k,}\ {i t})) that may be different from itself, as in this
  {goto rule proof.}}

{narrow
 {over
  {center ə({i j,} ə({i k,} {i t})) ⊆ ə({i k,} {i t})}
  {left \ {goto rule05 5}}
  {center ə({i k,} {i t}) ⊆ ə({i k,} {i t})}
  {left \ {goto rule00 0}}
  {center {i true}}}}

{justify
  A Skolem type is a {goto object transformation} type if its base type is a
  transformation type.
  It is an {goto object execution} type if its base type is an execution type.
  The {goto typesize size} of a Skolem type is the same as that of its base
  type: {i size}(ə({i k,}\ {i t}))\ =\ {i size}({i t}).

  Orson can temporarily eliminate generic names from generic types by replacing
  them with new Skolem types.
  Each new Skolem type has an identifier which is different from that of any
  other Skolem type.
  Orson might create these identifiers by incrementing a hidden counter.
  As a result, each new Skolem type denotes a type which is potentially
  different from that denoted by any other Skolem type.}

{justify
  {b Skolemized types.}
  Suppose that {b type}\ θ\ {i T}\ {i n} is a generic parameter in a
  generic form type, where θ is a series of zero or more {b type} prefixes,
  {i T} is a type with no {b type} prefixes, and {i n} is a name.
  Also suppose that {i T} contains no {goto freedom free} generic names.
  Then appearances of {i n} in the generic form type may be replaced by a
  Skolemized type {i S} that is constructed from {b type}\ θ\ {i T.}
  If {i T} is Skolemizable, then {i S} is θ\ ə({i k,}\ {i T}), with a new
  identifier {i k} that appears in no other Skolem type.
  If {i T} is not Skolemizable, then {i S} is simply θ\ {i T.}

  The Skolemized type {i S} can replace the generic name {i n} without
  {goto errors error,} because {i S} has the same type as {i n.}
  This is proved in the following way.
  An object {i e} has a {goto typetype type} {i t} if {b type}\ {i e} is a
  subtype of {i t.}
  As a result, {b type}\ {i S} ought to be a subtype of {i n}'s type, which is
  {b type}\ θ\ {i T.}
  This is true if {i S} is θ\ ə({i k,}\ {i T}), as shown on the left.
  It is also true if {i S} is θ\ {i T,} as shown on the right.}

{narrow
 {layout
  {row
   {over
    {center {b type} θ ə({i k,} {i T}) ⊆ {b type} θ {i T}}
    {left \ {goto rule19 19}}
    {center ⋮
      ə({i k,}\ {i T}) ⊆ {i T}}
    {left \ {goto rule05 5}}
    {center {i T} ⊆ {i T}}
    {left \ {goto rule00 0}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {b type} θ {i T} ⊆ {b type} θ {i T}}
    {left \ {goto rule00 0}}
    {center {i true}}}}}}

{justify
  The three dots are meant to suggest that rule {goto rule19 19} is
  {goto rule applied} as many times as necessary to remove the {b type}
  prefixes.

  When a generic type is Skolemized, its first {b type} prefix is removed, and
  any remaining {b type} prefixes in θ are left outside the resulting new
  Skolem type.
  For example, if the type {i t} is Skolemizable, then the generic type
  {b type}\ {b type}\ {i t} is Skolemized to {b type}\ ə({i k},\ {i t}).
  Treating {b type} prefixes in this way makes it easy to Skolemize a
  Skolemized type again.
  For example, if {b type}\ ə({i k},\ {i t}) is Skolemized again, it results in
  ə({i j},\ ə({i k},\ {i t})).}

{label gentransform}
{left {b 5.9.2.5. Generic transformation.}}

{justify
  Suppose that the following is a {goto gentype generic} form {goto type type,}
  in which each {i g} {goto transform transforms} to a {goto typetype type}
  type, each {i n} is a {goto nametoken name,} and {i f} is a
  {goto formtype plain} form type.}

{narrow{orson
gen (g{- 11} n{- 11}, g{- 12} n{- 12} ..., g{- 1j{= 1}} n{- 1j{= 1}})
  gen (g{- 21} n{- 21}, g{- 22} n{- 22} ..., g{- 2j{= 2}} n{- 2j{= 2}})
    ⋮
    gen (g{- i1} n{- i1}, g{- i2} n{- i2} ..., g{- ij{= i}} n{- ij{= i}}) f}}

{justify
  Then the generic form type is transformed in the following way.
  First, a new {goto scope} is entered, and all generic names in the generic
  type are made {goto bind unbound.}

  Next, in the first generic prefix, each generic parameter {i g}\ {i n} is
  transformed to a new generic parameter {i G}\ {i n,} and the generic name
  {i n} is {goto bind rebound} to the type {i S} that results from
  {goto skolem Skolemizing} {i G.}
  The first generic prefix is then removed.
  This is repeated with the remaining generic prefixes, in order of appearance,
  until they all have been removed.

  Now suppose that a generic parameter {i g}\ {i n} appeared in one of the
  prefixes.
  Then either no {goto freedom free} generic names appeared in {i g,} or else
  all free generic names that appeared in {i g} were bound to Skolemized types
  by earlier generic prefixes.
  As a result, when {i g} was transformed to a new generic type {i G,} all free
  generic names in {i g} were {goto replace replaced} in {i G} by the
  Skolemized types to which they were bound.

  After the generic prefixes have been removed, only the plain form type {i f}
  remains.
  All free generic names in {i f} are also bound to Skolemized types by the
  generic prefixes.
  As a result, when {i f} is transformed to a new plain form type {i F,} the
  free generic names in {i f} are also replaced in {i F} by the Skolemized
  types to which they were bound.

  Finally, the generic prefixes are restored to {i F} along with their
  transformed generic types.
  Each Skolemized type that was introduced during transformation is replaced by
  the generic name which was bound to it.
  The scope that was entered at the start of transformation is then exited,
  restoring the generic names to their original {goto bind bindings.}
  The result is the following transformed generic form type.}

{narrow{orson
gen (G{- 11} n{- 11}, G{- 12} n{- 12} ..., G{- 1j{= 1}} n{- 1j{= 1}})
  gen (G{- 21} n{- 21}, G{- 22} n{- 22} ..., G{- 2j{= 2}} n{- 2j{= 2}})
    ⋮
    gen (G{- i1} n{- i1}, G{- i2} n{- i2} ..., G{- ij{= i}} n{- ij{= i}}) F}}

{justify
  In the transformed generic form type, each generic name {goto must} appear at
  least once as a unit in {i F}'s parameter types.
  This ensures that all generic names can be bound if a generic form of this
  type is {goto genclause called.}}

{justify
  {b Example.}
  The standard {goto prelude} binds the {goto quoted} name {i "}:={i "} to a
  generic form that implements an {goto colonequal assignment} operator.
  Its type is equivalent to the following.}

{narrow{orson
gen (type mut a)
 gen (type a b)
  form (var a l, b r) void}}

{justify
  This generic form type is transformed in the following way.
  First, a new scope is entered, and the generic names {i a} and {i b} are made
  unbound.
  Suppose that the result of transforming the {goto joker} type {goto {i mut}}
  is written as {c mut.}
  Then the generic type {b type}\ {i mut} is transformed to {b type}\ {c mut,}
  and the generic name {i a} is bound to the type ə(0,\ {c mut}) that results
  from Skolemizing it.
  The first generic prefix is then removed, leaving the following generic form
  type.}

{narrow{orson
gen (type a b)
 form (var a l, b r) void}}

{justify
  Using the binding for {i a} established by the previous generic prefix, the
  generic type {b type}\ {i a} is transformed to {b type}\ ə(0,\ {c mut}), and
  the generic name {i b} is bound to the type ə(1,\ ə(0,\ {c mut})) that
  results from Skolemizing it.
  The second generic prefix is then removed, leaving the following plain form
  type.}

{narrow{orson
form (var a l, b r) void}}

{justify
  The plain form type is now transformed.
  As a result of transformation, {i a} is replaced by its binding
  ə(0,\ {c mut}), and {i b} is replaced by its binding ə(1,\ ə(0,\ {c mut})).
  Suppose that the result of transforming {goto {i void}} is written as
  {c void.}
  Then the yield type {i void} is also replaced by {c void.}}

{narrow
 {left
  {b form} ({b var} ə(0, {c mut}) {i l,} ə(1, ə(0, {c mut})) {i r}) {c void}}}

{justify
  Next, the generic prefixes are restored, along with their transformed generic
  parameter types.}

{narrow{q{indent
{b gen} ({b type} {c mut} {i a})
  {b gen} ({b type} ə(0, {c mut}) {i b})
    {b form} ({b var} ə(0, {c mut}) {i l,} ə(1, ə(0, {c mut})) {i r}) {c void}}}}

{justify
  Finally, each Skolemized type is replaced by the generic name that was bound
  to it, so ə(0,\ {c mut}) is replaced by {i a,} and ə(1,\ ə(0,\ {c mut})) is
  replaced by {i b.}
  The generic form's scope is then exited, restoring {i a} and {i b} to their
  original bindings.
  The transformed generic form type looks like this.}

{narrow{q{indent
{b gen} ({b type} {c mut} {i a})
  {b gen} ({b type} {i a} {i b})
    {b form} ({b var} {i a} {i l,} {i b} {i r}) {c void}}}}

{justify
  Throughout the transformation, each generic name was {goto bind bound} to a
  Skolemized type.
  The Skolemized type has properties like those of the actual type to which the
  name would be bound in a generic form call.
  As a result, generic form types and parameter types can be arbitrary
  {goto term terms} in which generic names appear as {goto unit units.}}

{label genrule}
{left {b 5.9.2.6. Generic rules.}}

{justify
  To formally describe {goto gentype generic} form {goto type types,} the
  {goto rule rules} that are used elsewhere in this Report are extended so they
  can describe generic {goto nametoken names} without {goto bind bindings.}
  Suppose that the {i a}'s, {i b}'s, {i p}'s, and {i q}'s are
  {goto rule statements} about types, and that {bi r} is an identifying number.
  Then this is an extended rule.}

{narrow
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i m} | {i p}{- 1}, {i p}{- 2} ..., {i p}{-i j}}
  {left \ {bi r}}
  {center
   {i b}{- 1}, {i b}{- 2} ..., {i b}{-i n} | {i q}{- 1}, {i q}{- 2} ..., {i q}{-i k}}}}

{justify
  The {i b}'s and {i q}'s are called {i antecedents,} and the {i a}'s and
  {i p}'s are called {i consequents.}
  The extended rule {bi r} says that if the {i b}'s and {i q}'s are true, then
  the {i a}'s and {i p}'s are also true.
  However, statements on opposite sides of the separator `|' play different
  roles in {goto rule proofs.}
  The {i p}'s and {i q}'s on the right of the separator can {goto replace}
  {goto freedom free} generic names by types, but the {i a}'s and {i b}'s on
  the left of the separator cannot.

  If a proof {goto rule step} has a separator `|', then an extended rule can be
  {goto rule applied} to both sides of that step at once.
  An unextended rule can also be applied to the step, in two different ways.
  It can be applied to statements on the right side of the separator, leaving
  those on the left side unchanged.
  It can also be applied to statements on the left side, leaving those on the
  right side unchanged, but only if the right side is {i true.}
  As a result, statements on the left side can be proved only after those on
  the right have replaced all free generic names by types.

  Extended and unextended rules may be applied together to prove statements
  about types.
  A statement is true if it is possible to construct a finite tower of steps,
  starting with the statement on top, and ending with {i true,} or with
  {i true}\ |\ {i true,} on the bottom.
  If it is not possible to construct such a tower, then the statement is
  false.}

{label gensubtype}
{left {b 5.9.2.7. Generic subtyping.}}

{justify
  Suppose that {i t} and {i T} are form {goto type types,} and that at least
  one is a {goto gentype generic} form type.
  Then the following {goto genrule extended} {goto rule rules} constitute an
  algorithm that decides if {i t} is a {goto subtype} of {i T.}
  The algorithm assumes that all generic {goto nametoken names} declared in
  {i t} and {i T} together are {goto distinct} from each other.
  Generic names that violate this assumption are replaced by {goto unique}
  names which appear nowhere else.}

{justify
  {b Mark generic prefixes.}
  In the first step of the algorithm, each generic prefix in {i t} is marked
  with a superscript {c r,} indicating that the generic names it declares will
  be replaced by parts of {i T}'s parameter types.
  These generic prefixes are called {i replacing prefixes.}
  Each generic prefix in {i T} is also marked with a superscript {c s,}
  indicating that the generic names it declares will be replaced by
  {goto skolem Skolemized} types.
  These generic prefixes are called {i Skolemizing prefixes.}}

{justify
  {b Add a separator.}
  The second step is to add a {goto genrule separator} `|', as in rule {b 6.}
  This lets other rules add {goto rule statements} about generic names to the
  left side of the separator.}

{narrow
 {label rule06}
 {over
  {center {i t} ⊆ {i T}}
  {left \ {b 6}}
  {center {i true} | {i t} ⊆ {i T}}}}

{justify
  {b Remove generic prefixes.}
  In the third step, all generic prefixes are removed from {i t} and {i T.}
  Rules {b 7} and {b 8} each remove a replacing prefix and add equivalent
  statements about its generic names to the left side of the separator `|'.
  Initially, all replacing prefixes are on the left side of the subtype
  relation ⊆, but they might be moved to the right side by rule {goto rule04 4}
  if they appear as parts of parameter types.}

{narrow
 {label rule07}
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j} | {b gen}{+c r} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f} ⊆ {i T}}
 {left \ {b 7}}
 {center
  {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b type} {i n}{- 1} ⊆ {i g}{- 1}, {b type} {i n}{- 2} ⊆ {i g}{- 2} ..., {b type} {i n}{-i k} ⊆ {i g}{-i k} | {i f} ⊆ {i T}}}}

{narrow
 {label rule08}
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j} | {i t} ⊆ {b gen}{+c r} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i F}}
  {left \ {b 8}}
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b type} {i n}{- 1} ⊆ {i g}{- 1}, {b type} {i n}{- 2} ⊆ {i g}{- 2} ..., {b type} {i n}{-i k} ⊆ {i g}{-i k} | {i t} ⊆ {i F}}}}

{justify
  Similarly, rules {b 9} and {b 10} each remove a Skolemizing prefix, and
  {goto replace} {goto freedom free} appearances of the generic names it
  declares by Skolemized types.
  Each {i s} is the result of Skolemizing its corresponding type {i g.}
  Initially, all Skolemizing prefixes are on the right side of the subtype
  relation ⊆, but they might be moved to the left side by rule {b 4} if they
  appear as parts of parameter types.}

{narrow
 {label rule09}
 {over
  {center
   {b gen}{+c s} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f}⟨{i n}{- 1}, {i n}{- 2} ..., {i n}{-i k}⟩ ⊆ {i T}}
  {left \ {b 9}}
  {center
   {i f}⟨{i s}{- 1}, {i s}{- 2} ..., {i s}{-i k}⟩ ⊆ {i T}}}}

{narrow
 {label rule10}
 {over
  {center
   {i t} ⊆ {b gen}{+c s} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i F}⟨{i n}{- 1}, {i n}{- 2} ..., {i n}{-i k}⟩}
  {left \ {b 10}}
  {center
   {i t} ⊆ {i F}⟨{i s}{- 1}, {i s}{- 2} ..., {i s}{-i k}⟩}}}

{justify
  {b Replace generic names.}
  By the fourth step, only a statement about {goto formtype plain} form types
  remains on the right side of the separator `|'.
  Rules defined elsewhere in this Report are now applied in an attempt to prove
  the statement.
  Suppose that as a result of applying the rules, a statement {i n}\ ⊆\ {i t}
  or {i t}\ ⊆\ {i n} appears on the right of the separator, where {i n} is a
  generic name, and {i t} is a type with no free generic names.
  Then {i n} is replaced by {i t,} as in rules {b 11} and {b 12.}}

{narrow
 {label rule11}
 {over
  {center
   {i a}{- 1}⟨{i n}⟩, {i a}{- 2}⟨{i n}⟩ ..., {i a}{-i j}⟨{i n}⟩ | {i b}{- 1}⟨{i n}⟩, {i b}{- 2}⟨{i n}⟩ ..., {i b}{-i k}⟨{i n}⟩, {i n} ⊆ {i t}}
  {left \ {b 11}}
  {center
   {i a}{- 1}⟨{i t}⟩, {i a}{- 2}⟨{i t}⟩ ..., {i a}{-i j}⟨{i t}⟩ | {i b}{- 1}⟨{i t}⟩, {i b}{- 2}⟨{i t}⟩ ..., {i b}{-i k}⟨{i t}⟩}}}

{narrow
 {label rule12}
 {over
  {center
   {i a}{- 1}⟨{i n}⟩, {i a}{- 2}⟨{i n}⟩ ..., {i a}{-i j}⟨{i n}⟩ | {i b}{- 1}⟨{i n}⟩, {i b}{- 2}⟨{i n}⟩ ..., {i b}{-i k}⟨{i n}⟩, {i t} ⊆ {i n}}
  {left \ {b 12}}
  {center
   {i a}{- 1}⟨{i t}⟩, {i a}{- 2}⟨{i t}⟩ ..., {i a}{-i j}⟨{i t}⟩ | {i b}{- 1}⟨{i t}⟩, {i b}{- 2}⟨{i t}⟩ ..., {i b}{-i k}⟨{i t}⟩}}}

{justify
  {b Generic form types as generic types.}
  The algorithm needs an optional fifth step to deal with generic form types
  that appear as generic types.
  For example, the following generic form type describes a higher-order form
  whose argument is another form.
  The argument's type is described by a generic form type.}

{narrow{orson
gen (type gen (type obj t) form (t) t n) form (n a) void}}

{justify
  When applied to this type, the rules discussed previously will place a
  statement about the generic form type
  {b gen}\ ({b type}\ {i obj}\ {i t})\ {b form}\ ({i t})\ {i t} on the left
  side of the separator `|'.
  However, the rules assume that all statements about generic form types will
  appear on the right side, so their generic names can be replaced by types.
  The solution is to introduce rules {b 13} and {b 14} that move statements
  about generic form types from the left side to the right side.
  The superscript {ci p} stands for either {c r} or {c s.}}

{narrow
 {label rule13}
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b gen}{+ci p} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f} ⊆ {i T} | {i true}}
  {left \ {b 13}}
  {center 
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j} | {b gen}{+ci p} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f} ⊆ {i T}}}}

{narrow
 {label rule14}
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {i t} ⊆ {b gen}{+ci p} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i F} | {i true}}
  {left \ {b 14}}
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j} | {i t} ⊆ {b gen}{+ci p} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i F}}}}

{justify
  These rules cannot be applied to the left side until the right side has been
  proved true.
  At that point in the proof, all free generic names in generic form types on
  the left side will have been replaced.
  Once a generic form type appears on the right of the separator `|', the rules
  of the subtype algorithm are {goto rule applied} to it again.}

{justify
  {b Example.}
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}:={i "} to a generic form that implements an
  {goto colonequal assignment} operator.
  Its type is equivalent to the following.}

{narrow{orson
gen (type mut a)
  gen (type a b)
    form (var a l, b r) void}}

{justify
  When the generic form is called, its parameter {i l} {goto must} be
  {goto bind bound} to an {goto expression} of some {goto vartype variable}
  type.
  Its parameter {i r} must be bound to an expression whose type is a subtype of
  the variable type's base type.
  Now suppose that there is another version of this generic form which uses the
  {goto joker} type {goto {i inj}} instead of {goto mut {i mut,}} so it can
  assign values only to {goto int integer} variables.
  It has this type.}

{narrow{orson
gen (type inj c)
  gen (type c d)
    form (var c l, d r) void}}

{justify
  Since {i inj} is (indirectly) a subtype of {i mut,} it should always be
  possible to call a form of the first type with the same arguments as a form
  of the second type.
  As a result, the first type should be a subtype of the second type.
  This can be formally {goto rule proved} in the following way.}

{narrow
 {over
  {center
   {b gen}{+c r} ({b type} {i mut} {i a}) {b gen}{+c r} ({b type} {i a} {i b}) {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆
   {b gen}{+c s} ({b type} {i inj} {i c}) {b gen}{+c s} ({b type} {i c} {i d}) {b form} ({b var} {i c} {i l,} {i d} {i r}) {i void}}
  {left \ {goto rule06 6}}
  {center
    {i true} |
    {b gen}{+c r} ({b type} {i mut} {i a}) {b gen}{+c r} ({b type} {i a} {i b}) {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆
   {b gen}{+c s} ({b type} {i inj} {i c}) {b gen}{+c s} ({b type} {i c} {i d}) {b form} ({b var} {i c} {i l,} {i d} {i r}) {i void}}
  {left \ {goto rule07 7}}
  {center
   {b type} {i a} ⊆ {b type} {i mut} |
   {b gen}{+c r} ({b type} {i a} {i b}) {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆
   {b gen}{+c s} ({b type} {i inj} {i c}) {b gen}{+c s} ({b type} {i c} {i d}) {b form} ({b var} {i c} {i l,} {i d} {i r}) {i void}}
  {left \ {goto rule07 7}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆
   {b gen}{+c s} ({b type} {i inj} {i c}) {b gen}{+c s} ({b type} {i c} {i d}) {b form} ({b var} {i c} {i l,} {i d} {i r}) {i void}}
  {left \ {goto rule10 10}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆
   {b gen}{+c s} ({b type} ə(0, {i inj}) {i d}) {b form} ({b var} ə(0, {i inj}) {i l,} {i d} {i r}) {i void}}
  {left \ {goto rule10 10}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b form} ({b var} {i a} {i l,} {i b} {i r}) {i void} ⊆ {b form} ({b var} ə(0, {i inj}) {i l,} ə(1, ə(0, {i inj})) {i r}) {i void}}
  {left \ {goto rule04 4}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b var} ə(0, {i inj}) ⊆ {b var} {i a,} {i l} ⊆ {i l,} ə(1, ə(0, {i inj})) ⊆ {i b,} {i r} ⊆ {i r,} {i void} ⊆ {i void}}
  {left \ {goto rule00 0}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b var} ə(0, {i inj}) ⊆ {b var} {i a,} {i l} ⊆ {i l,} ə(1, ə(0, {i inj})) ⊆ {i b,} {i r} ⊆ {i r}}
  {left \ {goto rule02 2}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b var} ə(0, {i inj}) ⊆ {b var} {i a,} {i l} ⊆ {i l,} ə(1, ə(0, {i inj})) ⊆ {i b}}
  {left \ {goto rule02 2}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   {b var} ə(0, {i inj}) ⊆ {b var} {i a,} ə(1, ə(0, {i inj})) ⊆ {i b}}
  {left \ {goto rule20 20}}
  {center
   {b type} {i a} ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} {i a} |
   ə(0, {i inj}) ⊆ {i a,} ə(1, ə(0, {i inj})) ⊆ {i b}}
  {left \ {goto rule12 12}}
  {center
   {b type} ə(0, {i inj}) ⊆ {b type} {i mut,} {b type} {i b} ⊆ {b type} ə(0, {i inj}) |
   ə(1, ə(0, {i inj})) ⊆ {i b}}
  {left \ {goto rule12 12}}
  {center
   {b type} ə(0, {i inj}) ⊆ {b type} {i mut,} {b type} ə(1, ə(0, {i inj})) ⊆ {b type} ə(0, {i inj}) | {i true}}
  {left \ {goto rule19 19}}
  {center
   ə(0, {i inj}) ⊆ {i mut,} {b type} ə(1, ə(0, {i inj})) ⊆ {b type} ə(0, {i inj}) | {i true}}
  {left \ {goto rule19 19}}
  {center
   ə(0, {i inj}) ⊆ {i mut,} ə(1, ə(0, {i inj})) ⊆ ə(0, {i inj}) | {i true}}
  {left \ {goto rule05 5}}
  {center
   {i inj} ⊆ {i mut,} ə(1, ə(0, {i inj})) ⊆ ə(0, {i inj}) | {i true}}
  {left \ {goto rule05 5}}
  {center
   {i inj} ⊆ {i mut,} ə(0, {i inj}) ⊆ ə(0, {i inj}) | {i true}}
  {left \ {goto rule00 0}}
  {center
   {i inj} ⊆ {i mut} | {i true}}
  {left \ {goto rule55 55}}
  {center
   {i inj} ⊆ {i sca} | {i true}}
  {left \ {goto rule65 65}}
  {center
   {i inj} ⊆ {i num} | {i true}}
  {left \ {goto rule58 58}}
  {center
   {i inj} ⊆ {i inj} | {i true}}
  {left \ {goto rule00 0}}
  {center
   {i true} | {i true}}}}

{label genmult}
{left {b 5.9.2.8. Multiple generic names.}}

{justify
  Suppose that it is necessary to test if a {goto gentype generic} form
  {goto type} is a {goto gensubtype subtype} of another form type.
  Also suppose that a generic {goto nametoken name} {i n} appears many times in
  the generic form type's parameter types, so it can be {goto replace replaced}
  in many ways.
  Then the generic form type may be a subtype of the other form type when {i n}
  is replaced in some ways, but not in others.
  This is shown in an example {goto rule proof,} which begins with these
  steps.}

{narrow
 {over
  {center {b gen}{+c r} ({b type} {i obj} {i n}) {b form} ({i n,} {i n}) {i void} ⊆ {b form} ({i int,} {i obj}) {i void}}
  {left \ {goto rule06 6}}
  {center {i true} | {b gen}{+c r} ({b type} {i obj} {i n}) {b form} ({i n,} {i n}) {i void} ⊆ {b form} ({i int,} {i obj}) {i void}}
  {left \ {goto rule07 7}}
  {center {b type} {i n} ⊆ {b type} {i obj} | {b form} ({i n,} {i n}) {i void} ⊆ {b form} ({i int,} {i obj}) {i void}}
  {left \ {goto rule04 4}}
  {center {b type} {i n} ⊆ {b type} {i obj} | {i int} ⊆ {i n,} {i obj} ⊆ {i n,} {i void} ⊆ {i void}}
  {left \ {goto rule00 0}}
  {center
   {b type} {i n} ⊆ {b type} {i obj} | {i int} ⊆ {i n,} {i obj} ⊆ {i n}
   ⋮}}}

{justify
  At this point, the generic name {i n} could be replaced either by the type
  {goto int {i int,}} or by the {goto joker} type {goto obj {i obj.}}
  If {i n} is replaced by {i int,} then the proof fails, because {i obj} is not
  a subtype of {i int.}}

{narrow
 {over
  {center 
   ⋮
   {b type} {i n} ⊆ {b type} {i obj} | {i int} ⊆ {i n,} {i obj} ⊆ {i n}}
  {left \ {goto rule12 12}}
  {center {b type} {i int} ⊆ {b type} {i obj} | {i obj} ⊆ {i int}}}}

{justify
  However, if {i n} is replaced by {i obj} instead, then the proof succeeds,
  because {i int} is a subtype of {i obj.}}

{narrow
 {over
  {center
   ⋮
   {b type} {i n} ⊆ {b type} {i obj} | {i int} ⊆ {i n,} {i obj} ⊆ {i n}}
  {left \ {goto rule12 12}}
  {center {b type} {i obj} ⊆ {b type} {i obj} | {i int} ⊆ {i obj}}
  {left \ {goto rule60 60}}
  {center {b type} {i obj} ⊆ {b type} {i obj} | {i true}}
  {left \ {goto rule00 0}}
  {center {i true} | {i true}}}}

{justify
  Orson resolves this ambiguity by replacing generic names in the order that
  they appear in a generic form's parameter types.
  As a result, the leftmost possible free appearance of a generic name in the
  parameter types determines how the name is replaced.
  In the example, the leftmost appearance of {i n} is replaced by {i int,} so
  the proof fails.

  This convention for replacing generic names might be changed in future
  versions of Orson.
  If possible, a generic form type should therefore be written so that each of
  its generic names appears exactly once in its parameter types.
  A generic name should appear more than once only if it does not matter which
  of its appearances is replaced first.}

{label pointer}
{left {b 5.9.3. Pointer types.}}

{justify
  A {i pointer type} describes a pointer.
  A {i pointer} represents the address of an {goto object execution} instance
  in memory.
  The instance's {goto type} is called the pointer's {i base} type.
  The pointer is said to {i reference} or {i point to} the instance, and the
  instance can be obtained by {goto uparrow dereferencing} the pointer.
  It is also possible for a pointer to reference {i no} instance, or to
  reference an {goto undefined} instance, so that dereferencing it is an
  {goto errors error.}

  Suppose that a pointer references an instance.
  Then a pointer to a different instance, but with the same base type, may be
  obtained by {goto plus adding} an {goto int integer} to the pointer, or by
  {goto dash subtracting} an integer from the pointer.
  Programs that use such {i pointer arithmetic} are often efficient, but they
  may also erroneously create pointers which do not reference instances.
  Programs that do not use pointer arithmetic might therefore be safer than
  those which do.

  There are three kinds of pointer types.
  {goto row {i Row}} pointer types can reference instances, and can be computed
  by pointer arithmetic.
  {goto ref {i Ref}} pointer types can reference instances, but cannot be
  computed by pointer arithmetic.
  {goto null {i Null}} pointer types cannot reference instances, and cannot be
  computed by pointer arithmetic.

  All pointers are totally ordered.
  Suppose that {i l} and {i r} are pointers, possibly of different types.
  Then either {i l} is less than {i r,} {i l} is equal to {i r,} or {i l} is
  greater than {i r.}
  Orson might test the ordering of two pointers by first converting them to
  integers, then comparing the integers.

  All pointer types also have the same {goto typesize size,} an
  {goto unspecified} small positive integer {goto constant constant.}
  A pointer type does not necessarily have the same size as any integer type,
  or the same size as any {goto proctype procedure} type.}

{label ref}
{left {b 5.9.3.1. {i Ref} types.}}

{justify
  Suppose that the {goto term} {i t} {goto transform transforms} to an
  {goto object execution} {goto type type.}
  Then the term {b ref}\ {i t} transforms to the type of a {i ref}
  {goto pointer} whose {i base} type is {i t.}
  Orson tests if a {i ref} type is a {goto subtype} of another {i ref} type by
  comparing their base types, as in {goto rule} {b 15.}}

{narrow
 {label rule15}
 {over
  {center {b ref} {i t} ⊆ {b ref} {i T}}
  {left \ {b 15}}
  {center {i t} ⊆ {i T}}}}

{justify
  {i Ref} pointer types are both {goto object transformation} types and
  execution types.
  {i Ref} pointers are execution instances.}

{label row}
{left {b 5.9.3.2. {i Row} types.}}

{justify
  Suppose that the {goto term} {i t} {goto transform transforms} to an
  {goto object execution} {goto type type.}
  Then the term {b row}\ {i t} transforms to the {goto type} of a {i row}
  {goto pointer} whose {i base} type is {i t.}
  Orson tests if a {i row} type is a {goto subtype} of another {i row} type by
  comparing their base types, as in {goto rule} {b 16.}}

{narrow
 {label rule16}
 {over
  {center {b row} {i t} ⊆ {b row} {i T}}
  {left \ {b 16}}
  {center {i t} ⊆ {i T}}}}

{justify
  A {goto {i ref}} type can also be a {goto cotype} of a {i row} type, as in
  rule {b 17.}
  As a result, if a parameter type of a {goto call method} is a {i row} type,
  then its corresponding argument can have either a {i ref} type or a {i row}
  type.}

{narrow
 {label rule17}
 {over
  {center {b ref} {i t} ⊑ {i T}}
  {left \ {b 17}}
  {center {b row} {i t} ⊆ {i T}}}}

{justify
  However, a {i row} type is not a cotype of a {i ref} type.
  This is because a {i row} pointer might be computed by pointer arithmetic,
  making it riskier to use than a {i ref} pointer.
  Converting a {i row} pointer to a {i ref} pointer requires a
  {goto postbrace cast} to indicate acceptance of the risk.

  {i Row} pointer types are both transformation and execution types.
  {i Row} pointers are execution instances.
  {goto string Strings,} or {i row} pointers that reference
  {goto char {i char}0's,} are also {goto object transformation} instances.}

{label circular}
{left {b 5.9.3.3. Circular pointer types.}}

{justify
  The base type of a {goto {i ref}} or {goto {i row}} pointer type may be an
  {goto bind unbound} {goto nametoken name.}
  If it is, then the name {goto must} eventually be {goto bind bound} by an
  {goto withclause equate} in the same {goto progclause {i prog}} clause or
  {goto withclause {i with}} clause that created the pointer type.
  This allows the pointer's base type to be circularly defined in terms of
  itself.
  Linked data structures, like chains, trees, and graphs, may be described by
  such circular pointer types.

  For example, these two equates define a type {i link} that describes a linear
  chain of {goto tupleclause tuples} which contains {goto int {i int}'s.}
  The name {i node} is unbound when it appears in the first equate, but it is
  bound by the second equate.}

{narrow
 {layout
  {row
   {left {i link}}
   {center \ :−\ }
   {left {b ref} {i node}}}
  {row
   {left {i node}}
   {center \ :−\ }
   {left ({b tuple} {b var} {i int} {i key}, {b var} {i link} {i next})}}}}

{justify
  A pointer type like {i link,} whose base type is an unbound name, can be used
  without {goto errors error} only in situations where the name will not be
  examined.
  For example, its {goto typesize size} may be computed, and it can be used as
  part of another type.
  However, it cannot be asserted to be a {goto subtype} of a {i ref} or {i row}
  type, since this requires examining its base type.
  After the unbound name becomes bound, the pointer type can be used without
  these restrictions.}

{justify
  {b Infinite types.}
  After the name {i node} becomes bound, the type {i link} appears to have an
  infinite base type, as if it was defined as follows.
  Orson might represent a such a type in finite space as a graph with circular
  edges.}

{narrow{orson
link :−
  ref (tuple
        var int key,
        var ref (tuple
                  var int key,
                  var ref (tuple
                            var int key,
                            var ref ... )))}}

{justify
  An infinite type can appear only as the base type of a {i ref} or {i row}
  type.
  Because the size of a pointer type is a {goto constant constant,} infinite
  types can never be used to create {goto object instances} of infinite size.

  Since {i link} no longer mentions the name {i node,} it can be used even in
  {goto scope scopes} where {i node} is not bound.
  For example, a {goto call} to the {goto formclause plain} form {i chain}
  {goto transform transforms} to a circular pointer type that is computed by a
  {i with} clause.}

{narrow{orson
chain :−
 (form (type mut base) type ref tup:
  (with
    link :− ref node
    node :− (tuple var base key, var link next)
   do link))}}

{justify
  The call {i chain}({i int}) transforms to an infinite type like the one
  shown above.}

{justify
  {b Infinite subtypes.}
  Suppose that {i l} and {i r} are both {i ref} types or both {i row} types.
  Also suppose that a {goto rule statement} asserts {i l} to be a subtype of
  {i r.}
  Then the statement is true if {i l}'s base type can be {goto rule proved} to
  be a subtype of {i r}'s base type.

  Now suppose that during the proof, the original statement about {i l} and
  {i r} reappears.
  Then at least one of {i l} and {i r} are circular, so the proof might not
  terminate if it is continued.
  To avoid this, the reappearance of the original statement about {i l} and
  {i r} may be assumed to be {i true} and deleted, as in the following proof
  fragments.}

{narrow
 {layout
  {row
   {over
    {center
     {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b ref} {i t} ⊆ {b ref} {i T}}
    {left \ {goto rule15 15}}
    {center
     {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {i t} ⊆ {i T}}
    {left \ \ \ \ \ }
    {center
      ⋮
      {i b}{- 1}, {i b}{- 2} ..., {i b}{-i k}, {b ref} {i t} ⊆ {b ref} {i T}}
    {left \ \ \ \ \ }
    {center {i b}{- 1}, {i b}{- 2} ..., {i b}{-i k}}}
   {left \ \ \ \ \ \ \ \ \ \ }
   {over
    {center
     {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b row} {i t} ⊆ {b row} {i T}}
    {left \ {goto rule16 16}}
    {center
     {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {i t} ⊆ {i T}}
    {left \ \ \ \ \ }
    {center
      ⋮
      {i b}{- 1}, {i b}{- 2} ..., {i b}{-i k}, {b row} {i t} ⊆ {b row} {i T}}
    {left \ \ \ \ \ }
    {center {i b}{- 1}, {i b}{- 2} ..., {i b}{-i k}}}}}}

{label proctype}
{left {b 5.9.4. Procedure types.}}

{justify
  A {goto procclause procedure} is a {goto call method} whose {goto call}
  {goto evaluate evaluates} to an {goto object execution} instance, but not a
  {goto vartype variable.}
  A {i procedure type} {goto transform transforms} to the {goto type} of a
  procedure.
  Procedures are execution instances, and their types are both
  {goto object transformation} and {goto object execution} types.
  Each procedure type looks like this.}

{narrow
 {orson
proc (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{-i k} n{-i k}) y}}

{justify
  There are zero or more {i t}\ {i n} pairs in the procedure type, called
  {i parameters.}
  Each {i t} is a {goto term} that transforms to an execution type called a
  {i parameter type,} and each {i n} is a {goto namepart name} called a
  {i parameter name.}
  The parameter names {goto must} be {goto distinct} from each other, and any
  or all of them may be {goto missing missing.}
  The parameters describe the arguments with which the procedure can be called.
  A parameter with the missing name ⬚ describes an unused argument.
  The term {i y} transforms to an execution type, but not a variable type,
  called the {i yield type.}
  The yield type describes the execution instance to which the call evaluates.

  {goto rule Rule} {b 18} shows how a procedure type can be a {goto subtype} of
  another procedure type.}

{narrow
 {label rule18}
 {over
  {center
   {b proc} ({i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) {i y} ⊆ {b proc} ({i T}{- 1} {i N}{- 1}, {i T}{- 2} {i N}{- 2} ..., {i T}{-i k} {i N}{-i k}) {i Y}}
  {left \ {b 18}}
  {center
   {i T}{- 1} ⊆ {i t}{- 1}, {i n}{- 1} ⊆ {i N}{- 1}, {i T}{- 2} ⊆ {i t}{- 2}, {i n}{- 2} ⊆ {i N}{- 2} ..., {i T}{-i k} ⊆ {i t}{-i k}, {i n}{-i k} ⊆ {i N}{-i k}, {i y} ⊆ {i Y}}}}

{justify
  In the rule, both procedure types have the same number of parameters.
  Parameter types are compared in reverse {goto car1997 {c [car 1997],}} so
  that each parameter type {i T} on the right is a subtype of its corresponding
  parameter type {i t} on the left.
  Each parameter name {i n} on the left is a {goto subname} of its
  corresponding parameter name {i N} on the right.
  The yield type {i y} on the left is a subtype of the yield type {i Y} on the
  right.

  The {goto typesize size} of a procedure type is an {goto unspecified} small
  positive {goto int integer} {goto constant constant.}
  Two different procedure types do not necessarily have the same size.
  A procedure might be represented as the address of its machine instructions
  in memory.
  If this representation is used, then the size of a procedure type is the size
  of an address.
  However, a procedure type is not a {goto pointer} type.
  It does not necessarily have the same size as a pointer type, or the same
  size as any {goto int integer} type.}

{label typetype}
{left {b 5.9.5. Type types.}}

{justify
  Since all {goto type types} are {goto object objects,} and all objects have
  types, it follows that all types have types.
  The type of a type is called a {i type type.}
  Type types are {goto object transformation} types.

  Suppose that {i t} is a {goto term} which {goto transform transforms} to a
  type.
  Then the term {b type}\ {i t} transforms to a type type that describes its
  {i base} type {i t.}
  For example, {b type}\ {i int} transforms to the type of {goto int {i int,}}
  {b type}\ {b type}\ {i int} transforms to the type of the type of {i int,}
  {b type}\ {b type}\ {b type}\ {i int} transforms to the type of the type of
  the type of {i int,} etc.
  A type type can be a {goto subtype} of another type type, as in {goto rule}
  {b 19.}}

{narrow
 {label rule19}
 {over
  {center {b type} {i t} ⊆ {b type} {i T}}
  {left \ {b 19}}
  {center {i t} ⊆ {i T}}}}

{justify
  Suppose that {i e} is a term which {goto evaluate evaluates} to an
  {goto object instance.}
  Then {b type}\ {i e} transforms to the type of {i e.}
  For example, {b type}\ 0 transforms to {goto int {i int}0,} because the
  {goto intlit literal} 0 has the type {i int}0.
  As a result, {i e} has a type {i t} if and only if {b type}\ {i e} is a
  subtype of {i t.}}

{label vartype}
{left {b 5.9.6. Variable types.}}

{justify
  A {i variable} acts as a container for an {goto object execution} instance,
  called its {i value.}
  The value's {goto type} is called the variable's {i base} type.
  Suppose that the {goto term} {i t} {goto transform transforms} to an
  execution type, but not another variable type.
  Then the term {b var}\ {i t} transforms to the type of a variable whose base
  type is {i t.}
  Variables are execution instances, and their types are both
  {goto object transformation} types and execution types.

  When a variable is created, it can be given an instance of its base type as
  an initial value.
  If it is not given an initial value, then its value is an {goto unspecified}
  instance of its base type.
  After a variable is created, its value can be repeatedly changed by
  {goto call calls} to {goto assignment} forms.

  A variable type can be a {goto subtype} of another variable type, as in
  {goto rule} {b 20.}
  A variable type is also a {goto cotype} of its base type, as in rule {b 21.}}

{narrow
 {label rule20}
 {label rule21}
 {layout
  {row
   {over
    {center {b var} {i t} ⊆ {b var} {i T}}
    {left \ {b 20}}
    {center {i t} ⊆ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center {b var} {i t} ⊑ {i T}}
    {left \ {b 21}}
    {center {i t} ⊑ {i T}}}}}}

{justify
  An {goto expression} of a variable type is almost always
  {goto cotype coerced} to its base type, as in rule {b 21.}
  There are only four situations where it is not.}

{number
 {justify
   When the expression appears as an argument in a {goto call method} call, and
   its type is a subtype of the method's corresponding parameter type.}
 {justify
   When the expression appears as the body of a {goto formclause plain} or
   {goto genclause generic} form, and its type is a subtype of the form's yield
   type.}
 {justify
   When the expression appears in a {goto listclause list} clause.}
 {justify
   When the expression appears prefixed by a {goto typetype type} term.}}

{justify
  A variable of type {b var}\ {i t} is represented in the same way as an
  instance of its base type {i t.}
  As a result, the {goto typesize size} of a variable type is the same as that
  of its base type: {i size}({b var}\ {i t})\ =\ {i size}({i t}).}

{label unit}
{left {b 5.10. Units.}}

{justify
  A {i unit} can be
  a {goto clause clause,}
  a {goto literal literal,} or
  a {goto nameunit name.}
  Suppose
  that {i l} is a unit, 
  that the {i m}'s are zero or more {goto assignment assignments,}
  that the {i r}'s are zero or more assignments,
  and that {i n} is a {goto nametoken name.}
  Then the {goto expression expressions} in the following table are also units.
  Some units {goto abbreviate} {goto call calls} to forms whose {goto quoted}
  names are {goto bind bound} by the standard {goto prelude prelude.}
  These forms are described in the indicated sections of this Report.}

{table
 {row
  {center {b \ \ Section\ \ }}
  {center {b Unit}}
  {center {b Call}}}
 {row
  {left {goto call \ \ 5.10.1.}}
  {left \ {i l}({i r}{- 1}, {i r}{- 2} ..., {i r}{-i k})}
  {left \ }}
 {row
  {left {goto call \ \ 5.10.1.}}
  {left
    \ {i l}({i m}{- 1}, {i m}{- 2} ..., {i m}{-i j} :
            {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k})}
  {left
    \ {i l}({i m}{- 1}, {i m}{- 2} ..., {i m}{-i j},
            (: {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k}))}}
 {row
  {left {goto postbracket \ \ 7.3.1.}}
  {left \ {i l}[{i r}{- 1}, {i r}{- 2} ..., {i r}{-i j}]\ }
  {left \ {i "}␣[]{i "}({i l,} {i r}{- 1}, {i r}{- 2} ..., {i r}{-i j})\ }}
 {row
  {left \ }
  {left
    \ {i l}[{i m}{- 1}, {i m}{- 2} ..., {i m}{-i j} :
            {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k}]\ }
  {left
   \ {i "}␣[]{i "}({i l}, {i m}{- 1}, {i m}{- 2} ..., {i m}{-i j},
           (: {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k}))\ }}
 {row
  {left {goto postbrace \ \ 7.3.2.}}
  {left \ {i l}\{{i r}{- 1}, {i r}{- 2} ..., {i r}{-i j}\}\ }
  {left \ {i "}␣\{\}{i "}({i l,} {i r}{- 1}, {i r}{- 2} ..., {i r}{-i j})\ }}
 {row
  {left \ }
  {left
   \ {i l}\{{i m}{- 1}, {i m}{- 2} ..., {i m}{-i j} :
            {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k}\}\ }
  {left
   \ {i "}␣\{\}{i "}({i l}, {i m}{- 1}, {i m}{- 2} ..., {i m}{-i j},
             (: {i r}{- 1}, {i r}{- 2} ..., {i r}{-i k}))\ }}
 {row
  {left {goto symbol \ \ 5.10.6.}}
  {left \ ${i n}}
  {left \ }}
 {row
  {left {goto dot \ \ 7.3.11.}}
  {left \ {i l} . {i n}\ }
  {left \ {i "}.{i "}({i l,} ${i n})\ }}
 {row
  {left {goto hook \ \ 5.10.3}}
  {left \ ?{i n}}
  {left \ }}
 {row
  {left {goto hook \ \ 5.10.3.}}
  {left \ ?{i n}({i r}{- 1}, {i r}{- 2} ..., {i r}{-i k})}
  {left \ }}
 {row
  {left {goto at \ \ 7.3.33.}}
  {left \ {i l}@\ }
  {left \ {i "}@{i "}({i l})\ }}
 {row
  {left {goto at \ \ 7.3.33.}}
  {left \ {i l}↓\ }
  {left \ {i "}↓{i "}({i l})\ }}
 {row
  {left {goto uparrow \ \ 7.3.35.}}
  {left \ {i l}{q ^}\ }
  {left \ {i "}{q ^}{i "}({i l})\ }}
 {row
  {left {goto uparrow \ \ 7.3.35.}}
  {left \ {i l}↑\ }
  {left \ {i "}↑{i "}({i l})\ }}}

{justify
  A {goto symboltoken colon} lets some units have the {i r}'s as optional
  arguments.
  These arguments become the elements of a {goto list list,} which in turn is
  {goto call passed} to a form as its last argument.
  The form then obtains the optional arguments from the list.}

{label call}
{left {b 5.10.1. Calls.}}

{justify
  If {i m} is a {goto unit unit,} and the {i a}'s are zero or more
  {goto assignment assignments} separated by {goto symboltoken commas,} then
  the following unit is a {i call.}}

{narrow{orson
m(a{- 1}, a{- 2} ..., a{- k})}}

{justify
  The unit {i m} is called a {i method,} and the {i a}'s are called its
  {i arguments.}
  The call is either a {i form call} or a {i procedure call,} depending on the
  {goto object} to which the method {goto evaluate evaluates.}
  In either case, the method and its arguments together are evaluated in an
  {goto unspecified} order.
  There may be a {goto limit} on the number of arguments that can appear in a
  call.

  In a form call, the method {i m} {goto transform transforms} to an
  {goto altclause alternate} form, a {goto genclause generic} form, or a
  {goto formclause plain} form.
  Each argument also transforms to an {goto expression} or an object.
  The form call uses these expressions or objects, and their {goto type types,}
  to compute a new expression or object.
  It then transforms to the new expression or object, and its type.
  Form calls are described in more detail along with {goto altclause {i alt}}
  clauses, {goto formclause {i form}} clauses, and {goto genclause {i gen}}
  clauses.

  In a procedure call, the method {i m} evaluates to a
  {goto procclause procedure.}
  Each argument {goto must} also evaluate to an {goto object execution}
  instance.
  The procedure call uses these instances to compute a new execution instance
  that is not a {goto vartype variable.}
  It then evaluates to the new instance.
  Procedure calls are described in more detail along with
  {goto procclause {i proc}} clauses.}

{justify
  {b Optional arguments.}
  A form call can have zero or more optional arguments following a
  {goto symboltoken colon,} like this.}

{narrow{orson
m(a{- 1}, a{- 2} ..., a{- k} : a{- k+1}, a{- k+2} ..., a{- k+l})}}

{justify
  It {goto abbreviate abbreviates} a call whose last argument is a
  {goto listclause list} clause.}

{narrow{orson
m(a{- 1}, a{- 2} ..., a{- k}, (: a{- k+1}, a{- k+2} ..., a{- k+{i l}}))}}

{justify
  When the form call is transformed, the list clause transforms to a
  {goto list list,} from which the form obtains its optional arguments.
  Procedure calls cannot have optional arguments, because lists are not
  execution instances.
  However, procedure calls with optional arguments can often be simulated by
  form calls that transform to procedure calls.}

{label forward}
{left {b 5.10.1.1. Forwarding.}}

{justify
  Suppose that there is a {goto progclause {i prog}} or
  {goto withclause {i with}} clause in which an {goto withclause equate}
  {goto bind binds} the {goto nameunit name} {i a} to a {goto call method.}
  Also suppose that later, in the same {i prog} or {i with} clause, an equate
  binds the name {i b} to another method.
  Then the method {i b} can {goto call} the method {i a,} because the name
  {i a} is {goto bind bound} when the method {i b} is
  {goto evaluate evaluated.}
  However, the method {i a} can also call the method {i b,} even though the
  name {i b} is {goto bind unbound} when the method {i a} is evaluated.
  The name {i b} is said to be {i forwarded.}

  Forwarding allows methods whose names are bound in the same {i prog} or
  {i with} clause to call each other freely.
  It also allows methods to call themselves.
  In the following example, the {goto formclause plain} form {i a} calls the
  forwarded {goto procclause procedure} {i b,} and vice versa.
  If the method {i writeln} displays its argument on an output device, then the
  call {i a}(3) will display the {goto int integers} 3, 2, and 1.}

{narrow{orson
a :−
 (form (int k) void:
  (if k > 0
   then writeln(k)
        b(k − 1)))
b :−
 (proc (int k) void:
  (if k > 0
   then writeln(k)
        a(k − 1)))}}

{justify
  Orson might implement forwarding by delaying the
  {goto transform transformation} of method bodies.
  A form's body is not transformed until the form is called.
  A procedure's body might not be transformed until all the equates of the
  {i prog} or {i with} clause in which it appears are transformed.
  As a result, only calls that appear in method bodies can be forwarded.
  Also, if a name is forwarded in a {i prog} or {i with} clause, then it
  {goto must} eventually be bound by an equate in that same {i prog} or
  {i with} clause.}

{label subsume}
{left {b 5.10.1.2. Subsumption.}}

{justify
  Suppose that a form of {goto type} {i t} can always be {goto call called}
  with the same arguments as another form of type {i T.}
  Then the form of type {i t} is said to be {i subsumed by} the form of type
  {i T,} and the form of type {i T} is said to {i subsume} the form of type
  {i t.}
  Similarly, {i t} is said to be subsumed by {i T,} and {i T} is said to
  subsume {i t.}
  This is written as {i t}\ ≼\ {i T,} which is similar to the notation used for
  {goto subtype subtypes.}

  The following {goto genrule extended} {goto rule rules} constitute an
  algorithm that decides if {i t} is subsumed by {i T.}
  It is a simplified version of the {goto gensubtype algorithm} that decides if
  a form type is a subtype of another form type.
  The algorithm assumes that all generic {goto nametoken names} declared in
  {i t} and {i T} together are {goto distinct} from each other.
  Generic names that violate this assumption are replaced by {goto unique}
  names which appear nowhere else.}

{justify
  {b Remove alternate form types.}
  In the first step of the algorithm, {goto rule statements} about
  {goto altsclause alternate} form types are replaced by equivalent statements
  about {goto formtype plain} and {goto gentype generic} form types.
  An alternate form type is subsumed by a type {i T} if each member type {i t}
  is also subsumed by {i T,} as in rules {b 22} and {b 23.}
  The {goto joker} type {goto {i foj}} describes all form types.
  Each statement about a member type {i t} and {i T} is proved separately.}

{narrow
 {label rule22}
 {label rule23}
 {layout
  {row
   {over
    {center {- \ }({b alts}) ≼ {i T}{- \ }}
    {left \ {b 22}}
    {center {i T} ⊆ {i foj}}}
   {left \ \ \ \ \ }
   {over
    {center ({b alts} {i t}{- 1}, {i t}{- 2} ..., {i t}{-i k}) ≼ {i T}}
    {left \ {b 23}}
    {layout
     {row
      {center {i t}{- 1} ≼ {i T}}
      {left ,\ \ ({b alts} {i t}{- 2} ..., {i t}{-i k}) ≼ {i T}}}
     {row
      {rule}
      {left \ }}
     {row
      {center ⋮}
      {left \ }}}}}}}

{justify
  Rules {b 24} and {b 25} state that a type {i t} is subsumed by an alternate
  form type if it is subsumed by at least one member type.}

{narrow
 {label rule24}
 {label rule25}
 {layout
  {row
   {over
    {center {i t} ≼ ({b alts} {i T}{- 1}, {i T}{- 2} ..., {i T}{-i k})}
    {left \ {b 24}}
    {center {i t} ≼ {i T}{- 1}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ≼ ({b alts} {i T}{- 1}, {i T}{- 2} ..., {i T}{-i k})}
    {left \ {b 25}}
    {center {i t} ≼ ({b alts} {i T}{- 2} ..., {i T}{-i k})}}}}}

{justify
  Because of these rules, an alternate form type can be subsumed by a generic
  or plain form type, and vice versa.
  Also, any form type subsumes ({b alts}), but no form type is subsumed by
  ({b alts}) except itself.}

{justify
  {b Mark generic prefixes.}
  By the second step of the algorithm, only statements like {i t}\ ≼\ {i T}
  remain, where {i t} and {i T} are generic or plain form types.
  Each generic prefix in {i t} is marked with a superscript {c r,} indicating
  that the generic names it declares will be replaced by parts of {i T}'s
  parameter types.
  These generic prefixes are called {i replacing prefixes.}
  Similarly, each generic prefix in {i T} is marked with a superscript {c s,}
  indicating that the generic names it declares will be replaced by
  {goto skolem Skolemized} types.
  These generic prefixes are called {i Skolemizing prefixes.}}

{justify
  {b Add a separator.}
  The third step is to add a separator `|', as in rule {b 26.}
  This lets other rules add statements about generic names on the left side of
  the separator.}

{narrow
 {label rule26}
 {over
  {center {i t} ≼ {i T}}
  {left \ {b 26}}
  {center {i true} | {i t} ≼ {i T}}}}

{justify
  {b Remove generic prefixes.}
  The fourth step removes all generic prefixes from {i t} and {i T.}
  Rule {b 27} removes a replacing prefix and adds equivalent statements about
  its generic names on the left of the separator `|'.}

{narrow
 {label rule27}
 {over
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j} | {b gen}{+c r} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f} ≼ {i F}}
  {left \ {b 27}}
  {center
   {i a}{- 1}, {i a}{- 2} ..., {i a}{-i j}, {b type} {i n}{- 1} ⊆ {i g}{- 1}, {b type} {i n}{- 2} ⊆ {i g}{- 2} ..., {b type} {i n}{-i k} ⊆ {i g}{-i k} | {i f} ≼ {i F}}}}

{justify
  Rule {b 28} removes a Skolemizing prefix, {goto replace replacing}
  {goto freedom free} appearances of the generic names it declares by
  Skolemized types.
  Each {i s} is the type that results from {goto skolem Skolemizing} its
  corresponding type {i g.}}

{narrow
 {label rule28}
 {over
  {center
   {i f} ≼ {b gen}{+c s} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i F}⟨{i n}{- 1}, {i n}{- 2} ..., {i n}{-i k}⟩}
  {left \ {b 28}}
  {center
   {i f} ≼ {i F}⟨{i s}{- 1}, {i s}{- 2} ..., {i s}{-i k}⟩}}}

{justify
  {b Subsumption.}
  In the fifth step, only statements about plain form types remain on the right
  of the separator `|'.
  Rule {b 29} describes how a plain form type is subsumed by another plain form
  type.}

{narrow
 {label rule29}
 {over
  {center
   {b form} ({i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) {i t} ≼ {b form} ({i T}{- 1} {i N}{- 1}, {i T}{- 2} {i N}{- 2} ..., {i T}{-i k} {i N}{-i k}) {i T}}
  {left \ {b 29}}
  {center
   {i t}{- 1} ⊑ {i T}{- 1}, {i t}{- 2} ⊑ {i T}{- 2} ..., {i t}{-i k} ⊑ {i T}{-i k}}}}

{justify
  Just as in rule {goto rule04 4,} both form types have the same number of
  parameters.
  However, in rule {b 29,} parameter types are not compared in reverse.
  Each parameter type {i t} on the left is a {goto cotype} of its corresponding
  parameter type {i T} on the right.
  Parameter names and yield types are not compared at all.}

{justify
  {b Example.}
  A form of type {b form}\ ({b var}\ {i int}\ {i v})\ {i int} subsumes a form
  of type {b form}\ ({i int}\ {i i})\ {i int.}
  This is discussed informally, and in more detail, along with
  {goto altsclause {i alts}} clauses.
  However, it can also be formally {goto rule proved} like this.}

{narrow
 {over
  {center
   {b form} ({b var} {i int} {i v}) {i void} ≼ {b form} ({i int} {i i}) {i int}}
  {left \ {goto rule29 29}}
  {center {b var} {i int} ⊑ {i int}}
  {left \ {goto rule21 21}}
  {center {i int} ⊑ {i int}}
  {left \ {goto rule01 1}}
  {center {i int} ⊆ {i int}}
  {left \ {goto rule00 0}}
  {center {i true}}}}

{label clause}
{left {b 5.10.2. Clauses.}}

{justify
  A {i clause} appears between {goto symboltoken parentheses}
  `\ (\ ' and '\ )\ '.
  Most clauses are {goto unit units,} so they can appear as parts of
  {goto expression expressions.}
  They include
  {goto altclause {i alt}} clauses,
  {goto altsclause {i alts}} clauses,
  {goto caseclause {i case}} clauses,
  {goto catchclause {i catch}} clauses,
  {goto expclause expression} clauses,
  {goto forclause {i for}} clauses,
  {goto formclause {i form}} clauses,
  {goto genclause {i gen}} clauses,
  {goto ifclause {i if}} clauses,
  {goto listclause list} clauses,
  {goto pastclause {i past}} clauses,
  {goto procclause {i proc}} clauses,
  {goto tupleclause {i tuple}} clauses,
  {goto whileclause {i while}} clauses, and
  {goto withclause {i with}} clauses.
  However, {goto loadclause {i load}} clauses and {goto progclause {i prog}}
  clauses are not units, so they can appear only as parts of
  {goto program programs.}}

{label altclause}
{left {b 5.10.2.1. {i Alt} clauses.}}

{justify
  An {i alternate form} is a {goto call method} whose {goto call}
  {goto transform transforms} to an {goto expression} or an
  {goto object object,} and its {goto type type.}
  Alternate forms are {goto object transformation} instances, and their types
  are transformation types.
  Each alternate form is written as an {i alt} clause that has a series of zero
  or more {i member} forms.
  If the {i e}'s are {goto assignment assignments} that transform to member
  forms, then this is an {i alt} clause.}

{narrow
 {left ({b alt} {i e}{- 1}, {i e}{- 2} ..., {i e}{-i k})}}

{justify
  An {i alt} clause with exactly one member form, ({b alt}\ {i e}), is
  equivalent to simply {i e.}
  A nested {i alt} clause, like this,}

{narrow
 {left
  ({b alt}
   {i e}{- 1}, {i e}{- 2} ..., {i e}{-i j},
   ({b alt} {i e}{- {i j}+1}, {i e}{- {i j}+2} ..., {i e}{- {i j}+{i k}}),
   {i e}{- {i j}+{i k}+1},
   {i e}{- {i j}+{i k}+2} ..., {i e}{- {i j}+{i k}+{i l}})}}

{justify
  is equivalent to one that is not nested, like this.}

{narrow
 {left
  ({b alt}
   {i e}{- 1}, {i e}{- 2} ..., {i e}{-i j},
   {i e}{- {i j}+1}, {i e}{- {i j}+2} ..., {i e}{- {i j}+{i k}},
   {i e}{- {i j}+{i k}+1},
   {i e}{- {i j}+{i k}+2} ..., {i e}{- {i j}+{i k}+{i l}})}}

{justify
  As a result of this equivalence, each member form is assumed to be either a
  {goto formclause plain} form or a {goto genclause generic} form, not another
  alternate form.
  There may be a {goto limit} on the number of member forms in an {i alt}
  clause.}

{justify
  {b Alternate form calls.}
  When an alternate form is {goto call called,} Orson tries to call its member
  forms, one at a time, in order of appearance.
  If calling a member would be an {goto errors error} because of inappropriate
  arguments, then Orson does not call it, or report the error, but goes on to
  try the next member.
  Orson continues in this way until it finds the first member that can be
  called, and then calls it.
  The alternate form call finally transforms to the expression or object, and
  its type, that result from calling this member.

  For example, the following {goto withclause equate} {goto bind binds} the
  {goto nametoken name} {i inc} to an alternate form that
  {goto plusequal increments} an {goto int integer}
  {goto vartype variable.}
  It has two members.
  If {i u} is an integer variable, then {i inc}({i u,}\ 2) calls the first
  member, and {i inc}({i u}) calls the second member.}

{narrow{orson
inc :−
 (alt
  (form (var int v, int Δ) void:
    v += Δ),
  (form (var int v) void:
    v += 1))}}

{justify
  It is an error to call an alternate form with arguments for which no member
  can be called.
  For example, the call {i inc}(2) is an error, because neither of {i inc}'s
  members can be called with a single integer as its argument.
  It is always an error to call the alternate form ({b alt}), because it has no
  members at all.}

{justify
  {b Subsumed member forms.}
  It is also an error if an alternate form has a member form that can never be
  called.
  Suppose that there is a member {i a} followed by another member {i b}.
  If {i a} can always be called with the same arguments as {i b,} then {i b}
  can never be called, because any attempt to call {i b} will call {i a}
  instead.
  The member {i b} is said to be {goto subsume subsumed} by the member {i a.}
  It is an error for a member to be subsumed in this way.

  For example, suppose that a new first member is added to {i inc,} so it looks
  like the following.
  Then the first member allows {i inc} to be called on an integer, so
  {i inc}(2) evaluates to 3.
  However, it also subsumes the third member.
  If {i u} is an integer variable, then {i inc}({i u}) calls the first member,
  not the third, because {i u} is {goto cotype coerced} to an integer.}

{narrow{orson
inc :−
 (alt
  (form (int i) int:
    i + 1),
  (form (var int v, int Δ) void:
    v += Δ),
  (form (var int v) void:
    v += 1))}}

{justify
  Subsumption errors can often be avoided by reordering an {i alt} clause's
  members.
  For example, {i inc} can be reordered so the member that increments an
  integer variable appears before the member that increments an integer.}

{narrow{orson
inc :−
 (alt
  (form (var int v) void:
    v += 1),
  (form (int i) int:
    i + 1),
  (form (var int v, int Δ) void:
    v += Δ))}}

{justify
  Now {i inc}({i u}) calls the first member without coercing {i u,} and
  {i inc}(2) calls the second member.
  The third member is called in the same way as before.}

{label altsclause}
{left {b 5.10.2.2. {i Alts} clauses.}}

{justify
  An {i alts} clause {goto transform transforms} to an {i alternate form type,}
  the {goto type} of an {goto altclause alternate} form.
  Alternate forms are {goto object transformation} instances, and their types
  are transformation types.
  Suppose that the {i t}'s are zero or more {goto gentype generic} form types
  and {goto formtype plain} form types.
  Also suppose that the {i s}'s are zero or more {goto expression expressions,}
  so this is an {goto altclause {i alt}} clause which transforms to an
  alternate form.}

{narrow{orson
(alt (t{- 1}: s{- 1}), (t{- 2}: s{- 2}) ..., (t{- k}: s{- k}))}}

{justify
  Then the following is an {i alts} clause that transforms to the alternate
  form's type.
  It has a series of zero or more {i member types,} the types of the alternate
  form's member forms.
  There may be a {goto limit} on the number of member types in an {i alts}
  clause.}

{narrow{orson
(alts t{- 1}, t{- 2} ..., t{- k})}}

{justify
  It is an {goto errors error} if a member type is {goto subsume subsumed} by
  another member type that appears before it in the {i alts} clause.
  It is also an error for a {goto joker} type or a {goto skolem Skolem} type to
  appear as a member.
  As a result, it is an error for a {goto gentype generic}
  {goto nametoken name} to appear as a member, because it will be
  {goto replace replaced} by a Skolem type when the {i alts} clause is
  transformed.
  However, joker types, Skolem types, and generic names can appear as parts of
  members.

  An {i alts} clause with exactly one member type, ({b alts}\ {i t}), is
  equivalent to simply {i t.}
  A nested {i alts} clause like this,}

{narrow
 {left
  ({b alts}
   {i t}{- 1}, {i t}{- 2} ..., {i t}{-i j},
   ({b alts} {i t}{- {i j}+1}, {i t}{- {i j}+2} ..., {i t}{- {i j}+{i k}}),
   {i t}{- {i j}+{i k}+1},
   {i t}{- {i j}+{i k}+2} ..., {i t}{- {i j}+{i k}+{i l}})}}

{justify
  is equivalent to one that is not nested, like this.}

{narrow
 {left
  ({b alts}
   {i t}{- 1}, {i t}{- 2} ..., {i t}{-i j},
   {i t}{- {i j}+1}, {i t}{- {i j}+2} ..., {i t}{- {i j}+{i k}},
   {i t}{- {i j}+{i k}+1},
   {i t}{- {i j}+{i k}+2} ..., {i t}{- {i j}+{i k}+{i l}})}}

{justify
  As a result of this equivalence, each member type is assumed to be either a
  plain form type or a generic form type, not another alternate form type.

  An alternate form type is a {goto subtype} of another type {i T} if at least
  one of its member types is a subtype of {i T,} as in {goto rule rules} {b 30}
  and {b 31.}}

{narrow
 {label rule30}
 {label rule31}
 {layout
  {row
   {over
    {center ({b alts} {i t}{- 1}, {i t}{- 2} ..., {i t}{-i k}) ⊆ {i T}}
    {left \ {b 30}}
    {center {i t}{- 1} ⊆ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center ({b alts} {i t}{- 1}, {i t}{- 2} ..., {i t}{-i k}) ⊆ {i T}}
    {left \ {b 31}}
    {center ({b alts} {i t}{- 2} ..., {i t}{-i k}) ⊆ {i T}}}}}}

{justify
  A type {i t} is a subtype of an alternate form type if it is a subtype of
  each member type {i T,} as in rules {b 32} and {b 33.}
  The {goto joker} type {goto {i foj}} describes all form types.
  Each statement about {i t} and a member type {i T} is proved separately.}

{narrow
 {label rule32}
 {label rule33}
 {layout
  {row
   {over
    {center {- \ }{i t} ⊆ ({b alts}){- \ }}
    {left \ {b 32}}
    {center {i t} ⊆ {i foj}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ ({b alts} {i T}{- 1}, {i T}{- 2} ..., {i T}{-i k})}
    {left \ {b 33}}
    {layout
     {row
      {center {i t} ⊆ {i T}{- 1}}
      {left ,\ \ {i t} ⊆ ({b alts} {i T}{- 2} ..., {i T}{-i k})}}
     {row
      {rule}
      {left \ }}
     {row
      {center ⋮}
      {left \ }}}}}}}

{justify
  Because of these rules, an alternate form type can be a subtype of a generic
  form type or a plain form type, and vice versa.
  Also, any form type is a subtype of ({b alts}), but ({b alts}) is not a
  subtype of any form type except itself.}

{label caseclause}
{left {b 5.10.2.3. {i Case} clauses.}}

{justify
  A {i case} clause first {goto evaluate evaluates} an
  {goto expression expression} to a {goto char character} or an
  {goto int integer.}
  It then uses the character or integer to select and evaluate one of many
  {goto assignment assignments.}
  Each {i case} clause looks like the following.
  There may be an extra {goto semicolon} after the last {i e.}}

{narrow
 {left
  ({b case} {i s}
   {b of} {i l}{- 1}: {i e}{- 1} ;
          {i l}{- 2}: {i e}{- 2} ... ;
          {i l}{-i k}: {i e}{-i k} ;
          {b none}: {i e}{- {i k}+1})}}

{justify
  Here {i s} is an expression that evaluates to a character or an integer, and
  the {i e}'s are one or more assignments.
  The {i l}'s are also one or more assignments, called {i labels.}
  If {i s} evaluates to a character, then the labels {goto must}
  {goto transform} to character {goto constant constants.}
  If {i s} evaluates to an integer, then they must transform to integer
  constants.
  It is an {goto errors error} if two or more labels in a {i case} clause
  transform to the same constant.
  The labeled assignments, including the one labeled by {b none,} may appear
  in any order.
  There may be {goto limit limits} on the number of labels, and on the range of
  labels, in a {i case} clause.

  The {i case} clause ({b case}\ {i s}\ {b of}\ {b none}:\ {i e}), with only
  one {i e,} is equivalent to {i e} itself.
  A {i case} clause with two or more {i e}'s acts like an
  {goto abbreviate abbreviation} for the following {goto ifclause {i if}}
  clause inside a {goto withclause {i with}} clause.
  Here {i u} is a {goto unique} name that appears nowhere else, and the
  {goto comparison} operator `=' tests if two characters or two integers are
  {goto eq equal.}}

{narrow{orson
(with u :− (s){- \ }
 do (if u = l{- 1}
     then e{- 1}
     else if u = l{- 2}
          then e{- 2}
          else ...{- \ }
               if u = l{-i k}
               then e{-i k}
               else e{- {i k}+1}))}}

{justify
  As a result of the abbreviation, the {i case} clause first evaluates the
  expression {i s} to a character or integer.
  It then evaluates the assignment {i e} whose label {i l} equals that
  character or integer.
  If there is no assignment with such a label, then the {i case} clause
  evaluates the assignment whose label is {b none} instead.

  Orson does not necessarily implement a {i case} clause in this way, which
  selects the {i j}th labeled assignment in time proportional to {i j.}
  Instead, it implements a {i case} clause in an {goto unspecified} way that
  selects each labeled assignment in a small, constant amount of time.
  It might use a jump table {goto pat2005 {c [pat 2005].}}
  As a result, {i case} clauses are almost always more efficient than their
  equivalent {i if} clauses.}

{justify
  {b Abbreviations.}
  A {i case} clause can be {goto abbreviate abbreviated} in two ways.
  First, suppose that the {i case} clause has an assignment {i e} with two or
  more labels separated by {goto symboltoken commas:}}

{narrow{orson
l{- 1}, l{- 2} ..., l{-i k} : e}}

{justify
  Then this abbreviates a series of labeled assignments, in which {i e} appears
  two or more times, each with a different label.
  However, {i e} is still {goto transform transformed} only once.}

{narrow
 {layout
  {row
   {right {i l}{- 1}}
   {center :}
   {left {i e}}}
  {row
   {right {i l}{- 2}}
   {center :}
   {left {i e}}}
  {row
   {left \ }
   {center ⋮}
   {left \ }}
  {row
   {right {i l}{-i k}}
   {center :}
   {left {i e}}}}}

{justify
  Second, a {i case} clause in which no assignment is labeled by {b none}
  abbreviates one in which {goto void {i skip}} is labeled by {b none.}
  Such a {i case} clause always evaluates to {i skip,} so it should be used
  only for its side effects.}

{label catchclause}
{left {b 5.10.2.4. {i Catch} clauses.}}

{justify
  A {i catch} clause terminates the {goto execute execution} of an
  {goto expression} in response to an unusual situation.
  If {i s} is an expression with an {goto object execution} {goto type type,}
  then ({b catch}\ {i s}) is a {i catch} clause.
  It {goto abbreviate abbreviates} the {goto call} {i "}catch{i "}(({i s})).
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}catch{i "} to a {goto formclause plain} form like this.}

{narrow{orson
"catch" :−
  (form (exe s) int:
    ?catch(s))}}

{justify
  The standard prelude also binds the {goto plain} names {i rethrow,}
  {i throw,} and {i thrown} to forms that are used along with {i catch}
  clauses.}

{narrow{orson
rethrow :−
 (form () void:
   throw(thrown()))

throw :−
 (alt
  (form () void:
    throw(0)),
  (form (int r) void:
    ?throw(r)))

thrown :−
 (form () int:
   ?thrown())}}

{justify
  {b Catching and throwing.}
  Ordinarily, the {i catch} clause ({b catch}\ {i s}) {goto evaluate evaluates}
  the expression {i s} and returns the {goto int integer} 0.
  However, suppose that {i s} executes the call {i throw}({i r}), where {i r}
  evaluates to an integer.
  The call to {i throw} need not appear as a {goto unit} in {i s,} but may be
  executed as an indirect result of executing {i s.}
  For example, {i s} might call a {goto procclause procedure} that calls
  {i throw.}
  Then any {goto scope scopes} established by {i s} are exited, the execution
  of {i s} is terminated, and the {i catch} clause returns {i r} instead.

  Now suppose that two or more {i catch} clauses are executing at the same
  time, possibly as an indirect result of executing {i s.}
  For example, {i s} might call a procedure that executes another {i catch}
  clause.
  Then {i throw}({i r}) terminates the {i catch} clause whose execution began
  most recently.
  If no {i catch} clauses are executing, then {i throw}({i r}) terminates the
  entire {goto program program,} as if {goto {i exit}} was called with {i r.}

  During {goto transform transformation,} {i throw}({i r}) is treated as if it
  will execute to {goto void {i skip.}}
  (It is treated differently if it appears in a {goto caseclause {i case}} or
  {goto ifclause {i if}} clause.)
  However, it actually executes to no object, because it always stops the
  execution of the expression in which it appears.

  By convention, {i catch} and {i throw} handle unusual situations that occur
  during execution.
  If ({b catch}\ {i s}) returns 0, then no unusual situations occurred during
  the execution of {i s}: either {i throw} was never called, or it was called
  with the argument 0.
  (The call {i throw}() is equivalent to the call {i throw}(0).)
  If the {i catch} clause returns a nonzero integer, then an unusual situation
  did occur, and {i throw} was called in response.
  The integer can then be used to identify the situation.}

{justify
  {b Exceptions and handlers.}
  A nonzero integer returned by a {i catch} clause is called an
  {goto except {i exception.}}
  It is often used to select and execute an expression called a {i handler.}
  Executing the handler responds somehow to the situation that terminated the
  {i catch} clause.
  The following {i case} clause shows one way to select and execute handlers.
  The {i e}'s transform to exceptions, and the {i h}'s are
  {goto assignment assignments} that act as handlers.}

{narrow{orson
(case (catch s) of 0: h{- 0} ; e{- 1}: h{- 1} ; e{- 2}: h{- 2} ... ; e{- k}: h{- k} ; none: h{- k+1})}}

{justify
  If the {i catch} clause evaluates to 0, indicating that no unusual situation
  has occurred, then the handler labeled 0 is executed.
  If it evaluates to an exception which is one of the {i e}'s, indicating that
  an unusual situation has occurred, then the handler labeled by the exception
  is executed.
  Otherwise the default handler, labeled {b none}, is executed instead.

  The call {i thrown}() evaluates to the most recently thrown exception.
  If no exception has ever been thrown, then it evaluates to 0.
  A handler can call {i thrown} to obtain the exception that caused its
  execution.
  This exception can be passed to a handler associated with another {i catch}
  clause by executing the call {i rethrow}(), which is equivalent to
  {i throw}({i thrown}()).

  Orson's exception handling mechanism is rudimentary when compared with those
  of other programming languages {goto gos1996 {c [gos 1996].}}
  However, the {i catch} clause, {i rethrow,} {i throw,} and {i thrown} are
  all implemented as forms.
  This might allow a more elaborate mechanism to be built by redefining them,
  perhaps in a {goto prefix library} file.}

{label expclause}
{left {b 5.10.2.5. Expression clauses.}}

{justify
  An {i expression clause} is simply an {goto expression} {i e} in parentheses,
  ({i e}).
  It is {goto evaluate evaluated} in the same way as {i e.}
  Expression clauses let parentheses be used as grouping symbols.}

{label forclause}
{left {b 5.10.2.6. {i For} clauses.}}

{justify
  {i For} clauses {goto abbreviate} certain {goto expression expressions} that
  involve {goto call calls} to {i higher-order} forms.
  Such forms may take forms as their arguments, and may return forms as their
  results.
  Suppose that the {i t}'s are one or more {goto term terms} which
  {goto transform} to {goto type types,} and that the {i n}'s are one or more
  {goto distinct} {goto nametoken names,} any or all of which may be
  {goto missing missing.}
  Also suppose that the {i e}'s are one or more {goto assignment assignments,}
  and that {i s} is an expression.
  Then the following table shows {i for} clauses and the form calls they
  {goto abbreviate abbreviate.}}

{table
 {row
  {center {b {i For} clause}}
  {center {b Call}}}
 {row
  {orson
 (for t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- j} n{- j} in e{- 1}, e{- 2} ..., e{- k} do s) }
  {orson
 "for"((form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- j} n{- j}) obj: s), e{- 1}, e{- 2} ..., e{- k}) }}
 {row
  {orson
 (for t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- j} n{- j} do s) }
  {orson
 "for"((form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- j} n{- j}) obj: s)) }}
 {row
  {orson
 (in e{- 1} e{- 2} ..., e{- k} do s) }
  {orson
 "for"((form () obj: s), e{- 1}, e{- 2} ..., e{- k}) }}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}for{i "} to the following {goto altclause alternate} form.
  Its first four members are {goto formclause plain} forms that act as
  {i counting loops.}
  The fifth member is a {goto genclause generic} form that acts as a
  {i wrapper,} which embeds a form call inside another expression.}

{narrow{orson
"for" :−
  (alt
   (form (form (int) obj body, int b, int e, int s) void:
    (with
      int e :− (past e)
      int s :− (past s)
      var int k :− b
     do (while (if s ≥ 0 then k ≤ e else k ≥ e)
         do body(k)
            k += s))),
   (form (form (int) obj body, int b, int e) void:
     "for{i "}(body, b, e, 1)),
   (form (form (int) obj body, int e) void:
     "for"(body, 0, e − 1, 1)),
   (form (form () obj body, int e) void:
    (with var int e :− (past e)
     do (while e > 0
         do body()
            e −= 1))),
   (gen (type foj bodyType)
     gen (type form (bodyType) obj wrapType)
      form (bodyType body, wrapType wrap) obj:
       wrap(body)))}}

{justify
  {b Counting loops.}
  Suppose that {i n} is a {goto nametoken name,} that {i b,} {i e,} and {i s}
  are assignments that {goto evaluate} to {goto int {i int}'s,} and that {i d}
  is an expression.
  Then the {i for} clause
  ({b for}\ {i int}\ {i n}\ {b in}\ {i b,}\ {i e,}\ {i s}\ {b do}\ {i d})
  repeatedly {goto execute executes} {i d} for {goto bind bindings} of {i n,}
  beginning with {i b} and ending with {i e,} in steps of {i s.}
  Similarly, the {i for} clause
  ({b for}\ {i int}\ {i n}\ {b in}\ {i b,}\ {i e}\ {b do}\ {i d})
  repeatedly executes {i d} for bindings of {i n} from {i b} to {i e,} in steps
  of 1, and the {i for} clause
  ({b for}\ {i int}\ {i n}\ {b in}\ {i e}\ {b do}\ {i d}) repeatedly
  executes {i d} for bindings of {i n} from 0 to {i e}\ −\ 1, in steps of 1
  (the indexes of an {goto prebracket array} whose length is {i e}).
  For example, if the {goto call method} {i writeln} displays its argument on
  an output device, then each of these {i for} clauses displays 0 through 9.}

{narrow{orson
(for int m in 0, 9, 1 do writeln(m))
(for int m in 0, 9 do writeln(m))
(for int m in 10 do writeln(m))}}

{justify
  If {i e} evaluates to an {goto int integer} greater than 0, then the {i for}
  clause ({b in}\ {i e}\ {b do}\ {i d}) executes {i d} a total of {i e} times,
  but without binding a name.
  If {i e} evaluates to an integer less than or equal to 0, then it does
  nothing.
  All four counting loops evaluate to {goto void {i skip.}}}

{justify
  {b Wrappers.}
  Suppose that the {i t}'s are zero or more terms which transform to types, and
  that the {i n}'s are zero or more distinct names, any or all of which can be
  missing.
  Also suppose that {i w} is an expression which transforms to a form, and that
  {i d} is an expression.
  Then a {i for} clause that looks like this:}

{narrow{orson
(for t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{-i k} n{-i k} in w do d)}}

{justify
  is equivalent to a call to {i w} that looks like this.}

{narrow{orson
w((form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{-i k} n{-i k}) obj: d))}}

{justify
  The form {i w} is called a {i wrapper.}
  A wrapper is a higher-order form that takes another form {i f} as its
  argument.
  It typically transforms to a new expression in which a call to {i f} appears
  as a {goto unit unit.}
  In effect, the call to {i f} is wrapped in the new expression, which is how
  the wrapper gets its name.

  A wrapper is usually created by calling yet another form.
  For example, a call to the form {i elements} accepts an integer
  {goto prebracket array} as its argument.
  It transforms to a wrapper that uses a counting loop to visit the array's
  elements.
  The {goto pastclause {i past}} and {goto withclause {i with}} clauses prevent
  the array and its elements from being evaluated more often than necessary.}

{narrow{orson
elements :−
 (form ([] int a) foj:
  (form (form (int) obj body) obj:
   (with [] int a :− (past a)
    do (for int j in length(a)
        do (with int e :− a[j]
            do body(e))))))}}

{justify
  The {i for} clause
  ({b for}\ {i int}\ {i e}\ {b in}\ {i elements}({i a})\ {b do}\ {i writeln}({i e}))
  uses {i elements} to display each element {i e} of the array {i a.}
  A wrapper that visits parts of an {goto object} in this way is called an
  {i iterator,} a term borrowed from the programming language {c Clu}
  {goto lis1981 {c [lis 1981].}}}

{label formclause}
{left {b 5.10.2.7. {i Form} clauses.}}

{justify
  A {i form} clause {goto transform transforms} to a plain form.
  A {i plain form} is a {goto call method} whose {goto call} transforms to an
  {goto expression} or an {goto object object,} and its {goto type type.}
  Plain forms are {goto object transformation} instances, and their types are
  transformation types.
  Each {i form} clause looks like this.
  It consists of a {goto formtype plain} form type, followed by a
  {goto symboltoken colon,} followed in turn by an expression {i s} called the
  {i body.}}

{narrow{orson
(form (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- k} n{- k}) y: s)}}

{justify
  In the plain form type, there are zero or more {i t}\ {i n} pairs called
  {i parameters.}
  Each {i t} is a {goto term} that transforms to a type called a
  {i parameter type,} and each {i n} is a {goto namepart name} called a
  {i parameter name.}
  Any or all of the parameter names may be {goto missing missing,} and all the
  parameter names {goto must} be {goto distinct} from each other.
  The parameters describe the arguments with which the plain form can be
  called.
  A parameter with the missing name ⬚ describes an unused argument.
  There may be a {goto limit} on the number of parameters in a plain form type.
  The term {i y} transforms to a type called the {i yield type.}
  The yield type describes the expression or object to which the call
  transforms.}

{justify
  {b Transforming a {i form} clause.}
  When a {i form} clause is transformed, the type that appears on the left side
  of the colon is transformed.
  As a result, each parameter type {i t} transforms to a corresponding type
  {i T,} and the yield type {i y} transforms to a type {i Y.}
  The body {i s} is not transformed.
  The {i form} clause then transforms to a plain form whose type is the
  transformed form type.
  The plain form contains the transformed parameter types, the parameter names,
  the transformed yield type, and the untransformed body.
  It also contains a copy of the current {goto scope scope,} which is used when
  the plain form is called.
  Its type is the form type on the left of the colon.}

{justify
  {b Plain form calls.}
  A plain form call looks like this, where {i f} is a {goto unit} that
  transforms to a plain form {i F,} and the {i a}'s are zero or more
  {goto assignment assignments} that transform to {i F}'s arguments.
  The form and its arguments are transformed in {goto unspecified} order.}

{narrow{orson
f(a{- 1}, a{- 2} ..., a{- k})}}

{justify
  Each assignment {i a} transforms to a corresponding expression or object
  {i A,} and its type {i A}′.
  The call must have as many arguments as {i F} has parameters, so that each
  argument {i A} and its type {i A}′ corresponds to a parameter {i T}\ {i n,}
  where {i A}′ must be a {goto cotype} of {i T.}

  After all the arguments are transformed, {i F}'s {goto scope defining} scope
  is entered.
  Each parameter name {i n} is {goto bind bound} to its corresponding
  {goto cotype coerced} argument {i A}\{{i T}\} and its type, which is a
  {goto subtype} of {i T.}
  The body {i s} is then transformed to a new expression or object {i S} and
  its type {i S}′.
  If {i S} is an expression, then the parameter names in {i s} may be replaced
  in {i S} by the coerced arguments to which they were bound.
  The defining scope of {i F} is then exited, restoring the parameter names to
  their previous bindings.

  If the type {i S}′ is a cotype of the yield type {i Y,} then {i S} is coerced
  to {i S}\{{i Y}\} and its type, a subtype of {i Y.}
  The plain form call then transforms to {i S}\{{i Y}\} and its type.
  This occurs with a plain form that is intended to return an expression or
  object computed by its body.
  If {i Y} is the type {goto void {i void,}} but {i S}′ is an
  {goto object execution} type that is not a cotype of {i void,} then the plain
  form call transforms to the {goto subsequence} ({i S}\ ;\ {i skip}), whose
  type is {i void.}
  This occurs with a plain form that is intended only to perform side effects.
  It is an {goto errors error} if neither alternative is possible.}

{justify
  {b Example.}
  The following {goto withclause equate} binds the name {i abs} to a plain form
  that uses an {goto ifclause {i if}} clause to compute the absolute value of
  an {goto int integer} {i r.}
  (The standard {goto prelude} binds the name {goto {i abs}} to a more general
  version of this form.)
  The {goto withclause {i with}} clause ensures that {i r} is
  {goto evaluate evaluated} only once.}

{narrow{orson
abs :−
 (form (inj r) inj:
  (with inj a :− r
   do (if a < 0
       then − a
       else a)))}}

{justify
  In the call {i abs}({i v}), suppose that {i v} evaluates to an integer
  {goto vartype variable} of type {b var}\ {i int.}
  The variable {i v} is first coerced to the parameter type
  {goto inj {i inj,}} a {goto joker} that describes all integers.
  The result is an expression {i v}\{{i inj}\} that evaluates to the value of
  {i v,} whose type is {goto int {i int.}}
  The {goto scope defining} scope of {i abs} is then entered, and the parameter
  name {i r} is bound to this expression and its type.
  Next, the form's body is transformed to an expression that is equivalent to
  the following.}

{narrow{orson
(with int a :− {i v}\{{i inj}\}
 do (if a < 0
     then − a
     else a))}}

{justify
  When the {i with} clause in the form's body is transformed, the joker {i inj}
  in the equate is replaced by {i r}'s type {i int,} and {i r} itself is
  replaced by the coerced argument {i v}\{{i inj}\}.
  Since {i a}'s type is {i int,} the {i if} clause also has the type {i int,}
  and so does the {i with} clause.
  After the scope of {i abs} is exited, the {i with} clause is coerced to the
  yield type {i inj,} but since {i int} is already a subtype of {i inj,} this
  has no effect.
  As a result, the call transforms to an expression that is equivalent to the
  {i with} clause shown above, whose type is {i int.}

  In a real Orson program, the expressions that involve the
  {goto postbrace coercion} form {i "}␣\{\}{i ",} the {goto lt less} form
  {i "}<{i ",} and the {goto dash minus} form {i "}−{i "} would transform to
  {goto hook} calls.
  These were omitted to simplify the example.}

{justify
  {b Example.}
  The previous example showed how a form call can transform to an expression.
  A form call can also transform to an object, like an integer
  {goto constant constant.}
  This occurs in the call {i abs}(−1), which transforms to the absolute value
  of −1.

  First, −1 is coerced to the parameter type {i inj.}
  Since −1 has the type {goto int {i int}0,} which is already a subtype of
  {i inj,} this has no effect.
  The {goto scope defining} scope of {i abs} is then entered, and the parameter
  name {i r} is bound to −1 and its type {i int}0.
  Next, the form's body is transformed, substituting −1 for the parameter name
  {i r:}}

{narrow{orson
(with inj a :− −1
 do (if a < 0
     then −a
     else a))}}

{justify
  When the resulting {i with} clause is transformed, the name {i a} is bound
  to −1 and its type {i int}0.
  The {i if} clause is then transformed, producing a new {i if} clause
  ({b if}\ −1\ <\ 0\ {b then}\ −(−1)\ {b else}\ −1).
  The new {i if} clause, in turn, transforms to the constant 1, whose type is
  {i int}0.
  After the scope of {i abs} is exited, the constant 1 is coerced to the yield
  type {i inj,} but since {i int}0 is already a subtype of {i inj,} this has
  no effect.
  As a result, the call transforms to the constant 1, whose type is {i int}0.

  In a real Orson program, the expressions that involve the forms {i "}<{i "}
  and {i "}−{i "} would result in additional form calls which transform to
  constants.
  These were omitted to simplify the example.}

{label genclause}
{left {b 5.10.2.8. {i Gen} clauses.}}

{justify
  A {i gen} clause {goto transform transforms} to a {i generic form.}
  A generic form is a {goto call method} whose {goto call} transforms to an
  {goto expression} or an {goto object object,} and its {goto type type.}
  Generic forms are {goto object transformation} instances, and their types are
  transformation types.
  Each {i gen} clause looks like this.
  It consists of a {goto gentype generic} form type, followed by a
  {goto symboltoken colon,} followed in turn by an expression {i s} called the
  {i body.}}

{narrow{orson
(gen (g{- 11} n{- 11}, g{- 12} n{- 12} ..., g{- 1j{= 1}} n{- 1j{= 1}})
   gen (g{- 21} n{- 21}, g{- 22} n{- 22} ..., g{- 2j{= 2}} n{- 2j{= 2}})
     ⋮
     gen (g{- i1} n{- i1}, g{- i2} n{- i2} ..., g{- ij{= i}} n{- ij{= i}})
       form (t{- 1} m{- 1}, t{- 2} m{- 2} ..., t{- k} m{- k}) y: s)}}

{justify
  The generic form type looks like a {goto formtype plain} form type, but it
  has one or more {i generic prefixes,} each of which begins with {b gen.}
  Each generic prefix has one or more {i g}\ {i n} pairs, called
  {i generic parameters.}
  Each {i g} is a {goto term} that transforms to a {goto typetype type} type
  called a {i generic type,} and each {i n} is a {goto namepart name} called a
  {i generic name.}
  None of the generic names may be {goto missing missing.}
  There may be {goto limit limits} on the number of generic prefixes and on the
  number of generic parameters in a generic form type.

  In the plain form type that follows the generic prefixes, there are zero or
  more {i t}\ {i m} pairs, called {i parameters.}
  Each {i t} is a term that transforms to a type called a {i parameter type,}
  and each {i m} is a name called a {i parameter name.}
  Any or all of the parameter names may be missing.
  There may be a limit on the number of parameters in a generic form type.
  The term {i y} transforms to a type called the {i yield type.}

  Each generic prefix declares generic names that appear as {goto unit units}
  in the rest of the generic form type.
  The generic parameter {i g}\ {i n} declares that the generic name {i n} has
  the generic type {i g.}
  A generic name {i n} may optionally appear as a unit in one or more generic
  types of the generic prefixes following the one that declares it.
  It {goto must} appear as a unit in one or more parameter types, and it may
  optionally appear as a unit in the yield type.
  All generic names and parameter names together in a generic form type must
  be {goto distinct} from each other.

  Just as in a {goto formclause {i form}} clause, the parameters describe
  the arguments with which the generic form can be called.
  A parameter with the missing name ⬚ describes an unused argument.
  The yield type describes the expression or object to which the call
  transforms.
  However, unlike a {i form} clause, the generic parameters describe parts of
  the arguments' types, and relationships that must hold between them.}

{justify
  {b Transforming a {i gen} clause.}
  When a {i gen} clause is transformed, the type that appears on the left side
  of the colon is transformed.
  Suppose that {bi n} {goto replace abbreviates} all the generic names declared
  by the {i gen} clause.
  Then each generic type {i g} transforms to a corresponding type
  {i G}⟨{bi n}⟩, each parameter type {i t} transforms to a corresponding type
  {i T}⟨{bi n}⟩, and the yield type {i y} transforms to the type {i Y}⟨{bi n}⟩.
  The generic names abbreviated as {bi n} appear {goto freedom free} zero or
  more times in the transformed types, so they may be {goto replace replaced}
  by other types.
  The body {i s} is not transformed.
  The {i gen} clause transforms to a generic form that contains the transformed
  generic types, the generic names, the transformed parameter types, the
  parameter names, the transformed yield type, and the untransformed body.
  It also contains a copy of the current {goto scope scope,} which is used when
  the generic form is called. 
  Its type is the generic form type on the left of the colon.}

{justify
  {b Generic form calls.}
  Each generic form call looks like the following, where {i f} is a {goto unit}
  that transforms to a generic form {i F,} and the {i a}'s are zero or more
  {goto assignment assignments} that transform to {i F}'s arguments.
  The form and its arguments are transformed in {goto unspecified} order.}

{narrow{orson
f(a{- 1}, a{- 2} ..., a{- k})}}

{justify
  Each assignment {i a} transforms to an expression or object {i A,} and its
  type {i A}′.
  The call must have as many arguments as {i F} has parameters, so that each
  argument {i A} and its type {i A}′ corresponds to a parameter
  {i T}⟨{bi n}⟩\ {i m.}

  Calling a generic form is similar to calling a {goto formclause plain} form.
  However, in addition to binding its parameter names to the arguments, a
  generic form also binds its generic names to parts of the argument types.
  Binding generic names can be formally described by mechanisms similar to
  those that describe generic form {goto subtype subtypes.}
  Suppose that the generic names abbreviated as {bi n} are bound to parts of
  argument types abbreviated as {bi B.}
  Then the bindings must satisfy two criteria.}

{number
 {justify
   Suppose that {i n} is declared to have the generic type {i G}⟨{bi n}⟩ by a
   generic prefix.
   Then {i B,} the type to which {i n} is bound, must have the type
   {i G}⟨{bi B}⟩.
   In other words, each generic name must be bound to a type that is compatible
   with the way in which all other generic names are bound.}
 {justify
   Suppose that an argument {i A} corresponds to a parameter
   {i T}⟨{bi n}⟩\ {i m.}
   Then the argument's type {i A}′ must be a {goto cotype} of {i T}⟨{bi B}⟩.
   In other words, the generic names must be bound to types in a way that lets
   the argument types {goto cotype coerce} to their corresponding parameter
   types.}}

{justify
  Both criteria can be expressed by the following {goto rule statements.}
  The {b type}\ {i n}\ ⊆\ {i G}⟨{bi n}⟩ statements express the first criterion.
  The {i A}′\ ⊑\ {i T}⟨{bi n}⟩ statements express the second criterion.
  The {goto binder binders} record how generic names are bound to types that
  satisfy the criteria.}

{narrow
 {over
  {center
   {b type} {i n}{- 11} ⊆ {i G}{- 11}⟨{bi n}⟩, {b type} {i n}{- 12} ⊆ {i G}{- 12}⟨{bi n}⟩ ..., {b type} {i n}{- 1{i j}{= 1}} ⊆ {i G}{- 1{i j}{= 1}}⟨{bi n}⟩,
   {b type} {i n}{- 21} ⊆ {i G}{- 21}⟨{bi n}⟩, {b type} {i n}{- 22} ⊆ {i G}{- 22}⟨{bi n}⟩ ..., {b type} {i n}{- 2{i j}{= 2}} ⊆ {i G}{- 2{i j}{= 2}}⟨{bi n}⟩,
   \ ⋮,
   {b type} {i n}{- {i i}1} ⊆ {i G}{- {i i}1}⟨{bi n}⟩, {b type} {i n}{- {i i}2} ⊆ {i G}{- {i i}2}⟨{bi n}⟩ ..., {b type} {i n}{- {i ij{= i}}} ⊆ {i G}{-i ij{= i}}⟨{bi n}⟩,
   {i n}{- 11} ⇒ {i n}{- 11}, {i n}{- 12} ⇒ {i n}{- 12} ..., {i n}{- 1{i j}{= 1}} ⇒ {i n}{- 1{i j}{= 1}},
   {i n}{- 21} ⇒ {i n}{- 21}, {i n}{- 22} ⇒ {i n}{- 22} ..., {i n}{- 2{i j}{= 2}} ⇒ {i n}{- 2{i j}{= 2}}
   \ ⋮,
   {i n}{- {i i}1} ⇒ {i n}{- {i i}1}, {i n}{- {i i}2} ⇒ {i n}{- {i i}2} ..., {i n}{- {i ij{= i}}} ⇒ {i n}{- {i ij{= i}}} |
   {i A}′{- 1} ⊑ {i T}{- 1}⟨{bi n}⟩, {i A}′{- 2} ⊑ {i T}{- 2}⟨{bi n}⟩ ..., {i A}′{-i k} ⊑ {i T}{-i k}⟨{bi n}⟩}
  {left \ }
  {center ⋮}}}

{justify
  Now suppose that {goto rule rules} are {goto rule applied} to
  {goto rule prove} these statements.
  Also suppose that the proof ends with the following statements, in which the
  {i B}'s are parts of the argument types.}

{narrow
 {over
  {center ⋮}
  {left \ }
  {center
   {i true,}
   {i n}{- 11} ⇒ {i B}{- 11}, {i n}{- 12} ⇒ {i B}{- 12} ..., {i n}{- 1{i j}{= 1}} ⇒ {i B}{- 1{i j}{= 1}},
   {i n}{- 21} ⇒ {i B}{- 21}, {i n}{- 22} ⇒ {i B}{- 22} ..., {i n}{- 2{i j}{= 2}} ⇒ {i B}{- 2{i j}{= 2}}
   \ ⋮,
   {i n}{- {i i}1} ⇒ {i B}{- {i i}1}, {i n}{- {i i}2} ⇒ {i B}{- {i i}2} ..., {i n}{- {i ij{= i}}} ⇒ {i B}{- {i ij{= i}}} |
   {i true}}}}

{justify
  Then each binder {i n}\ ⇒\ {i B} asserts that the generic name {i n} will be
  bound to {i B,} whose type is {b type}\ {i B.}
  The appearances of {i true} indicate that the bindings satisfy the two
  criteria described previously.
  If it is not possible to construct a proof that ends with these statements,
  then the generic form call is in {goto errors error.}

  By convention, if a generic name appears free {goto genmult multiple} times
  in the parameter types, then the leftmost possible appearance of that name in
  the parameter types determines its binding.
  This convention may be changed in future versions of Orson.
  As a result, a generic form should be written so that each of its generic
  names appears exactly once in its parameter types.
  A generic name should appear more than once only if it does not matter which
  of its appearances is bound first.

  Suppose that the generic names can be bound to satisfy the criteria.
  Then {i F}'s {goto scope defining} scope is entered.
  The generic names abbreviated as {bi n} are bound to their corresponding
  types abbreviated as {bi B.}
  Each parameter name {i m} is also bound to its corresponding coerced argument
  {i A}\{{i T}⟨{bi B}⟩\}.
  Next, the generic form's body {i s} is transformed to a new expression or
  object {i S} and its type {i S}′.
  If {i S} is an expression, then the generic names in {i s} may be replaced in
  {i S} by the types to which they were bound, and the parameter names in {i s}
  may be replaced in {i S} by the coerced arguments to which they were bound.
  The defining scope of {i F} is then exited, restoring the generic names and
  the parameter names to their previous bindings.

  If the type {i S}′ is a cotype of the yield type {i Y}⟨{bi B}⟩, then {i S}
  is coerced to {i S}\{{i Y}⟨{bi B}⟩\} and its type, a subtype of
  {i Y}⟨{bi B}⟩.
  The generic form call then transforms to {i S}\{{i Y}⟨{bi B}⟩\} and its type.
  This occurs with a generic form that is intended to return an expression or
  object which is computed by its body.
  If {i Y}⟨{bi B}⟩ is the type {goto void {i void,}} but {i S}′ is an
  {goto object execution} type that is not a cotype of {i void,} then the
  generic form call transforms to a {goto subsequence} ({i S}\ ;\ {i skip}),
  whose type is {i void.}
  This occurs with a generic form that is intended only to perform side
  effects.
  It is an error if neither alternative is possible.}

{justify
  {b Example.}
  The following {goto withclause equate} binds the name {i ieia} to a generic
  form that increments the elements of an {goto int integer}
  {goto prebracket array} {goto vartype variable} {i l} by an integer {i r.}}

{narrow{orson
ieia :−
 (gen (type inj a)
   gen (type a b)
    form (var [] a l, b r) void:
     (with a Δ :− r
      do (for int i in length(l)
          do l[i] += Δ)))}}

{justify
  Inside {i ieia,} the {goto forclause {i for}} clause acts as a counting loop
  that binds the name {i i} to successive indexes of {i l.}
  The {goto withclause {i with}} clause binds the name Δ so that {i r} need not
  be repeatedly executed inside the loop.
  The assignment {i l}[{i i}]\ +=\ Δ {goto plusequal increments} the {i i}th
  {goto postbracket element} of {i l.}

  Suppose that {i v} {goto evaluate evaluates} to a variable of type
  {b var}\ [10]\ {i int,} and that {i k} evaluates to an integer of type
  {goto int {i int.}}
  Then the call {i ieia}({i v,}\ {i k}) increments the ten elements of {i v} by
  {i k.}
  The generic form call that results from the assignment binds both generic
  names {i a} and {i b} to {i int.}
  This is consistent with the generic prefixes, which assert that {i a} must be
  a subtype of the {goto joker} type {goto inj {i inj,}} and that {i b} must be
  a subtype of {i a.}
  The bindings of {i a} and {i b} can also be deduced by the following proof.}

{narrow
 {over
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i b} ⊆ {b type} {i a,} {i b} ⇒ {i b} |
   {b var} [10] {i int} ⊑ {b var} [] {i a,} {i int} ⊑ {i b}}
  {left \ {goto rule01 1}}
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i b} ⊆ {b type} {i a,} {i b} ⇒ {i b} |
   {b var} [10] {i int} ⊑ {b var} [] {i a,} {i int} ⊆ {i b}}
  {left \ {goto rule01 1}}
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i b} ⊆ {b type} {i a,} {i b} ⇒ {i b} |
   {b var} [10] {i int} ⊆ {b var} [] {i a,} {i int} ⊆ {i b}}
  {left \ {goto rule12 12}}
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i int} ⊆ {b type} {i a,} {i b} ⇒ {i int} | {b var} [10] {i int} ⊆ {b var} [] {i a}}
  {left \ {goto rule20 20}}
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i int} ⊆ {b type} {i a,} {i b} ⇒ {i int} | [10] {i int} ⊆ [] {i a}}
  {left \ {goto rule74 74}}
  {center
   {b type} {i a} ⊆ {b type} {i inj,} {i a} ⇒ {i a,} {b type} {i int} ⊆ {b type} {i a,} {i b} ⇒ {i int} | {i int} ⊆ {i a}}
  {left \ {goto rule12 12}}
  {center
   {b type} {i int} ⊆ {b type} {i inj,} {i a} ⇒ {i int,} {b type} {i int} ⊆ {b type} {i int,} {i b} ⇒ {i int} | {i true}}
  {left \ {goto rule00 0}}
  {center
   {b type} {i int} ⊆ {b type} {i inj,} {i a} ⇒ {i int,} {i b} ⇒ {i int} | {i true}}
  {left \ {goto rule19 19}}
  {center
   {i int} ⊆ {i inj,} {i a} ⇒ {i int,} {i b} ⇒ {i int} | {i true}}
  {left \ {goto rule51 51}}
  {center
   {i true,} {i a} ⇒ {i int,} {i b} ⇒ {i int} | {i true}}}}

{justify
  As expected, the binders at the end of the proof assert that both {i a} and
  {i b} are bound to {i int.}
  As a result, the argument {i v} is coerced to the parameter type
  {b var}\ []\ {i a,} which is equivalent to {b var}\ []\ {i int} because of
  {i a}'s binding.
  The argument {i k} is also coerced to the parameter type {i b,} which is
  equivalent to {i int} because of its binding.
  However, these coercions have no effect, because {i v} and {i k} already have
  the types to which they are coerced.

  The defining scope of {i ieia} is then entered.
  The parameter name {i l} is bound to the argument {i v,} and the parameter
  name {i r} is bound to the argument {i k.}
  Next, the form's body is transformed.
  The generic names {i a} and {i b} are replaced in the transformed body by
  the types to which they are bound, and the parameter names {i l} and {i r}
  are replaced by the argument to which they are bound.
  Also, the call to the form {goto {i length}} transforms to the integer
  {goto constant} 10, the number of elements in the array {i v.}
  The result of transformation is a new {i with} clause that is equivalent to
  the following.}
  
{narrow{orson
(with int Δ :− k
 do (for int i in 10
     do v[i] += Δ))}}

{justify
  When {i ieia}'s defining scope is exited, the generic names {i a} and {i b,}
  and the parameter names {i l} and {i r} are restored to their previous
  bindings.
  The transformed body shown above is also coerced to the yield type {i void.}
  However, the {i with} clause already has the type {i void,} because of the
  {i for} clause inside it, so the coercion has no effect.
  As a result, the call transforms to an expression that is equivalent to the
  one shown above, whose type is {i void.}

  In a real Orson program, the {i for} clause would transform to a {i with}
  clause that has a {goto whileclause {i while}} clause inside it.
  The assignment {i a}[{i i}]\ +=\ {i u} would also transform to an expression
  that uses {goto hook hooks.}
  These transformations were omitted to simplify the example.}

{label ifclause}
{left {b 5.10.2.9. {i If} clauses.}}

{justify
  An {i if} clause first {goto evaluate evaluates} an {goto expression} {i b}
  to an {goto int integer.}
  Depending on that integer, it then evaluates either an expression {i t} or an
  expression {i e.}
  Each {i if} clause looks like this.}

{narrow
 {left
  ({b if} {i b} {b then} {i t} {b else} {i e})}}

{justify
  {b Transforming an {i if} clause.}
  The {i if} clause is {goto transform transformed} in the following way.
  First, {i b} is transformed to a new expression or {goto object} {i B,}
  which {goto must} have an integer {goto type type.}
  If {i B} is a {goto constant constant,} then there are two possibilities.}

{number
 {justify
   Suppose that {i B} is an integer constant other than 0.
   Then {i t} is transformed to a new expression or object {i T} and its type
   {i T}′, but {i e} is not transformed.
   The {i if} clause then transforms to {i T} and {i T}′.
   The type {i T}′ may be any type.}
 {justify
   Suppose that {i B} is the integer constant 0.
   Then {i e} is transformed to a new expression or object {i E} and its type
   {i E}′, but {i t} is not transformed.
   The {i if} clause then transforms to {i E} and {i E}′.
   The type {i E}′ may be any type.}}

{justify
  If {i B} is not a constant, then {i t} is transformed to a new expression or
  object {i T} and its type {i T}′, and {i e} is also transformed to a new
  expression or object {i E} and its type {i E}′.
  Since either {i T} or {i E} might be {goto execute executed} later, both
  {i T}′ and {i E}′ must be {goto object execution} types.
  However, one or both of {i T} and {i E} might not execute to
  {goto object instances,} because they might {goto call} the forms
  {goto {i exit}} or {goto catchclause {i throw.}}
  As a result, there are now three possibilities.}

{number
 {justify
   Suppose that neither {i T} or {i E} will execute to instances.
   Then the {i if} clause transforms to 
   ({b if}\ {i B}\ {b then}\ {i T}\ {b else}\ {i E}), whose type is
   {goto void {i void.}}}
 {justify
   Suppose that only one of {i T} and {i E} will execute to an instance.
   Then the {i if} clause also transforms to
   ({b if}\ {i B}\ {b then}\ {i T}\ {b else}\ {i E}), but now its type depends
   on whether {i T} or {i E} executes to an instance.
   If {i T} will execute to an instance but {i E} will not, then the {i if}
   clause's type is {i T}′.
   If {i E} will execute to an instance but {i T} will not, then the {i if}
   clause's type is {i E}′.}
 {justify
   Suppose that both {i T} and {i E} will execute to instances.
   If {i T}′ is a {goto cotype} of {i E}′, then the {i if} clause transforms to
   ({b if}\ {i B}\ {b then}\ {i T}\{{i E}′\}\ {b else}\ {i E}), whose type is
   {i E}′.
   If {i E}′ is a cotype of {i T}′, then the {i if} clause transforms to
   ({b if}\ {i B}\ {b then}\ {i T}\ {b else}\ {i E}\{{i T}′\}), whose type is
   {i T}′.
   Otherwise, the {i if} clause transforms to
   ({b if}\ {i B}\ {b then}\ {i T}\ ;\ {i skip}\ {b else}\ {i E}\ ;\ {i skip}),
   whose type is {i void.}
   The {goto subsequence subsequences} discard the instances returned by {i T}
   and {i E,} returning {goto void {i skip}} instead.}}

{justify
  {i If} clauses of type {i void} are assumed to be executed only for their
  side effects.}

{justify
  {b Executing an {i if} clause.}
  The transformed {i if} clause
  ({b if}\ {i B}\ {b then}\ {i T}\ {b else}\ {i E}) is executed in the
  following way.
  First {i B} is executed to an integer.
  There are now two possibilities.}

{number
 {justify
   Suppose that {i B} executes to an integer other than 0.
   Then {i T} is executed, but {i E} is not.
   The instance returned by {i T} is then returned by the {i if} clause.
   If {i T} does not return an instance, then the {i if} clause does not return
   an instance either.}
 {justify
   Suppose that {i B} executes to the integer 0.
   Then {i E} is executed, but {i T} is not.
   The instance returned by {i E} is then returned by the {i if} clause.
   If {i E} does not return an instance, then the {i if} clause does not return
   an instance either.}}

{justify
  {b Abbreviations.}
  {i If} clauses may be abbreviated as shown below.
  The {b else} part of an {i if} clause can be omitted, and an {i if} clause
  that follows {b else} can be written without its surrounding parentheses.}

{table
 {row
  {center {b Abbreviated}}
  {center {b Unabbreviated}}}
 {row
  {left
   \ ({b if} {i b} {b then} {i t}){- \ }\ }
  {left
   \ ({b if} {i b} {b then} {i t} {b else} {i skip}){- \ }\ }}
 {row
  {left
   \ ({b if} {i b}{- 1}
      {b then} {i t}{- 1}
      {b else} {b if} {i b}{- 2}
               {b then} {i t}{- 2})\ }
  {left
   \ ({b if} {i b}{- 1}
      {b then} {i t}{- 1}
      {b else} ({b if} {i b}{- 2}
                {b then} {i t}{- 2}))\ }}
 {row
  {left
   \ ({b if} {i b}{- 1}
      {b then} {i t}{- 1}
      {b else} {b if} {i b}{- 2}
               {b then} {i t}{- 2}
               {b else} {i e}{- 2})\ }
  {left
   \ ({b if} {i b}{- 1}
      {b then} {i t}{- 1}
      {b else} ({b if} {i b}{- 2}
                {b then} {i t}{- 2}
                {b else} {i e}{- 2}))\ }}}

{justify
  There is no abbreviation for an {i if} clause that follows {b then,} because
  this would lead to the well-known ``dangling else'' ambiguity of the
  programming language Algol 60 {goto nau1963 {c [nau 1963].}}}
  
{label listclause}
{left {b 5.10.2.10. List clauses.}}

{justify
  If the {i e}'s are zero or more {goto assignment assignments} separated by
  {goto symboltoken commas,} then the following is a list clause.}

{narrow
 {left
  (: {i e}{- 1}, {i e}{- 2} ..., {i e}{-i k})}}

{justify
  Each list clause {goto transform transforms} to a {goto list} whose elements
  are the {goto expression expressions} and {goto object objects} that result
  from transforming the {i e}'s.
  The list clause (:) transforms to an {i empty list} with zero elements.
  There may be a {goto limit} on the number of elements in a list clause.
  A list clause is similar to the function {i list} in the programming
  languages Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}}

{label pastclause}
{left {b 5.10.2.11. {i Past} clauses.}}

{justify
  If {i n} is a {goto nametoken name,} then ({b past}\ {i n}) is a {i past}
  clause.
  It {goto must} appear in a {goto progclause {i prog}} or
  {goto withclause {i with}} clause that has an {goto withclause equate} which
  {goto bind binds} {i n.}
  The {i past} clause {goto transform transforms} to the {goto expression} or
  {goto object object,} and its {goto type type,} to which {i n} was
  {goto bind bound} in the {goto scope} immediately outside that of the
  {i prog} or {i with} clause.
  It is an {goto errors error} if {i n} is not bound in that scope.

  A {i prog} or {i with} clause that contains ({b past}\ {i n})
  {goto abbreviate abbreviates} a similar clause in which  ({b past}\ {i n}) is
  replaced by {i n,} and {i n} is replaced by a {goto unique} name {i u} that
  appears nowhere else.
  For example, the {i with} clause on the left abbreviates the one on the
  right.
  If the {goto call method} {i writeln} displays its {goto int integer}
  argument on an output device, then each {i with} clause displays first 1,
  then 2.}

{narrow
 {layout
  {row
   {orson
(with int n :− 1
 do (with int n :− 2
     do writeln((past n))
        writeln(n)))}
   {left \ \ \ \ \ \ \ \ \ \ }
   {orson
(with int n :− 1
 do (with int u :− 2
     do writeln(n)
        writeln(u)))}}}}

{justify
  The following is a more realistic example.
  The standard {goto prelude} binds the {goto quoted} name {i "}/{i "} to a
  {goto formclause plain} form that performs integer {goto slash division.}
  This equate {goto bind rebinds} {i "}/{i "} to a similar form that
  {goto catchclause throws} an {goto except exception} if division by 0
  occurs.}

{narrow{orson
inj "tried to divide by zero" :− except()

"/" :−
 (form (inj l, inj r) inj:
  (with inj r :− (past r)
   do (if r = 0
       then throw("tried to divide by zero")
       else (past "/")(l, r))))}}

{justify
  The {i with} clause and the {i past} clause ({b past}\ {i r}) ensure that the
  argument which is {goto bind bound} to the parameter {i r} will be executed
  only once.
  The {i past} clause ({b past}\ {i "}/{i "}) obtains the original form to
  which {i "}/{i "} was bound by the standard prelude.
  This form is {goto call called} when {i r} is not 0.}

{label procclause}
{left {b 5.10.2.12. {i Proc} clauses.}}

{justify
  A {i proc} clause transforms to a {i procedure.}
  A procedure is a {goto call method} whose {goto call}
  {goto evaluate evaluates} to an {goto object execution} instance.
  Procedures are execution instances, and their types are both
  {goto object transformation} and execution types.
  Each {i proc} clause looks like this.
  It consists of a {goto proctype procedure} {goto type type,} followed by a
  {goto symboltoken colon,} followed in turn by an {goto expression} {i s}
  called the {i body.}}

{narrow{orson
(proc (t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- k} n{- k}) y: s)}}

{justify
  In the procedure type, there are zero or more {i t}\ {i n} pairs called
  {i parameters.}
  Each {i t} is a {goto term} that {goto transform transforms} to an execution
  type without {goto joker jokers} called a {i parameter type,} and each {i n}
  is a {goto namepart name} called a {i parameter name.}
  Any or all of the parameter names may be {goto missing missing,} and all the
  parameter names {goto must} be {goto distinct} from each other.
  The parameters describe the arguments with which the procedure can be called.
  A parameter with a missing name ⬚ describes an unused argument.
  There may be a {goto limit} on the number of parameters in a procedure type.
  The term {i y} transforms to an execution type without jokers, but not a
  {goto vartype variable} type, called the {i yield type.}
  The yield type describes the {goto object} to which the call evaluates.}

{justify
  {b Evaluating a {i proc} clause.}
  When a {i proc} clause is evaluated, it is first transformed and then
  {goto execute executed.}
  When it is transformed, each parameter type {i t} transforms to a
  corresponding type {i T,} and the yield type transforms to the type {i Y.}
  A new {goto scope} is then entered.
  Each parameter name {i n} is {goto bind bound} to itself and its
  corresponding parameter type {i T.}
  The body {i s} is then transformed to a new expression {i S} and its type
  {i S}′.
  Since the parameter names were bound to themselves, they may appear in {i S.}
  After transformation, the new scope is exited, restoring the parameter names
  to their previous bindings.

  The procedure's body is constructed in the following way.
  If {i S}′ is a {goto cotype} of the yield type {i Y,} then the body is the
  expression {i S}\{{i Y}\}, in which {i S} is {goto cotype coerced} to {i Y.}
  This occurs in a procedure that is intended to return an execution instance
  computed by its body.
  If {i Y} is the type {goto void {i void,}} but {i S}′ is an execution type
  that is not a cotype of {i void,} then the procedure's body is the
  {goto subsequence} ({i S}\ ;\ {i skip}), whose type is {i void.}
  This occurs in a procedure that is intended only to perform side effects.
  It is an {goto errors error} if neither alternative is possible.

  Finally, a new procedure is constructed that contains the transformed
  parameter types, the parameter names, the transformed yield type, and the
  transformed body.
  It also contains a copy of the current scope, which is used when the
  procedure is called.
  Its type is the procedure type on the left of the colon.}

{justify
  {b Procedure calls.}
  Each procedure call looks like the following, where {i p} is a {goto unit}
  that evaluates to a procedure {i P,} and the {i a}'s are
  {goto assignment assignments} that evaluate to {i P}'s arguments.
  The procedure and its arguments are evaluated in {goto unspecified} order.}

{narrow{orson
p(a{- 1}, a{- 2} ..., a{- k})}}

{justify
  Each argument {i a} is evaluated to a corresponding execution instance {i A}
  and its type {i A}′.
  There must be as many arguments as {i P} has parameters, so that each
  instance {i A} and its type {i A}′ corresponds to a parameter {i T}\ {i n.}
  Each argument type {i A}′ must be a {goto cotype} of its corresponding
  parameter type {i T,} so that the instance {i A} can be {goto cotype coerced}
  to the parameter type {i T.}

  After all the arguments are evaluated, {i P}'s {goto scope defining} scope is
  entered.
  Each parameter name {i n} is then bound to its corresponding coerced argument
  instance {i A}\{{i T}\}, whose type is {i T.}
  If the parameter type {i T} is a variable type, and {i A}\{{i T}\} is a
  variable, then the parameter name {i n} is bound to {i A}\{{i T}\} itself.
  For historical reasons, the argument is said to be {i passed by reference.}
  If the parameter type {i T} is not a variable type, then the parameter name
  {i n} is bound to a copy of {i A}\{{i T}\} instead.
  For historical reasons, the argument is said to be {i passed by value.}

  After all the parameter names are bound, {i P}'s body is executed to an
  instance {i O,} whose type is the yield type {i Y.}
  The procedure {i P}'s defining scope is then exited, restoring its parameter
  names to their original bindings, and making its copied arguments
  {goto undefined undefined.}
  The call finally evaluates to {i O.}

  Suppose that a parameter name is bound to a variable, and that the variable's
  value is changed as a side effect of executing the procedure's body.
  Then the variable will retain its changed value even after the procedure call
  is executed.
  This lets a procedure use variable arguments to communicate with its caller.
  Suppose that a parameter name is bound to an instance other than a variable.
  Then the instance is copied to prevent variables that may be part of the
  instance from being unintentionally changed in this way.}

{label tupleclause}
{left {b 5.10.2.13. {i Tuple} clauses.}}

{justify
  A {i tuple} is an {goto object execution} instance that contains zero or more
  other execution instances, possibly of different {goto type types.}
  It is similar to a {i struct} in the programming language C
  {goto ker1988 {c [ker 1988].}}
  A {i tuple clause} {goto transform transforms} to the type of a tuple.
  Tuple types are both {goto object transformation} and execution types.
  Each {i tuple} clause looks like this.}

{narrow{orson
(tuple t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{-i k} n{- k})}}

{justify
  In the tuple clause, there are zero or more {i t}\ {i n} pairs called
  {i slots.}
  Each {i t} is a {goto term} that transforms to an execution type called a
  {i slot type,} and each {i n} is a {goto nametoken name} called a
  {i slot name.}
  Any or all of the slot names may be {goto missing missing,} and all the slot
  names {goto must} be {goto distinct} from each other.
  The slots describe the execution instances that are part of the tuple.
  A slot with a missing name ⬚ describes an unused instance.
  There may be a {goto limit} on the number of slots in a tuple type.

  {goto rule Rule} {b 34} describes how a tuple type can be a {goto subtype} of
  another tuple type.
  In the rule, both tuple types have the same number of slots, {i k.}
  Each slot type {i t} on the left is a subtype of its corresponding slot type
  {i T} on the right.
  Each slot name {i n} on the left is a {goto subname} of its corresponding
  slot name {i N} on the right.}

{narrow
 {label rule34}
 {over
  {center
   ({b tuple} {i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) ⊆ ({b tuple} {i T}{- 1} {i N}{- 1}, {i T}{- 2} {i N}{- 2} ..., {i T}{-i k} {i N}{-i k})}
  {left \ {b 34}}
  {center
   {i t}{- 1} ⊆ {i T}{- 1}, {i n}{- 1} ⊆ {i N}{- 1}, {i t}{- 2} ⊆ {i T}{- 2}, {i n}{- 2} ⊆ {i N}{- 2} ..., {i t}{-i k} ⊆ {i T}{-i k}, {i n}{-i k} ⊆ {i N}{-i k}}}}

{justify
  For example, the following {goto rule proof} demonstrates that the tuple type
  ({b tuple}\ {i real}\ {i re,}\ {i real}\ {i im}) is a subtype of the tuple
  type ({b tuple}\ {i real,} {i real}), whose slot names are missing.}

{narrow
 {over
  {center ({b tuple} {i real} {i re,} {i real} {i im}) ⊆ ({b tuple} {i real} ⬚, {i real} ⬚)}
  {left \ {goto rule34 34}}
  {center {i real} ⊆ {i real,} {i re} ⊆ ⬚, {i im} ⊆ ⬚}
  {left \ {goto rule03 3}}
  {center {i real} ⊆ {i real,} {i re} ⊆ ⬚}
  {left \ {goto rule03 3}}
  {center {i real} ⊆ {i real}}
  {left \ {goto rule00 0}}
  {center {i true}}}}

{justify
  In memory, a tuple's slots are stored in the same order that they appear in
  its type.
  As a result, the {goto typesize size} of a tuple type without
  {goto joker jokers} is at least the sum of the sizes of its slot types.}

{narrow{orson
size((tuple t{- 1} n{- 1}, t{- 2} n{- 2} ..., t{- k} n{- k}))\ \ ≥\ \ size(t{- 1}) + size(t{- 2}) ... + size(t{- k})}}

{justify
  The size may be greater than the sum because Orson may add invisible
  {i padding bytes} to the tuple.
  This might be done to satisfy the {goto align alignment} requirements of some
  computers.
  As a result, the size of a tuple type might vary from one implementation of
  Orson to another.}

{label whileclause}
{left {b 5.10.2.14. {i While} clauses.}}

{justify
  A {i while} clause repeatedly {goto execute executes} an {goto expression}
  {i s} zero or more times, as long as an {goto int integer} expression {i b}
  does not execute to 0.
  Each {i while} clause looks like this.}

{narrow{orson
(while b do s)}}

{justify
  The {i while} clause {goto abbreviate abbreviates} the following infinitely
  nested {goto ifclause {i if}} clauses and {goto subsequence subsequences,}
  in which {i b} is {goto transform transformed} only once, and {i s} is
  transformed at most once.
  It can be implemented in finite space using tests and jumps
  {goto pat2005 {c [pat 2005].}}}

{narrow{orson
(if b then s ; (if b then s ; (if b then s ; ... else skip) else skip) else skip)}}

{justify
  As a result of the abbreviation, if {i b} transforms to the integer
  {goto constant} 0, then {i s} is never transformed.
  Since {i s} is executed for its side effects, it {goto must} have an
  {goto object execution} {goto type type.}
  A {i while} clause either executes forever, or else returns
  {goto void {i skip.}}

  The {i while} clause ({b while}\ {i b}) is an abbreviation for
  ({b while}\ {i b}\ {b do}\ {i skip}).
  In particular, the {i while} clause ({b while}\ {i s}\ ;\ {i b}) repeatedly
  executes {i s} one or more times, until {i b} executes to 0.
  This is like the {i do} statement of the programming language C
  {goto ker1988 {c [ker 1988].}}}

{label withclause}
{left {b 5.10.2.15. {i With} clauses.}}

{justify
  A {i with} clause temporarily {goto bind binds} zero or more
  {goto nametoken names} and {goto evaluate evaluates} an {goto expression} in
  which those names appear.
  Each {i with} clause looks like this.}

{narrow{orson
(with t{- 1} n{- 1} :− e{- 1} ; t{- 2} n{- 2} :− e{- 2} ...; t{- j} n{- j} :− e{- j} do s)}}

{justify
  There are zero or more {i equates} in a {i with} clause.
  Each equate is a triple {i t}\ {i n}\ :−\ {i e,} where {i t} is a
  {goto term term,} {i n} is a name, and {i e} is an
  {goto assignment assignment.}
  All the {i n}'s in a {i with} clause {goto must} be {goto distinct} from each
  other, the {goto symbol} `:-' may appear instead of the symbol `:−', and
  there may be an extra {goto semicolon} after the last equate.
  There may also be a {goto limit} on the number of equates in a {i with}
  clause.
  The expression {i s} is called the {i with} clause's {i body.}

  Briefly, when a {i with} clause is evaluated, it first enters a new
  {goto scope} and visits its equates in order of appearance.
  When it visits an equate {i t}\ {i n}\ :−\ {i e}, the term {i t} must
  {goto transform} to a {goto type type,} and the assignment {i e} must
  evaluate to an {goto object} whose type is consistent with {i t.}
  It then binds the name {i n} to the object and its type.
  After the {i with} clause has bound all the {i n}'s, it evaluates the body
  {i s,} in which the {i n}'s may appear.
  It finally exits the new scope, restores the {i n}'s to their original
  bindings, and returns the result of evaluating {i s.}
  The rest of this section expands this brief description, describing how
  {i with} clauses are first transformed, and then {goto execute executed.}}

{justify
  {b Transforming a {i with} clause.}
  A {i with} clause is transformed in the following way.
  First, a new scope is entered, and the {i n}'s are made {goto bind unbound.}
  The {i with} clause's equates are then visited, one at a time, in order of
  their appearance.
  When an equate {i t}\ {i n}\ :−\ {i e} is visited, the term {i t} is
  transformed to a type {i T.}
  The assignment {i e} is also transformed to an expression {i E} and its type
  {i E}′.
  There are now several ways to finish transforming the equate, depending on
  {i T,} {i E,} and {i E}′.
  It is an {goto errors error} if the equate cannot be transformed in any of
  these ways.}

{justify
  {b Transforming a constant equate.}
  If {i E} is a constant, then the equate is called a {i constant equate,} and
  it is transformed in the following way.

  Suppose that {i T} is an {goto object execution} type, and that {i E}′ is a
  {goto cotype} of {i T.}
  Then {i E} is {goto cotype coerced} to a new constant {i E}\{{i T}\}, whose
  type is {i T.}
  The name {i n} is also {goto bind bound} to the new constant and its type.
  For example, the equate {i int}\ {i m}\ :−\ 1 binds the name {i m} to the
  constant 1, whose type is {goto int {i int.}}

  Suppose that {i T} is not an execution type, and that {i E}′ is a
  {goto subtype} of {i T.}
  Then {i E} is coerced to a new constant {i E}\{{i T}\}, whose type is a
  subtype of {i T.}
  The name {i n} is also bound to the new constant and its type.
  For example, the equate {i inj}\ {i m}\ :−\ 1 binds the name {i m} to the
  constant 1, whose type is {goto int {i int}0,} a subtype of the {goto joker}
  type {goto inj {i inj.}}

  After the name {i n} is bound, it transforms to the new constant and its type
  wherever it appears {goto shadow unshadowed} as a {goto unit} in the rest of
  the {i with} clause.
  The constant equate is then discarded, so it will not appear in the
  transformed {i with} clause.}

{justify
  {b Transforming a nonconstant equate.}
  If {i E} is not a constant, then the equate is called a
  {i nonconstant equate,} and it is transformed in the following way.

  Suppose that {i T} is an execution type without jokers, and that {i E}′ is a
  cotype of {i T.}
  Then {i E} is coerced to a new expression {i E}\{{i T}\} whose type is {i T,}
  and the equate transforms to a new equate {i T}\ {i n}\ :−\ {i E}\{{i T}\}.
  The name {i n} is also bound to itself and the type of the new expression.
  For example, suppose that {i v} is a {goto vartype variable} of type
  {b var}\ {i int}0.
  Then the equate {i int}\ {i m}\ :−\ {i v} transforms to a new equate that is
  equivalent to {i int}\ {i m}\ :−\ {i v}\{{i int}\}.

  Suppose that {i T} is not an execution type, or is an execution type with
  jokers, and that {i E}′ is a cotype of {i T.}
  Then {i E} is coerced to a new expression {i E}\{{i T}\} whose type is a
  subtype of {i T,} and the equate transforms to a new equate
  {i E}′\ {i n}\ :−\ {i E}\{{i T}\}.
  The name {i n} is also bound to itself and the type of the new expression.
  For example, suppose that {i v} is a variable of type {b var}\ {i int}0.
  Then the equate {i inj}\ {i m}\ :−\ {i v} transforms to a new equate that is
  equivalent to {i int}0\ {i m}\ :−\ {i v}\{{i int}0\}.

  After the name {i n} is bound, it transforms to itself and its type wherever
  it appears unshadowed as a unit in the rest of the {i with} clause.
  The new nonconstant equate is also added to the transformed {i with} clause
  so it can be executed later.}

{justify
  {b Transforming a form equate.}
  Suppose that {i E} is a form, and that {i E}′ is a subtype of {i T.}
  Also suppose that the scope established by the {i with} clause shadows the
  name {i n,} which was previously bound to another form.
  Then the equate is transformed differently than was just described.
  A new {goto altclause alternate} form is created that contains the members of
  the new form {i E,} followed by the members of the previous form.
  {goto subsume Subsumed} members of the new alternate form are removed
  without reporting errors.
  It is as if the equate is {i t}\ {i n}\ :−\ {i e}\ &\ ({b past}\ {i n}),
  where the {goto pastclause past} clause obtains the previous form, and the
  {goto ampersand operator} `&' creates the new alternate form.
  The name {i n} is then bound to the new alternate form and its type, and the
  equate is discarded.

  For example, the form {i inc} increments an {goto int integer} {i k,} either
  by {goto plus adding} 1, or by adding another integer Δ.
  It is created on the left by two {i with} clauses, and on the right by one
  {i with} clause, but the forms on both sides are equivalent.}

{narrow
 {layout
  {row
   {orson
(with
  inc :− (form (inj k) inj: k + 1)
 do (with
      inc :− (form (inj k, inj Δ) inj: k + Δ)
     do ...))}
   {left \ \ \ \ \ \ \ \ \ \ }
   {orson
(with
  inc :−
   (alt
    (form (inj k, inj Δ) inj: k + Δ),
    (form (inj k) inj: k + 1))
 do ...)}}}}

{justify
  {b Transforming a variable equate.}
  Suppose that {i T} is a variable type {b var}\ {i B} without jokers, and that
  {i E}′ is a cotype of {i B.}
  Then the nonconstant equate is also transformed differently than was just
  described.
  The expression {i E} is coerced to a new expression {i E}\{{i B}\} whose type
  is {i B,} and the equate transforms to a new equate
  {b var}\ {i B}\ {i n}\ :−\ {i E}\{{i B}\}.
  The name {i n} is then bound to itself and the type {b var}\ {i B,} and the
  new equate is added to the transformed {i with} clause so it can be executed
  later.
  When the new equate is executed, it will bind {i n} to a variable of type
  {b var}\ {i B,} whose initial value is {i E}\{{i B}\}.
  For example, the equate {b var}\ {i int}\ {i m}\ :−\ 1 transforms to an
  equate that is equivalent to {b var}\ {i int}\ {i m}\ :−\ 1\{{i int}\}, so
  {i m} will be bound to an {i int} variable whose initial value is 1.}

{justify
  {b Transforming the body.}
  After all the equates have been transformed, the {i with} clause's body {i s}
  is transformed to a new expression {i S} and its type {i S}′.
  As a result, names that appear unshadowed in {i s,} which were bound by the
  equates, may be replaced in {i S} by constants or by themselves.
  The scope that was entered at the beginning of transformation is then exited,
  so that the names bound by the equates are restored to their original
  bindings.

  Suppose that all equates from the original {i with} clause were constant
  equates, so none of them were added to the new, transformed {i with} clause.
  Then the original {i with} clause simply transforms to {i S} and its type
  {i S}′.
  The type {i S}′ may be any type.

  However, suppose that some equates from the original {i with} clause were
  nonconstant equates, so they were added to the new, transformed {i with}
  clause.
  Then the original {i with} clause transforms to the new {i with} clause,
  which will be executed later.
  The new {i with} clause contains the transformed nonconstant equates and the
  transformed body {i S.}
  Its type is {i S}′, which must be an execution type.}

{justify
  {b Executing a {i with} clause.}
  Suppose that the original {i with} clause transforms to the following new
  {i with} clause.
  The {i T}'s are execution types without jokers, the {i n}'s are distinct
  names, and the {i E}'s are expressions.}

{narrow{orson
(with T{- 1} n{- 1} :− (E{- 1}) ; T{- 2} {i n}{- 2} :− (E{- 2}) ...; T{- k} n{- k} :− (E{- k}) do S)}}

{justify
  When the transformed {i with} clause is executed, a new scope is entered, and
  its equates are executed in order of their appearance.
  Each equate {i T}\ {i n}\ :−\ ({i E}) is executed in one of two ways,
  depending on {i T.}
  If {i T} is a variable type, then {i n} is bound to a new variable of type
  {i T,} whose initial value is a copy of the execution instance returned by
  {i E.}
  If {i T} is not a variable type, then {i n} is bound directly to a copy of
  the execution instance returned by {i E} instead.

  After all the equates have been executed, the expression {i S} is executed.
  The new scope is then exited, so that the names bound by the equates are
  restored to their original bindings.
  Also, all variables and all copies of instances created by the equates become
  {goto undefined undefined.}
  The {i with} clause finally executes to the object returned by {i S,} whose
  type is {i S}′.}

{justify
  {b Abbreviations.}
  An equate can be {goto abbreviate abbreviated} in one of two ways.
  First, the equate {i n}\ :−\ {i e} abbreviates the equate
  {i obj}\ {i n}\ :−\ {i e.}
  Since the joker {goto {i obj}} describes any object, the abbreviated equate
  binds {i n} to the object or expression, and its type, that result from
  evaluating {i e.}
  This abbreviation should be used only when {i e}'s type is obvious from
  context.
  For example, the equate
  {i inc}\ :−\ ({b form}\ ({i int}\ {i k})\ {i int}:\ {i k}\ +\ 1)
  binds the name {i inc} to a {goto plain} form, whose type is
  {b form}\ ({i int}\ {i k})\ {i int.}
  Similarly, the equate π\ :−\ 3.14159 binds the name π to a
  constant whose type is {goto real {i real.}}

  Second, the equate {b var}\ {i t}\ {i n} abbreviates the equate
  {b var}\ {i t}\ {i n}\ :−\ {i x,} where the assignment {i x} evaluates to an
  {goto unspecified} instance of type {i t.}
  For example, the equate {b var}\ {i int}\ {i v} binds the name {i v} to a
  variable whose initial value is unspecified.
  This abbreviation should be used only when the variable will be initialized
  later in the {i with} clause.
  It is an error to use this abbreviation if the variable's value is a base
  {goto pointer} that will be visited by the {goto {i refs}}
  {goto forclause iterator.}}

{label hook}
{left {b 5.10.3. Hooks.}}

{justify
  A {i hook} is a {goto unit} that denotes a primitive mechanism provided by
  Orson.
  Hooks can appear in {goto prefix libraries} and {goto prelude preludes,} but
  {goto must} not appear in other {goto program programs.}
  Each hook starts with a {goto question question mark,} followed by a
  {goto plain} name that suggests its purpose.
  (Question marks are shaped like hooks.)
  
  Some hooks denote {goto object instances.}
  For example, the hook ?{i nil} denotes the {goto {i null}} pointer, and the
  hook ?{i skip} denotes the {goto {i void}} object.
  Other hooks denote {goto type types.}
  For example, the hooks ?{i int}0, ?{i int}1, and ?{i int}2 denote
  {goto int integer} types.
  Still other hooks can be {goto call called.}
  For example, the hook call ?{i intAdd}({i l,}\ {i r})
  {goto evaluate evaluates} to the {goto plus sum} of its integer arguments
  {i l} and {i r.}

  Unlike other hooks, callable hooks are not {goto object objects,} so they do
  not have types.
  It is {goto undefined} to call a hook with arguments that are different from
  those it expects.
  A callable hook might accept a varying number of arguments, it might not
  evaluate all its arguments, and it might evaluate some of its arguments more
  than once.
  As a result, {goto clause clauses} might {goto abbreviate} hook calls.
  For example, the {goto whileclause {i while}} clause
  ({b while}\ {i b}\ {b do}\ {i s})
  might abbreviate the hook call ?{i while}(({i b}),\ ({i s})).

  Each implementation of Orson may provide a different set of hooks, so that
  programs which use hooks may not be portable.
  This Report mentions hooks, but does not describe them.
  The hooks mentioned in this Report might not be provided by any
  implementation of Orson.}

{label literal}
{left {b 5.10.4. Literals.}}

{justify
  {i Literals} are {goto unit units} that {goto transform} to {goto constant}
  {goto object objects} of certain {goto type types.}
  There are four kinds of literals, called
  {goto charlit character} literals,
  {goto intlit integer} literals,
  {goto reallit real} literals, and
  {goto stringlit string} literals.
  They are described in the next few sections.}

{label charlit}
{left {b 5.10.4.1. Character literals.}}

{justify
  A {i character literal} is a {goto chartoken character} {goto token token.}
  It {goto transform transforms} to a {goto char character}
  {goto constant constant,} whose {goto type} is the smallest character type
  that describes it.
  For example, the character literal {q 'a'} transforms to a character constant
  of type {goto char {i char}0.}

  A constant of any character type can be obtained by a {goto postbrace cast.}
  For example, the {goto unit} {q 'a'}\{{i char}1\} transforms to a character
  constant of type {goto char {i char}1.}
  A character constant with a negative code can be obtained by a unit that uses
  the {goto dash minus} operator `-' or `−'.
  For example, the unit (−1)\{{i char}0\} transforms to the character of type
  {i char}0 whose code is −1.}

{label intlit}
{left {b 5.10.4.2. Integer literals.}}

{justify
  An {i integer literal} is an {goto inttoken integer} {goto token token.}
  It {goto transform transforms} to a nonnegative {goto int integer}
  {goto constant constant,} whose {goto type} is the smallest integer type that
  describes it.
  It is an {goto errors error} if no available integer type describes it.
  For example, the integer literal 100 transforms to an integer constant of
  type {goto int {i int}0.}

  An constant of any available integer type can be obtained by a
  {goto postbrace cast.}
  For example, the {goto unit} 100\{{i int}2\} transforms to an integer
  constant of type {goto int {i int}2.}
  A negative integer constant can be obtained by a {goto term} that uses the
  {goto dash minus} operator `-' or `−'.
  For example, the term −100 transforms to a negative integer constant of type
  {i int}0, and the term −100\{{i int}2\} transforms to a negative integer
  constant of type {i int}2.}

{label reallit}
{left {b 5.10.4.3. Real literals.}}

{justify
  A {i real literal} is a {goto realtoken real} {goto token token.}
  It {goto transform transforms} to a nonnegative {goto real real}
  {goto constant constant,} whose {goto type} is {goto real {i real.}}
  If the literal denotes a number which can be exactly represented as a
  {i real} constant, then it transforms to that constant.
  For example, the real literal 1.0 transforms to a real constant of type
  {i real.}
  If the literal denotes a number that cannot be exactly represented as a
  {i real} constant, but is within the range of numbers which can be
  represented in this way, then it transforms to the largest {i real} constant
  that is less than the number, or to the smallest that is greater than the
  number {goto ker1988 {c [ker 1988].}}
  It is an {goto errors error} if the literal denotes a number that is outside
  the range of numbers which can be represented as {i real} constants.

  A real of any available real type can be obtained by a {goto postbrace cast.}
  For example, the {goto unit} 1.0\{{i real}0\} transforms to a real constant
  of type {goto real {i real}0.}
  A negative real constant can be obtained by a {goto term} that uses the
  {goto dash minus} operator `-' or `−'.
  For example, the term −1.0 transforms to a negative real constant of type
  {i real,} and the term −1.0\{{i real}0\} transforms to a negative real
  constant of type {i real}0.}

{label stringlit}
{left {b 5.10.4.4. String literals.}}

{justify
  A {i string literal} is a {goto stringtoken string} {goto token token.}
  It {goto transform transforms} to a {goto string} {goto constant constant,}
  whose type is {goto string {i string.}}
  The number of characters in a string literal may be {goto limit limited} by
  the maximum number of characters on a {goto token line.}
  A string constant that is too long to fit on a line may be obtained by a
  {goto product} which {goto ampersand concatenates} two or more string
  constants using the `&' operator.}

{label nameunit}
{left {b 5.10.5. Names.}}

{justify
  A {goto unit} can be a {goto nametoken name.}
  The name can have a {goto bind binding} that determines how it is
  {goto transform transformed} and {goto execute executed.}
  A name's binding is determined by the region of the {goto program} in which
  it appears, called a {goto scope scope.}
  Scopes can be {goto nest nested} inside other scopes, and nested scopes can
  interact through {goto inherit inheritance,} {goto shadow shadowing,}
  {goto capture capture,} and {goto closure closure.}}

{label bind}
{left {b 5.10.5.1. Bindings.}}

{justify
  A {goto nametoken name} that has a binding is said to be {i bound,} and a
  name that has no binding is said to be {i unbound.}
  These terms are borrowed from the programming languages Common Lisp
  {goto ste1990 {c [ste 1990]}} and Scheme {goto spe2007 {c [spe 2007].}}
  The {goto missing} name ⬚ cannot have a binding.
  Attempting to give it a binding is not an {goto errors error,} but simply
  has no effect.}

{justify
  {b Transformation bindings.}
  During {goto transform transformation,} a name's binding has two parts.
  The first part is an {goto expression} or a {goto object transformation}
  object.
  The second part is a {goto type} that describes the expression or object.
  The name is said to be {i bound to} the expression or object, and its type.
  A bound name transforms to the expression or object, and the type, in its
  binding.
  It is an {goto errors error} to transform an unbound name.}

{justify
  {b Execution bindings.}
  During {goto execute execution,} a name's binding has only one part, an
  {goto object execution} instance.
  The name is said to be {i bound to} that instance.
  A bound name executes to the instance in its binding.
  It is impossible to execute an unbound name, because such a name would also
  have been unbound during transformation.
  When the unbound name was transformed, an error would have occurred, and
  Orson would have {goto errors recovered} from the error in a way that
  prevented the name's later execution.}

{justify
  {b Rebinding.}
  A name is said to be {i rebound} when it is given a new binding, or when it
  is made unbound.
  Names can be rebound both during transformation and during execution, and
  they can be rebound many times.

  Rebinding a name should not be confused with {goto assignment assigning} a
  value to a {goto vartype variable.}
  In most programming languages, names and variables are not clearly
  distinguished.
  In Orson, however, names are not variables.
  Instead, a name may be bound to a variable, and that variable's value may be
  changed by assignment.
  Distinguishing names from variables helps Orson do computations with
  {goto constant constants} during transformation.}

{label scope}
{left {b 5.10.5.2. Scopes.}}

{justify
  A {i scope} is a textual region of an {goto expression} in which zero or more
  {goto nameunit names} are {goto bind bound.}
  The expression is said to {i establish} the scope.
  The only expressions that can establish scopes are {goto gentype generic}
  form types, {goto formclause {i form}} clauses, {goto genclause {i gen}}
  clauses, {goto procclause {i proc}} clauses, and {goto withclause {i with}}
  clauses.
  {goto progclause {i Prog}} clauses can also establish scopes, but they are
  not expressions.

  Establishing a scope involves three steps.
  First, the scope is {i entered:} the {goto bind bindings} (or lack of
  bindings) of its names are saved, and the names are {goto bind rebound.}
  Next, a computation is performed that involves the names and their bindings.
  Finally, the scope is {i exited:} the names are rebound to their originally
  saved bindings (or lack of bindings).
  After the scope is exited, all names have the same bindings (or lack of
  bindings) that they did before the scope was entered.

  This Report sometimes also uses the word {i scope} to mean the set of all
  names and their bindings that exist at some point in a program.
  A {goto call method} is then said to record the scope in which it is created,
  called its {i defining scope.}
  It is also said to be {goto closure closed} in its defining scope.
  When the method is {goto call called,} its defining scope is entered, and
  after the call, its defining scope is exited.}

{label nest}
{left {b 5.10.5.3. Nesting.}}

{justify
  Suppose that there are two {goto expression expressions} which establish
  {goto scope scopes,} and that the second expression appears in the scope
  established by the first.
  Then the scope established by the first expression is called an {i outer}
  scope, and the scope established by the second is called an {i inner} scope.
  The inner scope is also said to be {i nested} inside the outer one.
  There may be a {goto limit} on the number of scopes can be nested in this
  way.}

{label inherit}
{left {b 5.10.5.4. Inheritance.}}

{justify
  Suppose that an {goto nest outer} {goto scope} {goto bind binds} a
  {goto nameunit name,} but an {goto nest inner} scope does not
  {goto bind rebind} the name.
  Then the name has the same {goto bind binding} in the inner scope as it did
  in the outer scope.
  The inner scope is said to {i inherit} the name and its binding from the
  outer scope.
  For example, the first {goto withclause {i with}} clause establishes an
  outer scope in which the name {i j} is {goto bind bound} to the
  {goto int integer} 1.
  The second {i with} clause establishes an inner scope that inherits {i j,}
  and that binds the name {i k} to the integer 2.}

{narrow{orson
(with int j :− 1
 do (with int k :− 2
     do writeln(j + k)))}}

{justify
  As a result, if the {goto call method} {i "}+{i "} computes the
  {goto plus sum} of two integers, and the method {i writeln} displays its
  argument on an output device, then the integer 3 will be displayed.}

{label shadow}
{left {b 5.10.5.5. Shadowing.}}

{justify
  Suppose that an {goto nest outer} {goto scope} binds a {goto nameunit name,}
  and an {goto scope inner} scope {goto bind rebinds} the same name.
  Then the {goto bind binding} of that name is not {goto inherit inherited,}
  but has the binding given to it by the inner scope.
  The inner scope is then said to {i shadow} the name.
  For example, the first {goto withclause {i with}} clause establishes an outer
  scope in which the name {i k} is bound to the {goto int integer} 1.
  The second {i with} clause then establishes an inner scope in which {i k} is
  rebound to the integer 2, so that it shadows {i k.}}

{narrow{orson
(with int k :− 1
 do writeln(k)
    (with int k :− 2
     do writeln(k))
    writeln(k))}}

{justify
  As a result, if the {goto call method} {i writeln} displays its argument on
  an output device, then 1, 2, and 1 will be displayed.}

{label capture}
{left {b 5.10.5.6. Capture.}}

{justify
  Suppose there is an {goto expression} that establishes a {goto scope} in
  which a {goto nametoken name} {i n} is {goto bind bound.}
  Also suppose that another name {i m} is {goto inherit inherited} in the same
  scope.
  For example, the expression might be a {goto withclause {i with}} clause
  ({b with}\ {b var}\ {i int}\ {i n}\ :−\ 1\ {b do}\ {i m}\ +\ {i n}) that
  returns {i m} {goto plus} 1.

  Now suppose that {i m} is bound to {i n,} so the {i with} clause
  {goto transform transforms} to a new {i with} clause which is equivalent to
  ({b with}\ {b var}\ {i int}\ {i n}\ :−\ 1\ {b do}\ {i n}\ +\ {i n}).
  Because the original {i with} clause returned {i m} plus 1, the new {i with}
  clause might be expected to return {i n} plus 1.
  However, it actually returns 2.
  This is because the {i n} that replaced {i m} during transformation is
  confused with the {i n} that appeared in the original {i with} clause.
  Something similar occurs if {i m} is bound to an expression in which {i n}
  appears as a {goto unit} but is not {goto shadow shadowed.}

  Confusing names in this way is called {i name capture.}
  Orson automatically avoids name captures in an {goto unspecified} way.
  For example, it might replace names that cause captures by new {goto unique}
  names which appear nowhere else.
  For example, in the previous {i with} clause, Orson might replace {i n} by a
  unique name {i u} before it replaces {i m} by {i n.}
  The result is a new {i with} clause
  ({b with}\ {b var}\ {i int}\ {i u}\ :−\ 1\ {b do}\ {i n}\ +\ {i u}) that
  returns {i n} plus 1, as expected.}

{label closure}
{left {b 5.10.5.7. Closure.}}

{justify
  Suppose that an {goto nest outer} {goto scope} {goto bind binds} a
  {goto nameunit name} and creates a {goto call method.}
  Also suppose that the method's body establishes an {goto nest inner} scope
  in which the name is {goto inherit inherited.}
  Then, when the method is {goto call called,} and its body is
  {goto evaluate evaluated,} the inherited name has the same binding as it did
  in the outer scope, where the method was created, even if the method is
  called in a scope that {goto shadow shadows} the name.
  This is called {i closure,} and the method is said to be {i closed.}
  These terms are borrowed from the programming languages Common Lisp
  {goto ste1990 {c [ste 1990]}} and Scheme {goto spe2007 {c [spe 2007].}}}

{justify
  {b Closed methods.}
  In the following example, a {goto withclause {i with}} clause establishes an
  outer scope in which the name {i v} is {goto bind bound} to an
  {goto int integer} {goto vartype variable} that has the value 0.
  The name {i a} is then bound to a {goto formclause form,} and the name {i b}
  is bound to a {goto procclause procedure,} both of whose scopes inherit
  {i v.}
  Finally, another {i with} clause establishes an inner scope that inherits
  {i a,} inherits {i b,} shadows {i v,} and {goto bind rebinds} {i v} to
  another integer variable whose value is 1.}

{narrow{orson
(with
  var int v :− 0
  a :− (form () int: v)
  b :− (proc () int: v)
 do (with var int v :− 1
     do writeln(a())
        writeln(b())))}}

{justify
  The form {i a} and the procedure {i b} use the binding of {i v} from the
  outer scope in which they were created.
  They do not use the binding of {i v} from the inner scope in which they are
  called.
  As a result, if the method {i writeln} displays its argument on an output
  device, then the integer 0 will be displayed twice.}

{justify
  {b Closure and execution instances.}
  Closure has possibly unexpected consequences if names bound to
  {goto object execution} instances are inherited from scopes that are later
  exited.
  This is shown by the following examples, both of which are incorrect.}

{narrow
 {layout
  {row
   {orson
(with
  a :−
   (with var int v :− 0
    do (form () int: v))
 do writeln(a()))}
   {left \ \ \ \ \ \ \ \ \ \ }
   {orson
(with
  b :−
   (with var int v :− 0
    do (proc () int: v))
 do writeln(b()))}}}}

{justify
  The example on the left is incorrect because a {i with} clause that creates
  an execution instance, like the variable {i v,} {goto must} not return a
  {goto object transformation} object, like a form.
  In the example, a call to {i a,} which occurs during transformation, would
  depend on the variable {i v,} which is not created until execution.
  Transformations can affect executions, but not the reverse.

  The example on the right is also incorrect, even though a {i with} clause
  that creates a execution instance, like the variable {i v,} can evaluate to
  another execution instance, like the procedure {i b.}
  This is because {i v} becomes {goto undefined} after the {i with} clause
  terminates, so that calling {i b} has undefined results.}

{justify
  {b Closure and transformation objects.}
  However, it is always correct to inherit names that are bound to
  {goto constant} transformation objects, even after the scopes which bound
  them are exited.
  This is shown by the following examples.}

{narrow
 {layout
  {row
   {orson
(with
  a :−
   (with int k :− 0
    do (form () int: k))
 do writeln(a()))}
   {left \ \ \ \ \ \ \ \ \ \ }
   {orson
(with
  b :−
   (with int k :− 0
    do (proc () int: k))
 do writeln(b()))}}}}

{justify
  In both examples, {i k} is bound to the integer constant 0, which is a
  transformation object.
  As a result, the left example binds {i a} to a form that is equivalent to
  ({b form}\ ()\ {i int}:\ 0).
  The right example binds {i b} to a procedure that is equivalent to
  ({b proc}\ ()\ {i int}:\ 0).
  Both examples display 0 on an output device.}

{label symbol}
{left {b 5.10.6. Symbol types.}}

{justify
  If {i n} is a {goto nametoken name,} but not the {goto missing} name ⬚, then
  the {goto unit} ${i n} {goto transform transforms} to a {i symbol type.}
  (The {goto dollar dollar sign} `$' looks like the first letter of the word
  {i symbol.})
  Unlike other {goto type types,} symbol types do not describe
  {goto object objects,} but denote names.
  For example, the form that defines the {goto dot} operator `.' uses a symbol
  type to denote the name of a slot in a {goto tupleclause tuple.}
  Symbol types are {goto object transformation} types.}

{rule}

{label program}
{left {b 6. Programs.}}

{narrow
 {left
   And I take it we might make the progs feel a bit awkward.}
 {right
  {goto mit1935 {c [mit 1935]}}}}

{justify
  A {i program} is a series of zero or more {goto loadclause {i load}} clauses
  and {goto progclause {i prog}} clauses.
  Unlike other {goto clause clauses,} {i load} and {i prog} clauses are not
  {goto unit units,} so they can appear only as parts of programs, not as parts
  of {goto expression expressions.}}

{label progclause}
{left {b 6.1. {i Prog} clauses.}}

{justify
  A {i prog} clause {goto bind binds} zero or more {goto nametoken names.}
  Each {i prog} clause looks like this.}

{narrow{orson
(prog t{- 1} n{- 1} :− e{- 1} ; t{- 2} n{- 2} :− e{- 2} ... ; t{- j} n{- j} :− e{- j})}}

{justify
  There are zero or more {i equates} in a {i prog} clause.
  Each equate is a triple {i t}\ {i n}\ :−\ {i e,} in which {i t} is a
  {goto term term,} {i n} is a name, and {i e} is an
  {goto assignment assignment.}
  All the {i n}'s in a {i prog} clause {goto must} be {goto distinct} from each
  other, the {goto symboltoken symbol} `:-' may appear instead of the symbol
  `:−', and there may be an extra {goto semicolon} after the last equate.
  There may also be a {goto limit} on the number of equates in a {i prog}
  clause.

  Suppose that each ε is a series of zero or more equates.
  Then the following series of zero or more {i prog} clauses, separated by
  semicolons, is a {goto program program.}
  There may be an extra semicolon after the last {i prog} clause.
  There may also be a limit on the number of {i prog} clauses in a program.}

{narrow
 {orson
(prog ε{- 1}) ; (prog ε{- 2}) ... ; (prog ε{- k})}}

{justify
  The program {goto abbreviate abbreviates} the following nested
  {goto withclause {i with}} clause, which returns {goto void {i skip.}}
  Because of this abbreviation, the {goto withclause equates} in a {i prog}
  clause are {goto evaluate evaluated} in the same way as those in a {i with}
  clause, and can be {goto abbreviate abbreviated} in the same way as those in
  a {i with} clause.}

{narrow
 {orson
(with ε{- 1} do (with ε{- 2} do ... (with ε{- k} do skip) ... ))}}

{justify
  Each {i prog} clause in the program establishes a new {goto scope scope.}
  The first {i prog} clause establishes an initial scope.
  Each later {i prog} clause establishes a scope that is {goto nest nested} in
  the one established by its predecessor.
  As a result, if an equate in a {i prog} clause binds a {goto plain} name or a
  {goto quoted} name in its scope, then that name can be
  {goto inherit inherited} or {goto shadow shadowed} by the scopes of later
  {i prog} clauses.}

{label progsecret}
{left {b 6.1.1. Secret objects.}}

{justify
  If a {goto plain} or {goto quoted} name appears in two or more
  {goto progclause {i prog}} clauses, then it is treated as the same
  {goto nametoken name} in each one.
  However, if a {goto secret} name appears in two or more {i prog} clauses,
  then it is treated as a different name in each one.
  This lets each {i prog} clause have its own secret names, different from
  those of other {i prog} clauses.

  Orson might implement secret names in the following way.
  Each {i prog} clause in a {goto program} is assigned a different number.
  The first might be assigned 1, the second might be assigned 2, etc.
  Whenever a secret name appears, the number of the current {i prog} clause is
  made part of that name.
  For example, when the secret name {i A} appears in {i prog} clause number 1,
  it is treated as {i A}¢1, but when it appears in {i prog} clause number 2, it
  is treated as {i A}¢2, etc.
  Here `¢' is an {goto unspecified} character that can appear only in names
  created by Orson.

  Suppose that an {goto withclause equate} in a {i prog} clause
  {goto bind binds} a secret name to an {goto object object.}
  Also suppose that no other names are bound to the object, that no
  {goto pointer pointers} reference it, that no {goto call calls} return it,
  etc.
  Then the object is accessible inside the {i prog} clause, but inaccessible
  outside it, because no other {i prog} clause can even mention its name.
  Because of {goto closure closure,} however, the object can still be accessed
  by calling {goto call methods} whose names are bound in the {goto scope} of
  the {i prog} clause, and {goto inherit inherited} by the scopes of later
  {i prog} clauses.}

{label abstract}
{left {b 6.1.2. Abstract data structures.}}

{justify
  In an {i abstract data structure,} some {goto object objects} are kept hidden
  and manipulated only by {goto call calling} trusted {goto call methods.}
  A {goto progclause {i prog}} clause can implement an abstract data structure
  by {goto bind binding} {goto progsecret secret} {goto nametoken names} to the
  hidden objects, and by binding {goto plain} or {goto quoted} names to the
  methods that manipulate them.
  For example, the following {i prog} clause implements a fixed length
  {i stack,} the classic example of an abstract data structure
  {goto knu1975 {c [knu 1975].}}}

{narrow{orson
(prog
  inj "stack is empty" :− except()
  inj "stack is full" :− except()

  !  {c Stack.} Return the type of a stack.

  stack :−
   (alt
    (form (inj n, type mut b) type tup:
     (if isInt(n)
      then (if n ≥ 0
            then (tuple
                   int Count,
                   [n] b Elements)
            else error($n, "non negative inj expression expected")
                 stack(0, b))
      else error($n, "constant expected")
           stack(0, b))),
    (form (type mut b) type tup:
     (tuple
       int Count,
       [] b Elements)))

  !  {c Elements.} An iterator that visits the elements of a stack {i s.}

  elements :−
   (gen (type mut b)
     form (stack(b) s) foj:
      (form (form (b) obj body) obj:
       (with s :− (past s)
        do (for int j in s.Count
            do (with b e :− s.Elements[j]
                do body(e))))))

  !  {c Init.} Initialize a stack {i s.}

  init :−
   (form (var stack(mut) s) void:
     s.Count := 0)

  !  {c IsEmpty.} Test if a stack {i s} has zero elements.

  isEmpty :−
   (form (stack(mut) s) bool:
     s.Count = 0)

  !  {c IsFull.} Test if a stack {i s} can hold no more elements.

  isFull :−
   (form (stack(mut) s) bool:
     s.Count = length(s.Elements))

  !  {c Peek.} Return the top element of a nonempty stack {i s.}

  peek :−
   (gen (type mut b)
     form (var stack(b) s) b:
      (if isEmpty(s)
       then throw("stack is empty")
       else s.Elements[s.Count − 1]))

  !  {c Pop.} Delete the top element of a nonempty stack {i s.}

  pop :−
   (form (var stack(mut) s) void:
    (if isEmpty(s)
     then throw("stack is empty")
     else s.Count −= 1))

  !  {c Push.} Add a new element {i n} to the top of a nonfull stack {i s.}

  push :−
   (gen (type mut b)
     gen (type b e)
      form (var stack(b) s, e n) void:
       (if isFull(s)
        then throw("stack is full")
        else s.Elements[s.Count] := n
             s.Count += 1)))}}

{justify
  Each stack is represented as a {goto tupleclause tuple} with two slots: the
  the {goto int integer} slot {i Count} holds the number of elements in the
  stack, and the {goto prebracket array} slot {i Elements} holds the elements
  themselves.
  Since these slots have {goto secret} names, they can be manipulated outside
  the {i prog} clause only by calling {goto inherit inherited} methods that
  implement stack operations.

  The plain name {i stack} is {goto bind bound} to a form whose call
  {goto transform transforms} to the {goto type} of a stack.
  Suppose that {i n} transforms to a nonnegative integer
  {goto constant constant,} and that {i t} transforms to an
  {goto object execution} type, but not a variable type.
  Then the call {i stack}({i n,}\ {i t}) transforms to the type of a stack that
  can hold at most {i n} elements of type {i t.}
  The call {i stack}({i t}) transforms to a {goto joker} type that describes
  any stack whose elements have the type {i t.}

  The plain names {i elements,} {i init,} {i isEmpty,} {i isFull,} {i peek,}
  {i pop,} and {i push} are bound to forms that implement stack operations.
  The name {goto isempty {i isEmpty}} was already bound to an
  {goto altclause alternate} form by the standard {goto prelude prelude,} but
  here it acquires an additional member that tests stacks.
  Since stack operations are implemented as forms, they work without the
  overhead of calling {goto procclause procedures.}
  Since they check if a stack is empty or full before operating on it, they
  cannot make unsafe array accesses.

  However, abstract data structures implemented in this way do not provide
  complete safety.
  For example, an {goto at enreferencer} can obtain a {goto pointer} to the
  tuple that represents a stack.
  The tuple can then be accessed unsafely through the pointer.
  Orson makes it possible to write safe programs, but does not make it
  impossible to write unsafe ones.}

{label loadclause}
{left {b 6.2. {i Load} clauses.}}

{justify
  {i Load} clauses let an Orson {goto program} reside on multiple
  {goto character files.}
  Suppose that {i p} is an {goto expression} which {goto transform transforms}
  to a portable {goto pathname pathname.}
  Then ({b load}\ {i p}) is a {i load} clause.
  It transforms to the series of {i prog} clauses on the file specified by the
  pathname {i p.}
  It is an {goto errors error} if the file does not exist, or cannot be read.
  A {i load} clause can appear anywhere that a {goto progclause {i prog}}
  clause can appear.

  When ({b load}\ {i p}) is transformed, the file specified by the pathname
  {i p} is said to be {i loaded.}
  If a file has already been loaded, or if it is now being loaded, then any
  attempt to load it again is ignored.
  As a result, a program cannot load itself, either directly or indirectly.

  For example, the following program defines a {goto procclause procedure}
  {i isBalanced} that tests if the {goto paren parentheses,}
  {goto brace braces,} and {goto bracket brackets} in a {goto string} are
  balanced.
  These {goto char characters} have the type {goto char {i char}0,} so that
  simple {goto pointer} arithmetic can traverse the string.
  The program uses a {goto abstract stack} whose {goto call methods} are
  defined in a file with the pathname {q ''stack''.}}

{narrow{orson
(load ''stack'')
(prog
  inj maxParens :− 100

!  {c IsBalanced.} Test if the parentheses in {i s} are correctly balanced.

  isBalanced :−
   (proc (string s) bool:
    (with
      var bool g :− true
      var stack(maxParens, char) p
      var string s :− (past s)

!  {c Open.} Push an open parenthesis {i o} on the stack {i p.}

      open :−
       (proc (char o) void:
        (if isFull(p)
         then g := false
         else push(p, o)))

!  {c Close.} Pop an open parenthesis {i o} off the stack {i p.}

      close :−
       (proc (char o) void:
        (if isEmpty(p)
         then g := false
         else g := (o = peek(p))
              pop(p)))

!  This is {c IsBalanced}'s body.

     do init(p)
        (while g ∧ s↑
         do (case s↑
             of '{t (}':  open('{t (}')
                '{t [}':  open('{t [}')
                '{t \{}':  open('{t \{}')
                '{t )}':  close('{t (}')
                '{t ]}':  close('{t [}')
                '{t \}}':  close('{t \{}'))
            s += 1)
        g ∧ isEmpty(p))))}}

{justify
  It is intended that most Orson programs will be implemented using high-level
  {goto abstract} objects, like stacks.
  Low-level concrete objects, like {goto prebracket arrays,}
  {goto pointer pointers,} and {goto tupleclause tuples,} will be used
  primarily to implement these abstract objects.
  Implementations of commonly used abstract objects may be loaded from a
  {goto prefix library.}
  This Report does not describe libraries.}

{label pathname}
{left {b 6.2.1. Pathnames.}}

{justify
  Most modern operating systems store files in a {i tree} 
  {goto rit1974 {c [rit 1974].}}
  The tree's internal nodes are {i directories,} and its external nodes are
  {i files.}
  Except for the directory at the root, each directory or file resides in the
  directory immediately above it in the tree.
  A {i pathname} specifies a file by tracing a linear {i path} through the
  tree.
  Operating systems notate pathnames in various ways, so
  {goto loadclause {i load}} clauses use {i portable pathnames} that are
  independent of these notations.

  A portable pathname is a {goto constant} {goto string} of zero or more names,
  separated by {goto dotchar dots.}
  Each name is a series of one or more {goto unicode Roman} letters and
  {goto digit digits,} in which {goto upper} and {goto lower} case letters are
  considered to be different.
  The first name is an optional {goto prefix} that denotes the directory at the
  root of an important subtree.
  It is followed by zero or more names that denote the directories on a path
  between the root and the specified file.
  The last name denotes the specified file itself.
  It may be followed by an optional {goto suffix} that describes the file's
  contents.
  There may be a {goto limit} on the number of characters in a portable
  pathname.}

{label prefix}
{left {b 6.2.2. Prefixes.}}

{justify
  The first name in a portable {goto pathname} may be a {i prefix} that
  specifies where the path starts in the filesystem {goto pathname tree.}
  There are three prefixes: {i lib,} {i own,} and {i top.}
  Orson may also provide other prefixes that are not described in this Report.

  If the prefix is {i lib,} then the path starts at an {goto unspecified}
  directory of library files.
  In the Unix operating system, it might be `/lib/orson' or `/usr/lib/orson'
  {goto rit1974 {c [rit 1974].}}
  For example, the pathname {q ''lib.prelude''} specifies a file named
  {i prelude} in the library directory.

  If the prefix is {i own,} then the path starts at the user's private
  directory.
  In the Unix operating system, this is `\ ~/\ '.
  For example, the pathname {q ''own.games.chess''} specifies a file {i chess}
  in a directory {i games,} which is in the user's {i own} directory.

  If the prefix is {i top,} then the path starts at the root of the entire file
  system tree.
  In the Unix operating system, this is `\ /\ '.
  For example, the pathname {q ''top.usr.local.bin.orson''} specifies a file
  {i orson} in a directory {i bin,} which is in a directory {i local,} which
  is in a directory {i usr,} which is in the root directory.

  If there is no prefix, then the path starts at the current directory.
  In the Unix operating system, this is `\ ./\ '.
  For example, the pathname {q ''stack''} specifies a file named {i stack} in
  the current directory.}

{label suffix}
{left {b 6.2.3. Suffixes.}}

{justify
  In some operating systems, a file name ends with a {i suffix} that describes
  the contents of the file.
  For example, the name of a file that contains text might end with the suffix
  {i txt.}

  A portable {goto pathname} can also optionally end in a suffix.
  The suffix is a {goto colon} followed by a series of one or more
  {goto unicode Roman} letters and {goto digit digits,} in which {goto upper}
  and {goto lower} case letters are considered to be different.
  For example, the pathname {q ''own.note:txt''} specifies a file in the
  directory {goto prefix {i own,}} whose name is {i note,} and whose suffix is
  {i txt.}

  Files might represent Orson {goto program programs} in many ways.
  A pathname's suffix might state how a file represents a program, and how it
  should be {goto loadclause loaded.}
  For example, a suffix might state that a program is represented as a series
  of {goto character characters.}
  A suffix might state that a program is represented as a series of machine
  instructions instead.
  A suffix might state that a program is a {goto prelude prelude,} or is part
  of a {goto prefix library,} so it is allowed to use {goto hook hooks.}
  A suffix might even state that a program is written in a language other than
  Orson.

  Suppose that pathnames can have several possible suffixes, and that these
  suffixes state how files should be loaded.
  Also suppose that a pathname without a suffix appears in a
  {goto loadclause {i load}} clause.
  Then, when the {i load} clause is {goto transform transformed,} Orson appends
  the first possible suffix to the end of the pathname, and tries to load the
  specified file.
  If the file does not exist, or cannot be read, then Orson does not report an
  {goto errors error,} but goes on to try the next possible suffix.
  Orson continues in this way, trying suffixes in an {goto unspecified} order,
  until it can load a file.
  It is an error if Orson cannot load a file after trying all possible
  suffixes.}

{rule}

{label prelude}
{left {b 7. Preludes.}}

{narrow
 {justify
   We were all silent, for we knew instinctively that this was only a prelude.}
 {right
  {goto sto2007 {c [sto 2007]}}}}

{justify
  A {i prelude} is a {goto progclause {i prog}} clause that Orson
  {goto loadclause loads} automatically to initialize itself, so it is
  implicitly the first {i prog} clause in every {goto program program.}
  The prelude {goto bind binds} many {goto nametoken names} to commonly used
  {goto object objects.}
  In particular, it binds the {goto quoted} names of
  {goto expression operators} to forms that implement them.

  Orson may provide many preludes.
  If it provides more than one, then it also provides an {goto unspecified} way
  to select which one is loaded.
  At least one prelude is a {i standard prelude,} a term borrowed from the
  programming language Algol 68 {goto vwi1977 {c [vwi 1977].}}
  If no prelude is selected, then Orson loads a standard prelude by default.

  The following sections describe the {goto withclause equates} that appear in
  a standard prelude.
  Most equates bind names to {goto stdtype simple} types, {goto stdjoker joker}
  types, and {goto stdform forms.}
  Within each section, equates appear in lexicographic order of the names they
  bind.
  In a real standard prelude, however, the equates appear in a different order,
  because some mention names that {goto must} be bound by earlier equates.}

{label stdtype}
{left {b 7.1. Standard simple types.}}

{justify
  The standard {goto prelude} {goto bind binds} several {goto plain} names to
  simple {goto type types.}
  Most of these types describe {goto object objects} that are commonly provided
  by computers and their operating systems.
  They include a simulated {goto bool Boolean} type,
  the {goto char character} types,
  the {goto int integer} types,
  a {goto {i list}} type,
  a {goto {i null}} pointer type,
  the {goto real} types,
  a {goto {i stream}} type,
  a {goto string} type, and
  a {goto {i void}} type.}

{label bool}
{left {b 7.1.1. {i bool,} {i false,} and {i true.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i bool,} {i false,} and {i true} like this.}

{narrow
 {layout
  {row
   {left \ }
   {left {i bool}}
   {center \ :−\ }
   {left {i int}0}}
  {row
   {left {i bool}\ }
   {left {i false}}
   {center \ :−\ }
   {left 0}}
  {row
   {left {i bool}\ }
   {left {i true}}
   {center \ :−\ }
   {left 1}}}}

{justify
  Orson does not have a Boolean {goto type type,} so it uses the
  {goto int integer} type {goto int {i int}0} to simulate one: the name
  {i bool} is bound to the same type as the name {i int}0.
  The integer 0 represents falsity, and any nonzero integer represents truth.
  As a result, the name {i false} is bound to the integer {goto constant} 0,
  and the name {i true} is bound to the integer constant 1.
  Boolean types are both {goto object transformation} and
  {goto object execution} types.
  Booleans themselves are both transformation and execution instances.}

{label char}
{left {b 7.1.2. {i char,} {i char}0, and {i char}1.}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i char,} {i char}0, and {i char}1 like this.}

{narrow
 {layout
  {row
   {left {i char}0}
   {center \ :−\ }
   {left ?{i char}0}}
  {row
   {left {i char}1}
   {center \ :−\ }
   {left ?{i char}1}}
  {row
   {left {i char}}
   {center \ :−\ }
   {left {i char}1}}}}

{justify
  The names {i char}0 and {i char}1 are bound to {goto hook hooks} that denote
  the {goto type types} of characters.
  The name {i char} is bound to the same type as the name {i char}1.
  Character types are both {goto object transformation} and
  {goto object execution} types.
  Characters themselves are both transformation and execution instances.
  Each character type describes a finite range of two's-complement
  {goto int integers} that represent character codes.
  The {goto typesize sizes} and ranges of character types appear in the
  following table.}

{table
 {row
  {center {b \ \ Type\ \ }}
  {center {b \ \ Size\ \ }}
  {center {b Range}}}
 {row
  {center {i char}0}
  {center 1 byte}
  {center −128 to 127}}
 {row
  {center {i char}1}
  {center 4 byte}
  {center \ −2147483648 to 2147483647\ }}}

{justify
  The type {i char}0 is a {goto cotype} of the type {i char}1, as in
  {goto rule} {b 35.}
  Also, both character types are cotypes of the integer type
  {goto int {i int}2,} as in rule {b 36.}}

{narrow
 {label rule35}
 {label rule36}
 {layout
  {row
   {over
    {center {i char}0 ⊑ {i T}}
    {left \ {b 35}}
    {center {i char}1 ⊑ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center {i char}0 ⊑ {i T}}
    {left \ {b 36}}
    {center {i int}2 ⊑ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center {i char}1 ⊑ {i T}}
    {left \ {b 36}}
    {center {i int}2 ⊑ {i T}}}}}}

{label int}
{left {b 7.1.3. {i int,} {i int}0, {i int}1, and {i int}2.}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names {i int,}
  {i int}0, {i int}1, and {i int}2 like this.}

{narrow
 {layout
  {row
   {left {i int}0}
   {center \ :−\ }
   {left ?{i int}0}}
  {row
   {left {i int}1}
   {center \ :−\ }
   {left ?{i int}1}}
  {row
   {left {i int}2}
   {center \ :−\ }
   {left ?{i int}2}}
  {row
   {left {i int}}
   {center \ :−\ }
   {left {i int}2}}}}

{justify
  The names {i int}0, {i int}1, and {i int}2 are bound to {goto hook hooks}
  that denote the {goto type types} of integers.
  Integer types are both {goto object transformation} and
  {goto object execution} types.
  Integers themselves are both transformation and execution instances.
  Each integer type {i intk} describes the range of two's-complement integers
  that can be represented in 2 to the power {i k} bytes, as shown in the
  following table.}

{table
 {row
  {center {b \ \ Type\ \ }}
  {center {b \ \ Size\ \ }}
  {center {b Range}}}
 {row
  {center {i int}0}
  {center 1 byte}
  {center −128 to 127}}
 {row
  {center {i int}1}
  {center 2 byte}
  {center −32768 to 32767}}
 {row
  {center {i int}2}
  {center 4 byte}
  {center −2147483648 to 2147483647}}}

{justify
  Orson may provide additional integer types that describe 8-byte integers,
  16-byte integers, 32-byte integers, etc.
  If these are provided, then the standard prelude will bind the names
  {i int}3, {i int}4, {i int}5, etc., to them, respectively.

  The standard prelude also binds the name {i int} to an {goto unspecified}
  integer type, chosen for compatibility with the computer on which Orson runs.
  It is at least as large as the type {i int}2, but may be larger.
  For example, on a computer with 32-bit registers, {i int} may be bound to the
  same type as {i int}2, but on one with 64-bit registers, {i int} may be bound
  to the same type as {i int}3.

  An integer type {i intj} is a {goto cotype} of another integer type {i intk}
  if {i j} is less than {i k,} as in {goto rule} {b 37.}
  Unlike most other programming languages, Orson does not {goto cotype coerce}
  integers to {goto real reals.}}

{narrow
 {label rule37}
 {over
  {center {i intj} ⊑ {i T}}
  {left \ {b 37}}
  {center {i intk} ⊑ {i T,} {i j} < {i k}}}}

{label list}
{left {b 7.1.4. {i list.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i list}
  like this.}

{narrow{orson
list :− ?list}}

{justify
  The name {i list} is bound to a {goto hook} that denotes the {goto type} of a
  list.
  A {i list} is an ordered, finite series of zero or more
  {goto expression expressions} and {goto object objects,} called its
  {i elements.}
  The elements need not all be of the same type.
  There may be a {goto limit} on the number of elements in a list.
  The type {i list} is a {goto object transformation} type, and lists
  themselves are transformation instances.

  Each element's type and {goto errpos position} are stored invisibly along
  with it in the list.
  An element obtained from a list has the type that was stored along with it.
  The element's position specifies the part of the program where it was
  {goto transform transformed.}
  If the element is in {goto errors error,} then its position can be used to
  report where the error occurred.

  The number of elements in a list is called its {i length.}
  The {i empty list} has no elements, so its length is 0.
  For historical reasons, the first element of a nonempty list is called its
  {goto car {i car,}} and the list of all elements except the first is called
  its {goto cdr {i cdr}} {goto ste1990 {c [ste 1990].}}
  Lists can be constructed by {goto call calling} the form
  {goto cons {i cons,}} which {goto transform transforms} to a new list with a
  specified {i car} and {i cdr.}
  Lists can also be constructed by {goto listclause list} clauses.

  Each element of a nonempty list is uniquely identified by a nonnegative
  {goto int integer} constant called its {i index,} which is less than the
  list's length.
  In a list of length {i n,} the first element has index 0, the second has
  index 1, etc.
  The {i n}th element has index {i n}\ −\ 1.
  An empty list has no elements, and therefore no indexes.

  A list of length {i n} also has {i n}\ +\ 1 {i tails.}
  The zeroth tail is the list itself.
  The first tail is the {i cdr} of the list, the second tail is the {i cdr} of
  the {i cdr,} etc.
  The {i n}th tail is the empty list.
  The element at index {i k} of a nonempty list is the {i car} of its {i k}th
  tail.}

{label null}
{left {b 7.1.5. {i null} and {i nil.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names {i nil}
  and {i null} like this.}

{narrow
 {layout
  {row
   {right {i null}}
   {center \ :−\ }
   {left ?{i null}}}
  {row
   {right {i null} {i nil}}
   {center \ :−\ }
   {left ?{i nil}}}}}

{justify
  The name {i nil} is bound to a {goto hook} that denotes a
  {goto pointer pointer.}
  It is a {goto constant constant,} it {goto pointer references} no instance,
  and it is {goto eq equal} only to itself.
  Any pointer that results from doing {goto pointer arithmetic} on {i nil} is
  {goto unspecified unspecified,} and {goto pointer dereferencing} {i nil} is
  an {goto errors error.}
  The pointer {i nil} is both a {goto object transformation} and an
  {goto object execution} instance.

  The name {i null} is bound to a hook that denotes the {goto type} of {i nil.}
  The {goto type size} of {i null} is the same as that of all other pointer
  types, and {i null} is both a transformation and an execution type.
  The type {i null} is a {goto subtype} of all other pointer types, as in
  {goto rule rules} {b 38} and {b 39.}}

{narrow
 {label rule38}
 {label rule39}
 {layout
  {row
   {over
    {center {i null} ⊆ {b ref} {i T}}
    {left \ {b 38}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i null} ⊆ {b row} {i T}}
    {left \ {b 39}}
    {center {i true}}}}}}

{justify
  The type {i null} is also a subtype of all {goto skolem Skolem} types that
  denote arbitrary subtypes of {goto {i ref}} and {goto {i row}} types, as in
  rules {b 40} and {b 41.}}

{narrow
 {label rule40}
 {label rule41}
 {layout
  {row
   {over
    {center {i null} ⊆ ə({i K,} {b ref}\ {i T})}
    {left \ {b 40}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i null} ⊆ ə({i K,} {b row}\ {i T})}
    {left \ {b 41}}
    {center {i true}}}}}}
   
{justify
  As a result of these rules, {i nil} may appear in most situations where a
  pointer is expected.
  It is often used to indicate the end of a linked chain of
  {goto tupleclause tuples.}
  However, it {goto must} not be used where a pointer with a base type is
  required, because its type {i null} has no base type.
  Also, {i nil} should not be used as a {goto string string,} even though
  {i null} is a subtype of the type {i string.}
  This is because most {goto call methods} that operate on strings expect
  pointers which reference {goto char {i char}0's.}}

{label real}
{left {b 7.1.6. {i real,} {i real}0, and {i real}1.}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i real,} {i real}0, and {i real}1 like this.}

{narrow
 {layout
  {row
   {left {i real}0}
   {center \ :−\ }
   {left ?{i real}0}}
  {row
   {left {i real}1}
   {center \ :−\ }
   {left ?{i real}1}}
  {row
   {left {i real}}
   {center \ :−\ }
   {left {i real}1}}}}

{justify
  The names {i real}0 and {i real}1 are bound to {goto hook hooks} that denote
  the {goto type types} of real numbers.
  Real types are both {goto object transformation} and {goto object execution}
  types.
  Reals themselves are both transformation and execution instances.
  Each real type describes a finite set of reals.
  The type {i real}0 describes the set provided by the 32-bit {c ieee} 754
  standard, and the type {i real}1 describes the set provided by the 64-bit
  {c ieee} 754 standard {goto iee1987 {c [iee 1987].}}
  These have the {goto typesize sizes} and ranges of absolute values shown in
  the following table.}

{table
 {row
  {center {b \ \ Type\ \ }}
  {center {b \ \ Size\ \ }}
  {center {b Absolute Range}}}
 {row
  {center {+ \ }{i real}0{+ \ }}
  {center {+ \ }4 byte{+ \ }}
  {center
    1.40239846 × 10{+ −45} to 3.40282347 × 10{+ 38}}}
 {row
  {center {+ \ }{i real}1{+ \ }}
  {center {+ \ }8 byte{+ \ }}
  {center
    \ 4.94065645841246544 × 10{+ −324} to 1.79769313486231570 × 10{+ 308}\ }}}

{justify
  Orson may also provide additional real types that describe sets of reals with
  other ranges.
  The standard prelude binds the name {i real} to an {goto unspecified} real
  type, whose range is at least that of {i real}1.

  A real type {i realj} is a {goto cotype} of another real type {i realk} if
  {i j} is less than {i k,} as in {goto rule} {b 42.}
  Unlike most other programming languages, Orson does not {goto cotype coerce}
  {goto int integers} to reals.}

{narrow
 {label rule42}
 {over
  {center {i realj} ⊑ {i T}}
  {left \ {b 42}}
  {center {i realk} ⊑ {i T,} {i j} < {i k}}}}

{label stream}
{left {b 7.1.7. {i stream} and {i eos.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i stream} and {i eos} like this.}

{narrow
 {layout
  {row
   {right {i int} {i eos}}
   {center \ :−\ }
   {left ?{i eos}()}}
  {row
   {right {i stream}}
   {center \ :−\ }
   {left ?{i stream}()}}}}

{justify
  A {i stream} is an ordered series of zero or more bytes, possibly of infinite
  length.
  The name {i stream} is bound to an {goto unspecified} {goto type} that
  describes a stream.
  Although the type {i stream} is shown in this Report as being created by a
  {goto hook hook,} it may actually be a {goto tupleclause tuple} type, a
  {goto pointer} type, etc.
  The type {i stream} is both a {goto object transformation} and an
  {goto object execution} type.
  Streams themselves are execution instances.

  The standard prelude provides no {goto call methods} that operate on streams,
  but they may be obtained by {goto loadclause loading} a {goto prefix library}
  {goto program program.}
  Typically, a stream is first {i opened} to associate it with a file.
  The stream can then be used to {i read} bytes from the file, or to {i write}
  bytes to the file.
  Each byte is represented as a nonnegative {goto int {i int.}}
  The stream is finally {i closed,} severing the association made when it was
  opened.

  The name {i eos} is bound to an unspecified negative {i int,} shown here as
  being created by a hook.
  If an attempt is made to read a byte from a stream, but no more bytes remain,
  then {i eos} is read instead.}

{label string}
{left {b 7.1.8. {i string} and ϵ.}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i string} and ϵ like this.}

{narrow
 {layout
  {row
   {right {i string}}
   {center \ :−\ }
   {left {b row} {i char}0}}
  {row
   {right {i string} ϵ}
   {center \ :−\ }
   {left {q ''''}}}}}

{justify
  The name {i string} is bound to the {goto type} of a string.
  A {i string} itself is an ordered, finite series of one or more
  {goto char {i char}1's} with nonnegative codes.
  Each string is represented as a {goto {i row}} {goto pointer} that references
  an {goto prebracket array} of one or more {goto char {i char}0's.}
  The last {i char}0 in the array is always the {goto slashed null} character,
  as in the programming language C {goto ker1988 {c [ker 1988].}}
  Unlike other {i row} pointer types, {i string} is both a
  {goto object transformation} and an {goto object execution} type.
  Strings themselves are both transformation and execution instances.
 
  Within the array referenced by the pointer, each {i char}1 is encoded as a
  series of one or more {i char}0's, as shown in the following table
  {goto uni2006 {c [uni 2006].}}
  The {i char}1's are shown in radix 16, and the {i char}0's are shown in radix
  2, where the {i x}'s denote the bits of each {i char}1, from most to least
  significant.}

{table
 {row
  {center {b {i char}1}}
  {center {b Series of {i char}0's}}}
 {row
  {center 00000000 to 0000007F}
  {left 0{i xxxxxxx}}}
 {row
  {center 00000080 to 000007FF}
  {left 110{i xxxxx} 10{i xxxxxx}}}
 {row
  {center 00000800 to 0000FFFF}
  {left 1110{i xxxx} 10{i xxxxxx} 10{i xxxxxx}}}
 {row
  {center 00010000 to 001FFFFF}
  {left 11110{i xxx} 10{i xxxxxx} 10{i xxxxxx} 10{i xxxxxx}}}
 {row
  {center 00200000 to 03FFFFFF}
  {left 111110{i xx} 10{i xxxxxx} 10{i xxxxxx} 10{i xxxxxx} 10{i xxxxxx}}}
 {row
  {center 04000000 to 7FFFFFFF}
  {left
    1111110{i x} 10{i xxxxxx} 10{i xxxxxx} 10{i xxxxxx} 10{i xxxxxx}
    10{i xxxxxx}}}}

{justify
  Each {i char}1 is encoded as the shortest possible series of {i char}0's that
  can represent it.
  The series starts with a {i char}0 whose code is greater than or equal to
  −64.
  A series that encodes an {goto unicode {c ascii}} character has one
  {i char}0, whose code is greater than or equal to 0.
  A series that encodes a non-{c ascii} character has from two to six
  {i char}0's, whose codes are less than 0.

  For example, the {goto unicode Unicode} {i char}1 {q 'Я'} has the radix 2
  code 0000010000101111, and the radix 16 code 024F.
  It is represented in a string as two {i char}0's.
  The first has the radix 2 code 11010000, and the radix 16 code D0.
  The second has the radix 2 code 10101111, and the radix 16 code AF.

  Algorithms based on simple pointer {goto pointer arithmetic} can
  {goto comp compare} strings lexicographically, can {goto count} the
  {i char}1's in a string, and can compute the {goto length} of a string.
  More complex algorithms are needed to visit the {i char}1's in a string,
  since each one may be represented as a different number of {i char}0's.

  The name ϵ is bound to an {i empty string} {goto hop2007 {c [hop 2007].}}
  An empty string contains exactly one {i char}0, the null character.
  It is lexicographically less than all nonempty strings.}

{label void}
{left {b 7.1.9. {i void} and {i skip.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names {i skip}
  and {i void} like this.}

{narrow
 {layout
  {row
   {right {i void}}
   {center \ :−\ }
   {left ?{i void}}}
  {row
   {right {i void} {i skip}}
   {center \ :−\ }
   {center ?{i skip}}}}}

{justify
  The name {i skip} is bound to a {goto hook} that denotes the lack of a useful
  {goto object object.}
  It is a {goto constant constant,} and is represented as an {goto unspecified}
  single byte.
  Nothing should be assumed about the byte that represents {i skip.}
  Orson might use many different bytes to represent it, even in a single
  program.

  The name {i void} is bound to a hook that denotes the {goto type} of
  {i skip.}
  The {goto typesize size} of {i void} is 1.
  The type {i void} is both a {goto object transformation} and an
  {goto object execution} type.
  The {i void} object {i skip} is both a transformation and an execution
  instance.

  Suppose that {goto transform transforming} an {goto expression} causes
  {goto errors errors.}
  Then Orson might {goto errors recover} from those errors by transforming the
  expression to {i skip} and its type {i void.}
  Although this recovery strategy is easy to implement, it may cause more
  errors, since the expression was probably not intended to return {i skip.}}

{label stdjoker}
{left {b 7.2. Standard joker types.}}

{justify
  The standard {goto prelude} {goto bind binds} several {goto plain} names to
  predefined {goto joker jokers,} shown in this Report as {goto hook hooks.}
  Each name is the first three {goto unicode letters} of a word that suggests
  the {goto object objects} which the joker describes.
  For example, the name of the joker that describes all
  {goto tupleclause tuples} is {goto tup {i tup.}}
  If this would conflict with another name used by Orson, then the joker's name
  ends with the letter `\ {i j}\ '.
  For example, the name of the joker that describes all {goto int integers} is
  {goto inj {i inj,}} to avoid conflict with the name {goto int {i int.}}
  Sometimes the `\ {i j}\ ' convention is used when it is not necessary, to
  suggest analogies between jokers.
  For example, the name of the joker that describes all {goto real reals} is
  {goto rej {i rej,}} by analogy with {i inj.}}

{label alj}
{left {b 7.2.1. {i alj.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i alj}
  like this.}

{narrow{orson
alj :− ?alj}}

{justify
  The {goto stdjoker joker} {i alj} describes {goto altclause alternate} forms.
  All {goto altsclause alternate} form types are {goto subtype subtypes} of
  {i alj,} as in {goto rule} {b 43.}}

{narrow
 {label rule43}
 {over
  {center ({b alts} {i t}{- 1}, {i t}{- 2} ..., {i t}{-i k}) ⊆ {i alj}}
  {left \ {b 43}}
  {center {i true}}}}

{label cha}
{left {b 7.2.2. {i cha.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i cha}
  like this.}

{narrow{orson
cha :− ?cha}}

{justify
  The {goto stdjoker joker} {i cha} describes {goto char characters.}
  All character types are {goto subtype subtypes} of {i cha,} as in {goto rule}
  {b 44.}}

{narrow
 {label rule44}
 {layout
  {row
   {over
    {center {i char}0 ⊆ {i cha}}
    {left \ {b 44}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i char}1 ⊆ {i cha}}
    {left \ {b 44}}
    {center {i true}}}}}}

{label exe}
{left {b 7.2.3. {i exe.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i exe}
  like this.}

{narrow{orson
exe :− ?exe}}

{justify
  The {goto stdjoker joker} {i exe} describes {goto object execution}
  instances.
  The {goto mut mutable} types are {goto subtype subtypes} of {i exe,} as in
  {goto rule} {b 45.}
  The {goto vartype variable} types are also subtypes of {i exe,} as in rule
  {b 46.}}

{narrow
 {label rule45}
 {label rule46}
 {layout
  {row
   {over
    {center {i t} ⊆ {i exe}}
    {left \ {b 45}}
    {center {i t} ⊆ {i mut}}}
   {left \ \ \ \ }
   {over
    {center {i t} ⊆ {i exe}}
    {left \ {b 46}}
    {center {i t} ⊆ {b var} {i mut}}}}}}

{label foj}
{left {b 7.2.4. {i foj.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i foj}
  like this.}

{narrow{orson
foj :− ?foj}}

{justify
  The {goto stdjoker joker} {i foj} describes forms.
  The {goto plj plain} form types, the {goto gej generic} form types, and the
  {goto alj alternate} form types are {goto subtype subtypes} of {i foj,} as in
  {goto rule rules} {b 47,} {b 48,} and {b 49.}}

{narrow
 {label rule47}
 {label rule48}
 {label rule49}
 {layout
  {row
   {over
    {center {i t} ⊆ {i foj}}
    {left \ {b 47}}
    {center {i t} ⊆ {i alj}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i foj}}
    {left \ {b 48}}
    {center {i t} ⊆ {i gej}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i foj}}
    {left \ {b 49}}
    {center {i t} ⊆ {i plj}}}}}}

{justify
  Rule {goto rule32 32} says that all form types are also subtypes of
  ({b alts}), the {goto altsclause alternate} form type with no member types.
  However, ({b alts}) is not a joker.}

{label gej}
{left {b 7.2.5. {i gej.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i gej}
  like this.}

{narrow{orson
gej :− ?gej}}

{justify
  The {goto stdjoker joker} {i gej} describes {goto genclause generic} forms.
  All {goto gentype generic} form types are {goto subtype subtypes} of {i gej,}
  as in {goto rule} {b 50.}}

{narrow
 {label rule50}
 {over
  {center
   {b gen} ({i g}{- 1} {i n}{- 1}, {i g}{- 2} {i n}{- 2} ..., {i g}{-i k} {i n}{-i k}) {i f} ⊆ {i gej}}
  {left \ {b 50}}
  {center
   {i true}}}}

{label inj}
{left {b 7.2.6. {i inj.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i inj}
  like this.}

{narrow{orson
inj :− ?inj}}

{justify
  The {goto stdjoker joker} {i inj} describes {goto int integers.}
  All integer types are {goto subtype subtypes} of {i inj,} as in {goto rule}
  {b 51.}}

{narrow
 {label rule51}
 {layout
  {row
   {over
    {center {i int}0 ⊆ {i inj}}
    {left \ {b 51}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i int}1 ⊆ {i inj}}
    {left \ {b 51}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i int}2 ⊆ {i inj}}
    {left \ {b 51}\ \ ...}
    {center {i true}}}}}}

{label met}
{left {b 7.2.7. {i met.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i met}
  like this.}

{narrow{orson
met :− ?met}}

{justify
  The {goto stdjoker joker} {i met} describes all {goto call methods:}
  {goto altclause alternate} forms, {goto genclause generic} forms,
  {goto formclause plain} forms, and {goto procclause procedures.}
  The form types and procedure types are {goto subtype subtypes} of {i met,} as
  in {goto rule rules} {b 52} and {b 53.}}

{narrow
 {label rule52}
 {label rule53}
 {layout
  {row
   {over
    {center {i t} ⊆ {i met}}
    {left \ {b 52}}
    {center {i t} ⊆ {i foj}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i met}}
    {left \ {b 53}}
    {center {i t} ⊆ {i pro}}}}}}

{justify
  Some {goto hook hooks} can be {goto call called} as if they are methods.
  However, they are not methods, so they are not subtypes of {i met.}}

{label mut}
{left {b 7.2.8. {i mut.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i mut}
  like this.}

{narrow{orson
mut :− ?mut}}

{justify
  The {goto stdjoker joker} {i mut} describes the {goto object execution}
  instances that can be the values of {goto vartype variables.}
  (The name {i mut} stands for {i mutable.})
  The {goto procclause procedure} types, the {goto sca scalar} types, the
  {goto str structured} types, and the {goto {i void}} type are
  {goto subtype subtypes} of {i mut,} as in {goto rule rules} {b 54,} {b 55,}
  {b 56,} and {b 57.}}

{narrow
 {label rule54}
 {label rule55}
 {label rule56}
 {label rule57}
 {layout
  {row
   {over
    {center {i t} ⊆ {i mut}}
    {left \ {b 54}}
    {center {i t} ⊆ {i pro}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i mut}}
    {left \ {b 55}}
    {center {i t} ⊆ {i sca}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i mut}}
    {left \ {b 56}}
    {center {i t} ⊆ {i str}}}
   {left \ \ \ \ \ }
   {over
    {center {i void} ⊆ {i mut}}
    {left \ {b 57}}
    {center {i true}}}}}}

{label num}
{left {b 7.2.9. {i num.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i num}
  like this.}

{narrow{orson
num :− ?num}}

{justify
  The {goto stdjoker joker} {i num} describes {goto int integers} and
  {goto real reals.}
  The integer types and real types are {goto subtype subtypes} of {i num,} as
  in {goto rule rules} {b 58} and {b 59.}}

{narrow
 {label rule58}
 {label rule59}
 {layout
  {row
   {over
    {center {i t} ⊆ {i num}}
    {left \ {b 58}}
    {center {i t} ⊆ {i inj}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i num}}
    {left \ {b 59}}
    {center {i t} ⊆ {i rej}}}}}}

{label obj}
{left {b 7.2.10. {i obj.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i obj}
  like this.}

{narrow{orson
obj :− ?obj}}

{justify
  The {goto stdjoker joker} {i obj} describes all {goto object objects.}
  Any type is a {goto subtype} of {i obj,} as in {goto rule} {b 60.}}

{narrow
 {label rule60}
 {over
  {center {i t} ⊆ {i obj}}
  {left \ {b 60}}
  {center {i true}}}}

{label plj}
{left {b 7.2.11. {i plj.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i plj}
  like this.}

{narrow{orson
plj :− ?plj}}

{justify
  The {goto stdjoker joker} {i plj} describes {goto formclause plain} forms.
  All plain form types are {goto subtype subtypes} of {i plj,} as in
  {goto rule} {b 61.}}

{narrow
 {label rule61}
 {over
  {center {b form} ({i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) {i y} ⊆ {i plj}}
  {left \ {b 61}}
  {center {i true}}}}

{label pro}
{left {b 7.2.12. {i pro.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i pro}
  like this.}

{narrow{orson
pro :− ?pro}}

{justify
  The {goto stdjoker joker} {i pro} describes {goto procclause procedures.}
  All procedure types are {goto subtype subtypes} of {i pro,} as in {goto rule}
  {b 62.}}

{narrow
 {label rule62}
 {over
  {center {b proc} ({i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) {i y} ⊆ {i pro}}
  {left \ {b 62}}
  {center {i true}}}}

{label rej}
{left {b 7.2.13. {i rej.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i rej}
  like this.}

{narrow{orson
rej :− ?rej}}

{justify
  The {goto stdjoker joker} {i rej} describes {goto real} numbers.
  All {goto real} types are {goto subtype subtypes} of {i rej,} as in
  {goto rule} {b 63.}}

{narrow
 {label rule63}
 {layout
  {row
   {over
    {center {i real}0 ⊆ {i rej}}
    {left \ {b 63}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i real}1 ⊆ {i rej}}
    {left \ {b 63}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {i real}2 ⊆ {i rej}}
    {left \ {b 63}\ \ ...}
    {center {i true}}}}}}

{label sca}
{left {b 7.2.14. {i sca.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i sca}
  like this.}

{narrow{orson
sca :− ?sca}}

{justify
  The {goto stdjoker joker} {i sca} describes scalars.
  An {goto object execution} instance is a {i scalar} if the
  {goto typesize size} of its {goto type} is a small nonnegative
  {goto constant constant,} and if it can be compared by
  {goto comparison ordering} relations.
  The {goto char character} types, the {goto num numeric} types, the
  {goto {i ref}} types, and the {goto {i row}} types are
  {goto subtype subtypes} of {i sca,} as in {goto rule rules} {b 64,} {b 65,}
  {b 66,} and {b 67.}}

{narrow
 {label rule64}
 {label rule65}
 {label rule66}
 {label rule67}
 {layout
  {row
   {over
    {center {i t} ⊆ {i sca}}
    {left \ {b 64}}
    {center {i t} ⊆ {i cha}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i sca}}
    {left \ {b 65}}
    {center {i t} ⊆ {i num}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i sca}}
    {left \ {b 66}}
    {center {i t} ⊆ {b ref} {i exe}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i sca}}
    {left \ {b 67}}
    {center {i t} ⊆ {b row} {i exe}}}}}}

{justify
  The type {goto {i null}} can be proved to be a subtype of {i sca} by rules
  {goto rule66 66} and {goto rule38 38.}
  The type {goto string {i string,}} which is equivalent to {b row}\ {i char}0,
  can be proved to be a subtype of {i sca} by rules {goto rule67 67,}
  {goto rule16 16,} {goto rule45 45,} {goto rule55 55,} {goto rule64 64,} and
  {goto rule44 44.}}

{label str}
{left {b 7.2.15. {i str.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i str}
  like this.}

{narrow{orson
str :− ?str}}

{justify
  The {goto stdjoker joker} {i str} describes structures: all
  {goto prebracket arrays} and all {goto tupleclause tuples.}
  All array and tuple types are {goto subtype subtypes} of {i str,} as in
  {goto rule rules} {b 68} and {b 69.}}

{narrow
 {label rule68}
 {label rule69}
 {layout
  {row
   {over
    {center {i t} ⊆ {i str}}
    {left \ {b 68}}
    {center {i t} ⊆ [] {i exe}}}
   {left \ \ \ \ \ }
   {over
    {center {i t} ⊆ {i str}}
    {left \ {b 69}}
    {center {i t} ⊆ {i tup}}}}}}

{label sym}
{left {b 7.2.16. {i sym.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i sym}
  like this.}

{narrow{orson
sym :− ?sym}}

{justify
  The {goto stdjoker joker} type {i sym} describes all {goto symbol} types, as
  in {goto rule} {b 70.}}

{narrow
 {label rule70}
 {over
  {center ${i n} ⊆ {i sym}}
  {left \ {b 70}}
  {center {i true}}}}

{label tup}
{left {b 7.2.17. {i tup.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i tup}
  like this.}

{narrow{orson
tup :− ?tup}}

{justify
  The {goto stdjoker joker} type {i tup} describes {goto tupleclause tuples.}
  All tuple types and {goto {i slot}} jokers are {goto subtype subtypes} of
  {i tup,} as in {goto rule rules} {b 71} and {b 72.}}

{narrow
 {label rule71}
 {label rule72}
 {layout
  {row
   {over
    {center
     ({b tuple} {i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) ⊆ {i tup}}
    {left \ {b 71}}
    {center {i true}}}
   {left \ \ \ \ \ }
   {over
    {center {- \ }{i t} ⊆ {i tup}{- \ }}
    {left \ {b 72}}
    {center {i t} ⊆ {i slot}({i exe,} {i sym})}}}}}

{label stdform}
{left {b 7.3. Standard forms.}}

{justify
  The standard {goto prelude} {goto bind binds} various {goto nametoken names}
  to commonly used forms.
  Many are the {goto quoted} names of {goto expression operators.}
  In this Report, the bodies of most such forms are {goto hook} calls.
  If the body of a form is an {goto expression} other than a hook call, then
  the expression is intended to show how the form behaves, but not necessarily
  how it should be implemented.}

{justify
  {b Arithmetic conventions.}
  Unless otherwise specified, forms defined by the standard prelude obey the
  following conventions about {goto int integer} and {goto real} arithmetic.

  Suppose that the arguments in a form {goto call} all have integer
  {goto type types,} or all have real types.
  Then the arguments are {goto cotype coerced} to the largest of those types.
  For example, in the {goto sum} {i l}\ +\ {i r,} if {i l} has the type
  {goto int {i int}0} and {i r} has the type {goto int {i int}1,} then {i l} is
  coerced to {i int}1.

  Suppose that a form call performs an arithmetic operation, and that all its
  arguments have the same integer type or real type (possibly because of
  coercion).
  Also suppose that the call {goto transform transforms} to an expression which
  is not a {goto constant constant.}
  Then the expression has the same type as its arguments.

  If an integer operation overflows or underflows during transformation or
  {goto execute execution,} then the result is computed according to the rules
  for two's-complement arithmetic.
  For example, if {i v} is an {goto int {i int}2} {goto vartype variable} whose
  value is −2147483648, then the {goto term} −\ {i v} {goto evaluate evaluates}
  to −2147483648.

  If a real operation overflows or underflows during transformation, then the
  result is an {goto unspecified} real constant.
  If a real operation overflows or underflows during execution, then the result
  is {goto undefined undefined.}}

{justify
  {b Constant conventions.}
  Unless otherwise specified, forms defined by the standard prelude obey the
  following conventions about constants.

  Suppose that all the arguments in a form call transform to
  {goto char character} constants, integer constants, real constants,
  {goto string} constants, types, or to a mixture of these.
  Then the call also transforms to a constant.
  A form call might also transform to a constant even though all its arguments
  do not.
  For example, suppose that one of the arguments in the {goto product}
  {i l}\ ×\ {i r} transforms to the integer constant 0 but the other does not.
  Then {i l}\ ×\ {i r} itself might transform to the integer constant 0.
  If this occurs, then neither argument will be executed.

  Suppose that a form call transforms to a character constant, an integer
  constant, or a real constant.
  Then the constant has the same type as if it had appeared as a
  {goto literal literal.}
  For example, the {goto intlit integer} literals 1000000 and 999999 both have
  the type {goto int {i int}2,} but their {goto dash difference}
  1000000\ −\ 999999 transforms to the constant 1, which has the type
  {i int}0.}

{justify
  {b Name conventions.}
  Some forms defined by the standard prelude have two names.
  For example, the form that {goto star multiplies} integers or reals has the
  quoted names {i "}⁎{i "} and {i "}×{i ".}
  This allows writing the product {i l}\ ⁎\ {i r} on computers that support
  only the {goto unicode {c ascii}} character set, and the product
  {i l}\ ×\ {i r} on computers that support the larger {goto unicode Unicode}
  character set.
  However, there is no explicit connection between these names, so that
  {goto bind rebinding} {i "}⁎{i "} does not affect {i "}×{i ",} or vice-versa.

  Some forms have related names.
  For example, the form that {goto plus adds} integers or reals has the quoted
  name {i "}+{i ",} and the form that {goto plusequal increments} an integer or
  real variable has the quoted name {i "}+={i ".}
  There is no explicit connection between these names either, so that rebinding
  {i "}+{i "} does not affect {i "}+={i ",} or vice-versa.

  Some forms are said to be defined in terms of the {goto bind bindings} of
  certain names.
  For example, the form {goto ischar {i isChar}} is said to return a
  {goto bool Boolean} constant, either {goto bool {i true}} or
  {goto bool {i false.}}
  There is also no explicit connection between the form and the names, so that
  rebinding {goto bool {i bool,}} {i true} or {i false} does not affect
  {i isChar.}}

{label postbracket}
{left {b 7.3.1. {i "}␣[]{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}␣[]{i "} like this.}

{narrow{orson
"␣[]" :−
 (alt
  (gen (type mut lBase)
    form (var [] lBase l, inj r) var lBase:
     ?varArrElem(l, r)),
  (gen (type exe lBase)
    form ([] lBase l, inj r) lBase:
     ?arrElem(l, r)),
  (gen (type exe lBase)
    form (row lBase l, inj r) lBase:
     ?rowElem(l, r)),
  (form (list l, inj r) obj:
    ?listElem(l, r)),
  (form (list l, inj b, inj e) list:
    ?listElems(l, b, e)))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to an {goto prebracket array}
  {goto vartype variable} of {goto type} {b var}\ [{i k}]\ {i t,} where {i t}
  is not a variable type.
  Also suppose that {i r} evaluates to an {goto int integer.}
  Then the {goto unit} {i l}[{i r}] evaluates to the element of {i l} at the
  index {i r,} whose type is {b var}\ {i t.}
  In other words, the element is treated as if it is a variable.
  It is an {goto errors error} if {i l} has no element with index {i r.}

  Suppose that {i l} evaluates to an array of type [{i k}]\ {i t,} where {i t}
  may or may not be a variable type.
  Then {i l}[{i r}] evaluates to the element of {i l} at index {i r,} whose
  type is {i t.}
  It is an error if {i l} has no element with index {i r.}

  Suppose that {i l} evaluates to a {goto {i row}} pointer whose base type is
  {i t,} and that it {goto pointer references} an element at index {i j} of an
  array.
  Also suppose that {i r} evaluates to an integer.
  Then {i l}[{i r}] evaluates to the element of the array at index
  {i j}\ +\ {i r,} whose type is {i t.}
  This lets a {i row} pointer simulate an array whose {goto length} is unknown.
  It is {goto undefined} if the array has no element with index
  {i j}\ +\ {i r.}
  Contrary to {goto stdform convention,} if {i l} {goto transform transforms}
  to a {goto string} {goto constant constant,} and {i r} transforms to an
  integer constant, then {i l}[{i r}] does not transform to a
  {goto char character} constant.

  Suppose that {i l} transforms to a {goto list list,} and that {i r}
  transforms to an integer constant.
  Then {i l}[{i r}] transforms to the element of {i l} at index {i r} and its
  type.
  It is an error if {i r} does not transform to a constant, or if {i l} has no
  element with index {i r.}

  Suppose that {i l} transforms to a list, and that both {i b} and {i e}
  transform to integer constants.
  Then the unit {i l}[{i b,}\ {i e}] transforms to a list of length
  {i e}\ −\ {i b} that starts with the element at index {i b} of {i l,} and
  ends with the element at index {i e}\ −\ 1 of {i l.}
  It is an error if {i b} and {i e} do not both transform to constants, if
  {i b} and {i e} do not both transform to indexes of {i l,} or if {i b} is
  greater than {i e.}
  This is the convention used for indexes in the programming language Common
  Lisp {goto ste1990 {c [ste 1990].}}}

{label postbrace}
{left {b 7.3.2. {i "}␣\{\}{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}␣\{\}{i "} like this.}

{narrow{orson
"␣\{\}" :−
 (alt
  (form (inj l, type cha rType) cha:
    ?intCast(l, rType)),
  (form (cha l, type inj rType) inj:
    ?charCast(l, rType)),
  (form (inj l, type num rType) num:
    ?intCast(l, rType)),
  (form (row exe l, type ref exe rType) ref exe:
    ?rowCast(l, rType)),
  (form (row exe l, type row exe rType) row exe:
    ?rowCast(l, rType)),
  (form (rej l, type num rType) num:
    ?realCast(l, rType)),
  (gen (type obj rType)
    gen (type rType lType)
     form (lType l, type rType) rType:
      l))}}

{justify
  The {goto altclause alternate} form {i "}␣\{\}{i "} implements {i casts.}
  Suppose that {i r} {goto transform transforms} to a {goto type type.}
  Then the {goto unit} {i l}\{{i r}\} {goto evaluate evaluates} to an
  {goto object} that is like {i l,} but of the type {i r.}
  The unit {i l} is said to be {i cast} to the type {i r.}

  Casts are similar to {goto cotype coercions.}
  However, casts are performed explicitly by a program, and coercions are
  performed implicitly by Orson.
  New casts can be defined by {goto bind rebinding} {i "}␣\{\}{i ",} but new
  coercions cannot be defined.
  All coercions can be performed by casts, so that if {i l}
  {goto cotype coerces} to the type {i r,} then {i l} can also be cast to the
  type {i r.}
  However, potentially unsafe {goto pointer} casts cannot be performed by
  coercions, so they cannot occur unless they are intended.

  Suppose that {i l} evaluates to an {goto int integer,} and that {i r}
  transforms to a {goto char character} type.
  Then {i l}\{{i r}\} evaluates to the character with the code {i l,} of type
  {i r.}
  If this is not possible, then {i l}\{{i r}\} evaluates to an
  {goto unspecified} character of type {i r.}
  It is an {goto errors error} if {i r} is a {goto joker joker.}

  Suppose that {i l} evaluates to a character, and that {i r} transforms to an
  integer type.
  Then {i l}\{{i r}\} evaluates to the code for {i l,} represented as an
  integer of type {i r.}
  If this is not possible, then {i l}\{{i r}\} evaluates to an unspecified
  integer of type {i r.}
  It is an error if {i r} is a joker.

  Suppose that {i l} evaluates to an integer, and that {i r} transforms to an
  integer type.
  Then {i l}\{{i r}\} evaluates to {i l,} represented as an integer of type
  {i r.}
  If this is not possible, then {i l}\{{i r}\} evaluates to an unspecified
  integer of type {i r.}
  It is an error if {i r} is a joker.

  Suppose that {i l} evaluates to a {goto real real,} and that {i r} transforms
  to an integer type.
  Then {i l}\{{i r}\} evaluates to the integer of type {i r} that results from
  discarding {i l}'s fractional part.
  If this is not possible, then {i l}\{{i r}\} evaluates to an unspecified
  integer of type {i r.}
  It is an error if {i r} is a joker.

  Suppose that {i l} evaluates to an integer or a real, and that {i r}
  transforms to a real type.
  Then {i l}\{{i r}\} evaluates to the result of converting {i l} to a real of
  type {i r.}
  If {i l} can be exactly represented as a real of type {i r,} then it is
  converted to that real.
  If {i l} cannot be exactly represented as a real of type {i r,} but is in the
  range of reals that can be represented in this way, then it is converted to
  the largest real of type {i r} which is less than {i l,} or to the smallest
  which is greater than {i l.}
  If {i l} is outside the range of reals that can be represented by the type
  {i r,} then it is converted to an unspecified real of type {i r}
  {goto ker1988 {c [ker 1988].}}
  It is an error if {i r} is a joker.

  Suppose that {i l} evaluates to a {goto {i ref}} or {goto {i row}} pointer,
  and that {i r} transforms to a {i ref} or {i row} pointer type.
  Then {i l}\{{i r}\} evaluates to the pointer {i l,} but of type {i r.}
  It is an error if {i r} contains jokers as parts.

  Suppose that {i r} transforms to a type, and that {i l}'s type is a
  {goto cotype} of {i r.}
  Then {i l}\{{i r}\} evaluates to the result of coercing {i l} so its type is
  a {goto subtype} of {i r.}
  For example, if {i v} is a {goto vartype variable} of type {b var}\ {i int,}
  then {i v}\{{i inj}\} evaluates to the {goto int {i int}} value of {i v,}
  whose type is a subtype of the joker {goto inj {i inj.}}}

{label ampersand}
{left {b 7.3.3. {i "}&{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}&{i "} like this.}

{narrow{orson
"&" :−
 (alt
  (form (char l, string r) string:
    ?strPre(l, r)),
  (form (inj l, inj r) inj:
    ?intAnd(l, r)),
  (form (foj l, foj r) foj:
    ?formConc(l, r)),
  (form (string l, char r) string:
    ?strPost(l, r)),
  (form (string l, string r) string:
    ?strConc(l, r)),
  (form (type foj l, type foj r) type foj:
    ?typeAlts(l, r)),
  (form (type tup l, type tup r) type tup:
    ?typeConc(l, r)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Then the {goto product} {i l}\ &\ {i r} evaluates to the integer bitwise
  {c and} of {i l} and {i r.}

  Suppose that {i l} and {i r} both {goto transform} to forms.
  Then {i l}\ &\ {i r} transforms to a new {goto altclause alternate} form
  ({b alt}\ {i l,}\ {i r}).
  If any member forms in the new alternate form are {goto subsume subsumed,}
  then they are deleted without reporting {goto errors errors.}

  Suppose that {i l} and {i r} both transform to form {goto type types.}
  Then {i l}\ &\ {i r} transforms to a new {goto altsclause alternate} form
  type ({b alts}\ {i l,}\ {i r}).
  If any member types in the new alternate form type are subsumed, then they
  are deleted without reporting errors.
  It is an error if {i l} or {i r} is a {goto joker} type or a
  {goto skolem Skolem} type.
  However, {i l} and {i r} can have joker types and Skolem types as parts.

  Suppose that {i l} transforms to a {goto char character}
  {goto constant constant,} and that {i r} transforms to a {goto string}
  constant.
  Then {i l}\ &\ {i r} transforms to a string constant in which {i l} is
  concatenated to the left end of {i r.}
  It is an error if {i l} and {i r} do not both transform to constants.

  Suppose that {i l} transforms to a string constant, and that {i r} transforms
  to a character constant.
  Then {i l}\ &\ {i r} transforms to a string constant in which {i r} is
  concatenated to the right end of {i l.}
  It is an error if {i l} and {i r} do not both transform to constants.

  Suppose that {i l} and {i r} both transform to string constants.
  Then {i l}\ &\ {i r} transforms to a string constant in which {i r} is
  concatenated to the right end of {i l.}
  It is an error if {i l} and {i r} do not both transform to constants.

  Suppose that {i l} and {i r} both transform to {goto tupleclause tuple}
  types.
  Then {i l}\ &\ {i r} transforms to a tuple type that contains the slots of
  {i l,} followed by the slots of {i r.}
  It is an error if {i l}\ &\ {i r} would transform to a tuple type whose slot
  names are not all {goto distinct} from each other.}

{label ampequal}
{left {b 7.3.4. {i "}&={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}&={i "} like this.}

{narrow{orson
"&=" :−
 (gen (type inj lBase)
   gen (type lBase rType)
    form (var lBase l, rType r) void:
     ?intAndSet(l, r))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment} {i l}\ &=\ {i r} sets the value of {i l} to the
  integer bitwise {goto ampersand {c and}} of {i l} and {i r.}
  It evaluates to {goto void {i skip.}}}

{label star}
{left {b 7.3.5. {i "}⁎{i "} and {i "}×{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}⁎{i "} and {i "}×{i "} like this.}

{narrow{orson
"⁎" :−
 (alt
  (form (inj l, inj r) inj:
    ?intMul(l, r)),
  (form (rej l, rej r) rej:
    ?realMul(l, r)))

"×" :− "⁎"}}

{justify
  If {i l} and {i r} both {goto evaluate} to {goto int integers,} then the
  {goto product products} {i l}\ ⁎\ {i r} and {i l}\ ×\ {i r} evaluate to the
  integer that results from multiplying {i l} and {i r.}
  If {i l} and {i r} both evaluate to {goto real reals,} then {i l}\ ⁎\ {i r}
  and {i l}\ ×\ {i r} evaluate to the real that results from multiplying {i l}
  and {i r.}}

{label starequal}
{left {b 7.3.6. {i "}⁎={i "} and {i "}×={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}⁎={i "} and {i "}×={i "} like this.}

{narrow{orson
"⁎=" :−
 (alt
  (gen (type inj lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?intMulSet(l, r)),
  (gen (type rej lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?realMulSet(l, r)))

"×=" :− "⁎="}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment assignments} {i l}\ ⁎=\ {i r} and {i l}\ ×=\ {i r}
  set the value of {i l} to the integer that results from
  {goto star multiplying} {i l} and {i r.}
  They both evaluate to {goto void {i skip.}}

  Suppose that {i l} evaluates to a variable of type {b var}\ {i t,} where
  {i t} is a {goto real} type.
  Also suppose that {i r} evaluates to a real of type {i t.}
  Then {i l}\ ⁎=\ {i r} and {i l}\ ×=\ {i r} set the value of {i l} to the real
  that results from multiplying {i l} and {i r.}
  They both evaluate to {i skip.}}

{label plus}
{left {b 7.3.7. {i "}+{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}+{i "} like this.}

{narrow{orson
"+" :−
 (alt
  (gen (type num rType)
    form (rType r) rType:
     r),
  (form (inj l, inj r) inj:
    ?intAdd(l, r)),
  (form (rej l, rej r) rej:
    ?realAdd(l, r)),
  (gen (type exe lBase)
    form (row lBase l, inj r) row lBase:
     ?rowAdd(l, r)))}}

{justify
  If {i r} has an {goto int integer} or {goto real} {goto type type,} then the
  {goto term} +\ {i r} {goto transform transforms} to {i r.}
  If {i l} and {i r} both {goto evaluate} to integers, then the {goto sum}
  {i l}\ +\ {i r} evaluates to the integer that results from adding {i l} and
  {i r.}
  If {i l} and {i r} both evaluate to reals, then {i l}\ +\ {i r} evaluates to
  the real that results from adding {i l} and {i r.}}

{justify
  {b Pointer arithmetic.}
  Suppose that {i l} evaluates to a {goto {i row}} pointer whose base type is
  {i t.}
  Also suppose that {i r} evaluates to an integer.
  Then {i l}\ +\ {i r} performs {goto pointer} arithmetic.
  First {i l} is converted to a nonnegative integer, then {i r} times the
  {goto typesize size} of {i t} is added to it.
  The result is converted to a pointer of type {b row}\ {i t} and returned.

  For example, suppose there is an {goto prebracket array} whose base type is
  {i t.}
  Also suppose that {i l} is a pointer whose base type is {i t,} and that it
  references an element of the array at index {i k.}
  Then {i l}\ +\ {i r} evaluates to a pointer of type {b row}\ {i t} that
  references an element of the array at index {i k}\ +\ {i r.}
  If the element does not exist, then {i l}\ +\ {i r} evaluates to an
  {goto unspecified} pointer of type {b row}\ {i t.}
  Contrary to {goto stdform convention,} if {i l} transforms to a {goto string}
  {goto constant} and {i r} transforms to an integer constant, then
  {i l}\ +\ {i r} does not transform to a string constant.}

{label plusequal}
{left {b 7.3.8. {i "}+={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}+={i "} like this.}

{narrow{orson
"+=" :−
 (alt
  (gen (type inj lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?intAddSet(l, r)),
  (gen (type rej lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?realAddSet(l, r)),
  (form (var row exe l, inj r) void:
    ?rowAddSet(l, r)))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment} {i l}\ +=\ {i r} sets the value of {i l} to the
  integer that results from {goto plus adding} {i l} and {i r.}
  It evaluates to {goto void {i skip.}}

  Suppose that {i l} evaluates to a variable of type {b var}\ {i t,} where
  {i t} is a {goto real} type.
  Also suppose that {i r} evaluates to a real of type {i t.}
  Then {i l}\ +=\ {i r} sets the value of {i l} to the real that results from
  adding {i l} and {i r.}
  It evaluates to {i skip.}

  Suppose that {i l} evaluates to a variable whose base type is a
  {goto {i row}} pointer, and that {i r} evaluates to an integer.
  Then {i l}\ +=\ {i r} sets the value of {i l} to the {i row} pointer that
  results from adding {i l} and {i r.}
  It evaluates to {i skip.}}

{label dash}
{left {b 7.3.9. {i "}-{i "} and {i "}−{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}-{i "} and {i "}−{i "} like this.}

{narrow{orson
"-" :−
 (alt
  (form (inj r) inj:
    ?intNeg(r)),
  (form (rej r) rej:
    ?realNeg(r)),
  (form (inj l, inj r) inj:
    ?intSub(l, r)),
  (form (rej l, rej r) rej:
    ?realSub(l, r)),
  (gen (type exe lBase)
    form (row lBase l, inj r) row lBase:
     ?rowSub(l, r)),
  (gen (type exe lBase)
    gen (type lBase rBase)
     form (row lBase l, row rBase r) inj:
      ?rowDist(l, r)),
  (gen (type exe rBase)
    gen (type rBase lBase)
     form (row lBase l, row rBase r) inj:
      ?rowDist(l, r)))

"−" :− "-"}}

{justify
  If {i r} {goto evaluate evaluates} to an {goto int integer} or to a
  {goto real real,} then the {goto term terms} -\ {i r} and −\ {i r} evaluate
  to {i r} with the opposite of its original sign.
  If {i l} and {i r} both evaluate to {goto int integers,} then the
  {goto sum sums} {i l}\ -\ {i r} and {i l}\ −\ {i r} evaluate to the integer
  that results when {i r} is subtracted from {i l.}
  If {i l} and {i r} both evaluate to {goto real reals,} then {i l}\ -\ {i r}
  and {i l}\ −\ {i r} evaluate to the real that results when {i r} is
  subtracted from {i l.}}

{justify
  {b Pointer arithmetic.}
  Suppose that {i l} evaluates to a {goto {i row}} pointer whose base type is
  {i t.}
  Also suppose that {i r} evaluates to an integer.
  Then {i l}\ -\ {i r} and {i l}\ −\ {i r} perform {goto pointer} arithmetic.
  First {i l} is converted to a nonnegative integer, then {i r} times the
  {goto typesize size} of {i t} is subtracted from it.
  The result is converted to a pointer of type {b row}\ {i t} and returned.

  For example, suppose there is an {goto prebracket array} whose base type is
  {i t.}
  Also suppose that {i l} is a pointer whose base type is {i t,} and that it
  references an element of the array at index {i k.}
  Then {i l}\ -\ {i r} and {i l}\ −\ {i r} evaluate to a pointer of type
  {b row}\ {i t} that references an element of the array at index
  {i k}\ −\ {i r.}
  If the element does not exist, then they evaluate to an {goto unspecified}
  pointer of type {b row}\ {i t.}
  Contrary to {goto stdform convention,} if {i l} {goto transform transforms}
  to a {goto string} {goto constant} and {i r} transforms to an integer
  constant, then {i l}\ -\ {i r} and {i l}\ −\ {i r} do not transform to a
  string constant.}

{justify
  {b Pointer distance.}
  Suppose that {i l} and {i r} both evaluate to {i row} pointers.
  Also suppose that {i l}'s base type is a {goto subtype} of {i r}'s base type,
  or vice-versa, so both base types have the same size.
  Then {i l}\ -\ {i r} and {i l}\ −\ {i r} evaluate to the integer {i distance}
  between {i l} and {i r}.
  This is the number of {goto object execution} instances, of either base type,
  that separate {i l} and {i r} in memory.
  First {i l} and {i r} are converted to nonnegative integers, their difference
  is divided by the size of either base type, and the resulting integer
  (which may be negative) is returned.
  It is an {goto errors error} if the size of either base type is 0.

  For example, suppose there is an array whose base type is {i t,} and that
  {i l} and {i r} are pointers whose base type is {i t.}
  Also suppose that {i l} references an element of the array at index {i j,}
  and that {i r} references an element at index {i k.}
  Then {i l}\ -\ {i r} and {i l}\ −\ {i r} evaluate to {i j}\ −\ {i k.}
  Contrary to convention, if {i l} and {i r} transform to string constants,
  then {i l}\ -\ {i r} and {i l}\ −\ {i r} do not transform to an integer
  constant.}

{label dashequal}
{left {b 7.3.10. {i "}-={i "} and {i "}−={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}-={i "} and {i "}−={i "} like this.}

{narrow{orson
"-=" :−
 (alt
  (gen (type inj lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?intSubSet(l, r)),
  (gen (type rej lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?realSubSet(l, r)),
  (gen (type exe lBase)
    form (var row lBase l, inj r) void:
     ?rowSubSet(l, r)))

"−=" :− "-="}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment assignments} {i l}\ -=\ {i r} and {i l}\ −=\ {i r}
  set the value of {i l} to the integer that results when {i r} is
  {goto dash subtracted} from {i l.}
  They both evaluate to {goto void {i skip.}}

  Suppose that {i l} evaluates to a variable of type {b var}\ {i t,} where
  {i t} is a {goto real} type.
  Also suppose that {i r} evaluates to a real of type {i t.}
  Then the assignments {i l}\ -=\ {i r} and {i l}\ −=\ {i r} set the value of
  {i l} to the real that results from {i r} is subtracted from {i l.}
  They both evaluate to {i skip.}

  Suppose that {i l} evaluates to a variable whose base type is a
  {goto {i row}} pointer type, and that {i r} evaluates to an integer.
  Then {i l}\ -=\ {i r} and {i l}\ −=\ {i r} set the value of {i l} to the
  {i row} pointer that results when {i r} is subtracted from {i l.}
  They both evaluate to {i skip.}}

{label dot}
{left {b 7.3.11. {i "}.{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}.{i "} like this.}

{narrow{orson
"." :−
 (alt
  (gen (type mut lType, type sym rSym)
    gen (type rSym lSym)
     form (var slot(lType, lSym) l, type rSym r) var lType:
      ?varTupSlot(l, r)),
  (gen (type exe lType, type sym rSym)
    gen (type rSym lSym)
     form (slot(lType, lSym) l, type rSym r) lType:
      ?tupSlot(l, r)),
  (gen (type exe lType, type sym rSym)
    gen (type rSym lSym)
     form (type slot(lType, lSym), type rSym) type lType:
      lType),
  (form (list l, type sym r) list:
    ?listTail(l, r)))}}

{justify
  The {goto altclause alternate} form {i "}.{i "} retrieves named parts of
  {goto list lists} and {goto tupleclause tuples.}
  It uses a {goto symbol} {goto type} ${i r} to denote the
  {goto nametoken name} {i r} of the part to be retrieved.
  If {i l} is a {goto unit} and {i r} is a name, then the unit {i l}\ .\ {i r}
  {goto abbreviate abbreviates} the {goto call} {i "}.{i "}({i l,}\ ${i r}).

  Suppose that {i l} evaluates to a {goto vartype variable} whose base type is
  a tuple type with a slot {i t}\ {i r,} where {i t} is not a variable type.
  Then {i l}\ .\ {i r} {goto evaluate evaluates} to the instance in the slot
  {goto namepart named} {i r} in {i l,} whose type is {b var}\ {i t.}
  In other words, the instance is treated as if it is a variable.

  Suppose that {i l} evaluates to a tuple with a slot {i t}\ {i r,} where {i t}
  may or may not be a variable type.
  Then {i l}\ .\ {i r} evaluates to the instance in the slot named {i r} in
  {i l,} whose type is {i t.}

  Suppose that {i l} transforms to a tuple type with a slot {i t}\ {i r.}
  Then {i l}\ .\ {i r} {goto transform transforms} to the type {i t.}

  Suppose that {i l} transforms to a list.
  Then {i l}\ .\ {i r} transforms to the first {goto list tail} of {i l} whose
  {goto {i car}} is ${i r.}
  It is an {goto errors error} if {i l} has no such tail.
  This is primarily intended to be used with {goto scapegoat} lists.
  It is similar to the function {i assoc} in the programming language Common
  Lisp {goto ste1990 {c [ste 1990].}}}

{justify
  {b Virtual slots.}
  The name {i "}.{i "} may be {goto bind rebound} to make it appear that an
  object has a slot, even though it does not.
  Such a slot is called a {i virtual slot.}
  For example, this {goto withclause equate} adds a new {goto altclause member}
  form to {i "}.{i "}, making it appear that {goto int integers} have a virtual
  slot called {i sign.}}

{narrow
 {orson
"." :−
 (form (inj l, type $sign) bool:
   l < 0)}}

{justify
  Suppose that {i l} is a unit which evaluates to an integer.
  Then {i l}.{i sign} evaluates to {goto bool {i true}} if {i l} is negative,
  and it evaluates to {goto bool {i false}} otherwise.}

{label slash}
{left {b 7.3.12. {i "}/{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}/{i "} like this.}

{narrow{orson
"/" :−
 (alt
  (form (inj l, inj r) inj:
    ?intDiv(l, r)),
  (form (rej l, rej r) rej:
    ?realDiv(l, r)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Then the {goto product} {i l}\ /\ {i r} evaluates to the integer that is the
  result of dividing {i l} by {i r.}
  It is an {goto errors error} if {i r} evaluates to 0.

  Suppose that {i l} and {i r} both evaluate to {goto real reals.}
  Then {i l}\ /\ {i r} evaluates to the real that is the result of dividing
  {i l} by {i r.}
  If {i r} evaluates to 0.0, then {i l}\ /\ {i r} evaluates to an
  {goto unspecified} real.}

{label slashequal}
{left {b 7.3.13. "/=".}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}/={i "} like this.}

{narrow{orson
"/=" :−
 (alt
  (gen (type inj lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?intDivSet(l, r)),
  (gen (type rej lBase)
    gen (type lBase rType)
     form (var lBase l, rType r) void:
      ?realDivSet(l, r)))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment} {i l}\ /=\ {i r} sets the value of {i l} to the
  integer that is the result of {goto slash dividing} {i l} by {i r.}
  It returns {goto void {i skip.}}

  Suppose that {i l} evaluates to a variable of type {b var}\ {i t,} where
  {i t} is a {goto real} type.
  Also suppose that {i r} evaluates to a real of type {i t.}
  Then the {i l}\ /=\ {i r} sets the value of {i l} to the real that is the
  result of dividing {i l} by {i r.}
  It returns {i skip.}}

{label colonequal}
{left {b 7.3.14. {i "}:={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}:={i "} like this.}

{narrow{orson
":=" :−
 (gen (type mut lBase)
   gen (type lBase rType)
    form (var lBase l, rType r) void:
     ?varSet(l, r))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t.}
  Also suppose that {i r} evaluates to an {goto object execution} instance
  whose type is a {goto subtype} of {i t.}
  Then the {goto assignment} {i l}\ :=\ {i r} sets the value of {i l} to {i r.}
  It returns {goto void {i skip.}}}

{label lt}
{left {b 7.3.15. {i "}<{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name 
  {i "}<{i "} like this.}

{narrow{orson
"<" :−
 (alt
  (form (cha l, cha r) bool:
    ?charLt(l, r)),
  (form (inj l, inj r) bool:
    ?intLt(l, r)),
  (form (rej l, rej r) bool:
    ?realLt(l, r)),
  (form (null l, row exe r) bool:
    ?rowLt(l, r)),
  (form (row exe l, null r) bool:
    ?rowLt(l, r)),
  (form (string l, string r) bool:
    comp(l, r) < 0),
  (form (row exe l, row exe r) bool:
    ?rowLt(l, r)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison} {i l}\ <\ {i r} evaluates to the
  {goto bool Boolean} {goto bool {i true}} if {i l}'s code is less than {i r}'s
  code.
  It evaluates to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ <\ {i r} evaluates to {i true} if {i l} is less than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ <\ {i r} evaluates to {i true} if {i l} is
  {goto comp lexicographically} less than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} evaluate to {goto {i row}} pointers, possibly
  of different {goto type types,} but not both strings.
  Then {i l}\ <\ {i r} evaluates to {i true} if {i l} is less than {i r.}
  It evaluates to {i false} otherwise.}

{label ltlt}
{left {b 7.3.16. {i "}<␣<{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}<␣<{i "} like this.}

{narrow{orson
"<␣<" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charLt(l, m) ∧ ?charLt(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intLt(l, m) ∧ ?intLt(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realLt(l, m) ∧ ?realLt(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLt(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLt(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLt(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) < 0 ∧ comp(m, r) < 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLt(m, r))))}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison} {i l}\ <\ {i m}\ <\ {i r} evaluates to the
  {goto bool Boolean} {goto bool {i true}} if {i l}'s code is less than {i m}'s
  code, and {i m}'s code is less than {i r}'s code.
  It evaluates to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ <\ {i m}\ <\ {i r} evaluates to {i true} if {i l} is less than
  {i m,} and {i m} is less than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ <\ {i m}\ <\ {i r} evaluates to {i true} if {i l} is
  {goto comp lexicographically} less than {i m,} and {i m} is lexicographically
  less than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ <\ {i m}\ <\ {i r} evaluates to {i true} if {i l} is less than
  {i m,} and {i m} is less than {i r.}
  It evaluates to {i false} otherwise.}

{label ltle}
{left {b 7.3.17. {i "}<␣<={i "} and {i "}<␣≤{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<␣<={i "} and {i "}<␣≤{i "} like this.}

{narrow{orson
"<␣<=" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charLt(l, m) ∧ ?charLe(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intLt(l, m) ∧ ?intLe(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realLt(l, m) ∧ ?realLe(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLe(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLe(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLe(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) < 0 ∧ comp(m, r) ≤ 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowLt(l, m) ∧ ?rowLe(m, r))))

"<␣≤" :− "<␣<="}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ <\ {i m}\ <=\ {i r} and
  {i l}\ <\ {i m}\ ≤\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is less than {i m}'s code, and {i m}'s
  code is less than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ <\ {i m}\ <= {i r} and {i l}\ <\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is less than {i m,} and {i m} is less than or equal to
  {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ <\ {i m}\ <=\ {i r} and {i l}\ <\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} less than {i m,} and {i m}
  is lexicographically less than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ <\ {i m}\ <=\ {i r} and {i l}\ <\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is less than {i m,} and {i m} is less than or equal to
  {i r.}
  They evaluate to {i false} otherwise.}

{label left}
{left {b 7.3.18. {i "}<<{i "} and {i "}←{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<<{i "} and {i "}←{i "} like this.}

{narrow{orson
"<<" :−
 (gen (type inj lType)
   form (lType l, inj r) lType:
    ?intLsh(l, r))

"←" :− "<<"}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Contrary to {goto stdform convention,} they are not {goto cotype coerced} to
  the same {goto type type.}
  If {i r} is greater than or equal to 0, then {i l}\ <<\ {i r} and
  {i l}\ ←\ {i r} evaluate to the integer that results from shifting {i l} by
  {i r} bits to the left, filling in 0-bits on the right.
  If {i r} is less than 0, then {i l}\ <<\ {i r} and {i l}\ ←\ {i r} evaluate
  to an {goto unspecified} integer.
  In either case {i l}\ <<\ {i r} and {i l}\ ←\ {i r} evaluate to an integer
  with the same type as {i l.}}

{label leftequal}
{left {b 7.3.19. {i "}<<={i "} and {i "}←={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<<={i "} and {i "}←={i "} like this.}

{narrow{orson
"<<=" :−
 (form (var inj l, inj r) void:
   ?intLshSet(l, r))

"←=" :− "<<="}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to an {goto int integer}
  {goto vartype variable,} and that {i r} evaluates to an integer.
  Then the {goto assignment assignments} {i l}\ <<=\ {i r} and {i l}\ ←=\ {i r}
  set the value of {i l} to the integer that results from {goto left shifting}
  {i l} by {i r} bits to the left.
  They both evaluate to {goto void {i skip.}}}

{label le}
{left {b 7.3.20. {i "}<={i "} and {i "}≤{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<={i "} and {i "}≤{i "} like this.}

{narrow{orson
"<=" :−
 (alt
  (form (cha l, cha r) bool:
    ?charLe(l, r)),
  (form (inj l, inj r) bool:
    ?intLe(l, r)),
  (form (rej l, rej r) bool:
    ?realLe(l, r)),
  (form (null l, row exe r) bool:
    ?rowLe(l, r)),
  (form (row exe l, null r) bool:
    ?rowLe(l, r)),
  (form (string l, string r) bool:
    comp(l, r) ≤ 0),
  (form (row exe l, row exe r) bool:
    ?rowLe(l, r)))

"≤" :− "<="}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ <=\ {i r} and {i l}\ ≤\ {i r}
  evaluate to the {goto bool Boolean} {goto bool {i true}} if {i l}'s code is
  less than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ <=\ {i r} and {i l}\ ≤\ {i r} evaluate to {i true} if {i l} is
  less than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ <=\ {i r} and {i l}\ ≤\ {i r} evaluate to {i true} if {i l} is
  {goto comp lexicographically} less than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not both strings.
  Then {i l}\ <=\ {i r} and {i l}\ ≤\ {i r} evaluate to {i true} if {i l} is
  less than or equal to {i r.}
  They evaluate to {i false} otherwise.}

{label lelt}
{left {b 7.3.21. {i "}<=␣<{i "} and {i "}≤␣<{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<=␣<{i "} and {i "}≤␣<{i "} like this.}

{narrow{orson
"<=␣<" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charLe(l, m) ∧ ?charLt(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intLe(l, m) ∧ ?intLt(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realLe(l, m) ∧ ?realLt(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLt(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLt(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLt(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) ≤ 0 ∧ comp(m, r) < 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLt(m, r))))

"≤␣<" :− "<=␣<"}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ <=\ {i m}\ <\ {i r} and
  {i l}\ ≤\ {i m}\ <\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is less than or equal to {i m}'s code,
  and {i m}'s code is less than {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ <=\ {i m}\ <\ {i r} and {i l}\ ≤\ {i m}\ <\ {i r} evaluate to
  {i true} if {i l} is less than or equal to {i m,} and {i m} is less than
  {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ <=\ {i m}\ <\ {i r} and {i l}\ ≤\ {i m}\ <\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} less than or equal to
  {i m,} and {i m} is lexicographically less than {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ <=\ {i m}\ <\ {i r} and {i l}\ ≤\ {i m}\ <\ {i r} evaluate to
  {i true} if {i l} is less than or equal to {i m,} and {i m} is less than
  {i r.}
  They evaluate to {i false} otherwise.}

{label lele}
{left {b 7.3.22. {i "}<=␣<={i "} and {i "}≤␣≤{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<=␣<={i "} and {i "}≤␣≤{i "} like this.}

{narrow{orson
"<=␣<=" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charLe(l, m) ∧ ?charLe(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intLe(l, m) ∧ ?intLe(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realLe(l, m) ∧ ?realLe(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLe(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLe(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLe(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) ≤ 0 ∧ comp(m, r) ≤ 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowLe(l, m) ∧ ?rowLe(m, r))))

"≤␣≤" :− "<=␣<="}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ <=\ {i m}\ <=\ {i r} and
  {i l}\ ≤\ {i m}\ ≤\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is less than or equal to {i m}'s code,
  and {i m}'s code is less than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ <=\ {i m}\ <=\ {i r} and {i l}\ ≤\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is less than or equal to {i m,} and {i m} is less than or
  equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ <=\ {i m}\ <=\ {i r} and {i l}\ ≤\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} less than or equal to
  {i m,} and {i m} is lexicographically less than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ <=\ {i m}\ <=\ {i r} and {i l}\ ≤\ {i m}\ ≤\ {i r} evaluate to
  {i true} if {i l} is less than or equal to {i m,} and {i m} is less than or
  equal to {i r.}
  They evaluate to {i false} otherwise.}

{label ne}
{left {b 7.3.23. {i "}<>{i "} and {i "}≠{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}<>{i "} and {i "}≠{i "} like this.}

{narrow{orson
"<>" :−
 (alt
  (form (cha l, cha r) bool:
    ?charNe(l, r)),
  (form (inj l, inj r) bool:
    ?intNe(l, r)),
  (form (rej l, rej r) bool:
    ?realNe(l, r)),
  (form (null l, row exe r) bool:
    ?rowNe(l, r)),
  (form (row exe l, null r) bool:
    ?rowNe(l, r)),
  (form (string l, string r) bool:
    comp(l, r) ≠ 0),
  (form (row exe l, row exe r) bool:
    ?rowNe(l, r)))

"≠" :− "<>"}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ <>\ {i r} and
  {i l}\ ≠\ {i r} evaluate to the {goto bool Boolean} {goto bool {i true}} if
  {i l}'s code is not equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ <>\ {i r} and {i l}\ ≠\ {i r} evaluate to {i true} if {i l} is
  not equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ <>\ {i r} and {i l}\ ≠\ {i r} evaluate to {i true} if {i l} is
  not {goto comp lexicographically} equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not both strings.
  Then {i l}\ <>\ {i r} and {i l}\ ≠\ {i r} evaluate to {i true} if {i l} is
  not equal to {i r.}
  They evaluate to {i false} otherwise.}

{label eq}
{left {b 7.3.24. {i "}={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}={i "} like this.}

{narrow{orson
"=" :−
 (alt
  (form (cha l, cha r) bool:
    ?charEq(l, r)),
  (form (inj l, inj r) bool:
    ?intEq(l, r)),
  (form (rej l, rej r) bool:
    ?realEq(l, r)),
  (form (null l, row exe r) bool:
    ?rowEq(l, r)),
  (form (row exe l, null r) bool:
    ?rowEq(l, r)),
  (form (string l, string r) bool:
    comp(l, r) = 0),
  (form (row exe l, row exe r) bool:
    ?rowEq(l, r)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison} {i l}\ =\ {i r} evaluates to the
  {goto bool Boolean} {goto bool {i true}} if {i l}'s code is equal to {i r}'s
  code.
  It evaluates to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ =\ {i r} evaluates to {i true} if {i l} is equal to {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ =\ {i r} evaluates to {i true} if {i l} is
  {goto comp lexicographically} equal to {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not both strings.
  Then {i l}\ =\ {i r} evaluates to {i true} if {i l} is equal to {i r.}
  It evaluates to {i false} otherwise.}

{label gt}
{left {b 7.3.25. {i "}>{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}>{i "} like this.}

{narrow{orson
">" :−
 (alt
  (form (cha l, cha r) bool:
    ?charGt(l, r)),
  (form (inj l, inj r) bool:
    ?intGt(l, r)),
  (form (rej l, rej r) bool:
    ?realGt(l, r)),
  (form (null l, row exe r) bool:
    ?rowGt(l, r)),
  (form (row exe l, null r) bool:
    ?rowGt(l, r)),
  (form (string l, string r) bool:
    comp(l, r) > 0),
  (form (row exe l, row exe r) bool:
    ?rowGt(l, r)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison} {i l}\ >\ {i r} evaluates to the
  {goto bool Boolean} {goto bool {i true}} if {i l}'s code is greater than
  {i r}'s code.
  It evaluates to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ >\ {i r} evaluates to {i true} if {i l} is greater than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ >\ {i r} evaluates to {i true} if {i l} is
  {goto comp lexicographically} greater than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not both strings.
  Then {i l}\ >\ {i r} evaluates to {i true} if {i l} is greater than {i r.}
  It evaluates to {i false} otherwise.}

{label gtgt}
{left {b 7.3.26. {i "}>␣>{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}>␣>{i "} like this.}

{narrow{orson
">␣>" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charGt(l, m) ∧ ?charGt(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intGt(l, m) ∧ ?intGt(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realGt(l, m) ∧ ?realGt(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGt(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGt(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGt(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) > 0 ∧ comp(m, r) > 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGt(m, r))))}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison} {i l}\ >\ {i m}\ >\ {i r} evaluates to the
  {goto bool Boolean} {goto bool {i true}} if {i l}'s code is greater than
  {i m}'s code, and {i m}'s code is greater than {i r}'s code.
  It evaluates to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ >\ {i m}\ >\ {i r} evaluates to {i true} if {i l} is greater than
  {i m,} and {i m} is greater than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ >\ {i m}\ >\ {i r} evaluates to {i true} if {i l} is
  {goto comp lexicographically} greater than {i m,} and {i m} is
  lexicographically greater than {i r.}
  It evaluates to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ >\ {i m}\ >\ {i r} evaluates to {i true} if {i l} is greater than
  {i m,} and {i m} is greater than {i r.}
  It evaluates to {i false} otherwise.}

{label gtge}
{left {b 7.3.27. {i "}>␣>={i "} and {i "}>␣≥{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>␣>={i "} and {i "}>␣≥{i "} like this.}

{narrow{orson
">␣>=" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charGt(l, m) ∧ ?charGe(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intGt(l, m) ∧ ?intGe(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realGt(l, m) ∧ ?realGe(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGe(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGe(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGe(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) > 0 ∧ comp(m, r) ≥ 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowGt(l, m) ∧ ?rowGe(m, r))))

">␣≥" :− ">␣>="}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ >\ {i m}\ >=\ {i r} and
  {i l}\ >\ {i m}\ ≥\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is greater than {i m}'s code, and
  {i m}'s code is greater than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ >\ {i m}\ >= {i r} and {i l}\ >\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is greater than {i m,} and {i m} is greater than or equal
  to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ >\ {i m}\ >=\ {i r} and {i l}\ >\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} greater than {i m,} and
  {i m} is lexicographically greater than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ >\ {i m}\ >=\ {i r} and {i l}\ >\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is greater than {i m,} and {i m} is greater than or equal
  to {i r.}
  They evaluate to {i false} otherwise.}

{label right}
{left {b 7.3.28. {i "}>>{i "} and {i "}→{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>>{i "} and {i "}→{i "} like this.}

{narrow{orson
">>" :−
 (gen (type inj lType)
   form (lType l, inj r) lType:
    ?intLsh(l, r))

"→" :− ">>"}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Contrary to {goto stdform convention,} they are not {goto cotype coerced} to
  the same {goto type type.}
  If {i r} is greater than or equal to 0, then {i l}\ >>\ {i r} and
  {i l}\ →\ {i r} evaluate to the integer that results from shifting {i l} by
  {i r} bits to the right, filling in copies of the most significant bit on the
  left.
  If {i r} is less than 0, then {i l}\ >>\ {i r} and {i l}\ →\ {i r} evaluate
  to an {goto unspecified} integer.
  In either case, {i l}\ >>\ {i r} and {i l}\ →\ {i r} evaluate to an integer
  with the same type as {i l.}}

{label rightequal}
{left {b 7.3.29. {i "}>>={i "} and {i "}→={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>>={i "} and {i "}→={i "} like this.}

{narrow{orson
">>=" :−
 (form (var inj l, inj r) void:
   ?intRshSet(l, r))

"→=" :− ">>="}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to an {goto int integer}
  {goto vartype variable.}
  Also suppose that {i r} evaluates to an integer.
  Then the {goto assignment assignments} {i l}\ >>=\ {i r} and {i l}\ →=\ {i r}
  set the value of {i l} to the integer that results from {goto right shifting}
  {i l} by {i r} bits to the right.
  They both evaluate to {goto void {i skip.}}}

{label ge}
{left {b 7.3.30. {i "}>={i "} and {i "}≥{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>={i "} and {i "}≥{i "} like this.}

{narrow{orson
">=" :−
 (alt
  (form (cha l, cha r) bool:
    ?charGe(l, r)),
  (form (inj l, inj r) bool:
    ?intGe(l, r)),
  (form (rej l, rej r) bool:
    ?realGe(l, r)),
  (form (null l, row exe r) bool:
    ?rowGe(l, r)),
  (form (row exe l, null r) bool:
    ?rowGe(l, r)),
  (form (string l, string r) bool:
    comp(l, r) ≥ 0),
  (form (row exe l, row exe r) bool:
    ?rowGe(l, r)))

"≥" :− ">="}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ >=\ {i r} and
  {i l}\ ≥\ {i r} evaluate to the {goto bool Boolean} {goto bool {i true}} if
  {i l}'s code is greater than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then {i l}\ >=\ {i r} and {i l}\ ≥\ {i r} evaluate to {i true} if {i l} is
  greater than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto string strings.}
  Then {i l}\ >=\ {i r} and {i l}\ ≥\ {i r} evaluate to {i true} if {i l} is
  {goto comp lexicographically} greater than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l} and {i r} both evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not both strings.
  Then {i l}\ >=\ {i r} and {i l}\ ≥\ {i r} evaluate to {i true} if {i l} is
  greater than or equal to {i r.}
  They evaluate to {i false} otherwise.}

{label gegt}
{left {b 7.3.31. {i "}>=␣>{i "} and {i "}≥␣>{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>=␣>{i "} and {i "}≥␣>{i "} like this.}

{narrow{orson
">=␣>" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charGe(l, m) ∧ ?charGt(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intGe(l, m) ∧ ?intGt(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realGe(l, m) ∧ ?realGt(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGt(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGt(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGt(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) ≥ 0 ∧ comp(m, r) > 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGt(m, r))))

"≥␣>" :− ">=␣>"}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ >=\ {i m}\ >\ {i r} and
  {i l}\ ≥\ {i m}\ >\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is greater than or equal to {i m}'s
  code, and {i m}'s code is greater than {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ >=\ {i m}\ >\ {i r} and {i l}\ ≥\ {i m}\ >\ {i r} evaluate to
  {i true} if {i l} is greater than or equal to {i m,} and {i m} is greater
  than {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ >=\ {i m}\ >\ {i r} and {i l}\ ≥\ {i m}\ >\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} greater than or equal to
  {i m,} and {i m} is lexicographically greater than {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ >=\ {i m}\ >\ {i r} and {i l}\ ≥\ {i m}\ >\ {i r} evaluate to
  {i true} if {i l} is greater than or equal to {i m,} and {i m} is greater
  than {i r.}
  They evaluate to {i false} otherwise.}

{label gege}
{left {b 7.3.32. {i "}>=␣>={i "} and {i "}≥␣≥{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}>=␣>={i "} and {i "}≥␣≥{i "} like this.}

{narrow{orson
">=␣>=" :−
 (alt
  (form (cha l, cha m, cha r) bool:
   (with m :− (past m)
    do ?charGe(l, m) ∧ ?charGe(m, r))),
  (form (inj l, inj m, inj r) bool:
   (with m :− (past m)
    do ?intGe(l, m) ∧ ?intGe(m, r))),
  (form (rej l, rej m, rej r) bool:
   (with m :− (past m)
    do ?realGe(l, m) ∧ ?realGe(m, r))),
  (form (null l, string m, string r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGe(m, r))),
  (form (string l, null m, string r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGe(m, r))),
  (form (string l, string m, null r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGe(m, r))),
  (form (string l, string m, string r) bool:
   (with m :− (past m)
    do comp(l, m) ≥ 0 ∧ comp(m, r) ≥ 0)),
  (form (row exe l, row exe m, row exe r) bool:
   (with m :− (past m)
    do ?rowGe(l, m) ∧ ?rowGe(m, r))))

"≥␣≥" :− ">=␣>="}}

{justify
  Suppose that {i l,} {i m,} and {i r} all {goto evaluate} to
  {goto char characters.}
  Then the {goto comparison comparisons} {i l}\ >=\ {i m}\ >=\ {i r} and
  {i l}\ ≥\ {i m}\ ≥\ {i r} evaluate to the {goto bool Boolean}
  {goto bool {i true}} if {i l}'s code is greater than or equal to {i m}'s
  code, and {i m}'s code is greater than or equal to {i r}'s code.
  They evaluate to the Boolean {goto bool {i false}} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto int integers} or
  all evaluate to {goto real reals.}
  Then {i l}\ >=\ {i m}\ >=\ {i r} and {i l}\ ≥\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is greater than or equal to {i m,} and {i m} is greater
  than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto string strings.}
  Then {i l}\ >=\ {i m}\ >=\ {i r} and {i l}\ ≥\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is {goto comp lexicographically} greater than or equal to
  {i m,} and {i m} is lexicographically greater than or equal to {i r.}
  They evaluate to {i false} otherwise.

  Suppose that {i l,} {i m,} and {i r} all evaluate to {goto {i row}} pointers,
  possibly of different {goto type types,} but not all strings.
  Then {i l}\ >=\ {i m}\ >=\ {i r} and {i l}\ ≥\ {i m}\ ≥\ {i r} evaluate to
  {i true} if {i l} is greater than or equal to {i m,} and {i m} is greater
  than or equal to {i r.}
  They evaluate to {i false} otherwise.}

{label at}
{left {b 7.3.33. {i "}@{i "} and {i "}↓{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}@{i "} and {i "}↓{i "} like this.}

{narrow{orson
"@" :−
 (alt
  (gen (type mut lType)
    form (var [] lType l) row var lType:
     ?varArrToRow(l)),
  (gen (type exe lType)
    form ([] lType l) row lType:
     ?arrToRow(l)),
  (gen (type exe lType)
    form (lType l) row lType:
     ?toRow(l)))

"↓" :− "@"}}

{justify
  The {goto unit units} {i l}@ and {i l}↓ are called {i enreferencers,} the
  opposite of {goto uparrow dereferencers.}
  If {i l} {goto evaluate evaluates} to an {goto object execution} instance,
  then both {i l}@ and {i l}↓ evaluate to a {goto {i row}} pointer that
  references {i l.}
  If the {goto typesize size} of {i l}'s {goto type} is 0, then they evaluate
  to an {goto unspecified} {i row} pointer.

  Suppose that {i l} evaluates to an {goto prebracket array}
  {goto vartype variable} of type {b var}\ [{i k}]\ {i t,} where {i t} is not a
  variable type.
  Then {i l}@ and {i l}↓ evaluate to a pointer of type {b row}\ {b var}\ {i t}
  that references the element of the array at index 0.
  In other words, the element is treated as if it is a variable.

  Suppose that {i l} evaluates to an array of type [{i k}]\ {i t,} where {i t}
  may or may not be a variable type.
  Then {i l}@ and {i l}↓ evaluate to a pointer of type {b row}\ {i t} that
  references the element of the array at index 0.

  Suppose that {i l} evaluates to an execution instance of type {i t,} but not
  an array.
  Then {i l}@ and {i l}↓ evaluate to pointer of type {b row}\ {i t} that
  references the instance.}

{justify
  {b Copied objects.}
  Suppose that {i l} evaluates to an execution instance which is temporarily
  stored in a register, or in an area of memory reserved for temporary
  instances.
  Then {i l}@ and {i l}↓ evaluate to an unspecified pointer that references a
  copy of {i l.}
  For example, if a {goto procclause procedure} {goto call} {i p}() returns an
  {goto int integer,} then the unit {i p}()↓ references a copy of that integer.

  Nothing should be assumed about where the copies of these temporary instances
  reside in memory.
  If the same temporary instance is enreferenced twice, then the two
  enreferencers might return the same pointer, or they might return different
  pointers.
  If two different temporary instances are enreferenced, then the two
  enreferencers might return the same pointer, or they might return different
  pointers.}

{justify
  {b Named objects.}
  Suppose that a {goto nametoken name} {i n} is {goto bind bound} by an
  {goto withclause equate} to an array, to an array variable, to a
  {goto tupleclause tuple,} or to a tuple variable.
  Then the units {i n}@ and {i n}↓ reference the actual execution instance to
  which {i n} is bound, not a copy.

  Suppose that the unit {i e} evaluates to an execution instance which is part
  of {i n.}
  Also suppose that {i e} is composed only of {goto call calls} to
  the {goto plus addition} form {i "}+{i ",}
  the dereferencing form {i "}{q ^}{i "} or {i "}↑{i ",}
  the {goto dash subtraction} form {i "}-{i "} or {i "}−{i ",}
  the {goto dot} form {i "}.{i ",}
  and the array {goto postbracket element} form {i "}␣[]{i ".}
  Then the units {i e}@ and {i e}↓ reference the actual part of the instance,
  not a copy.
  For example, the unit {i n}↑[{i k}\ +\ 1].{i s}↓ references the actual
  instance in the slot {goto namepart named} {i s} in the tuple that is the
  {i k}\ +\ 1st element of the array referenced by {i n.}}

{justify
  {b Undefined objects.}
  Enreferencers can create pointers that reference {goto undefined} execution
  instances.
  For example, the {goto withclause {i with}} clause
  ({b with}\ {b var}\ {i int}\ {i v}\ :−\ 0\ {b do}\ {i v}↓)
  creates a {goto vartype variable} {i v,} then returns a pointer to it.
  However, {i v} becomes undefined after the {i with} clause's {goto scope}
  exits, so any attempt to dereference the pointer is an {goto errors error.}}

{label prebracket}
{left {b 7.3.34. {i "}[]␣{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}[]␣{i "} like this.}

{narrow{orson
"[]␣" :−
 (alt
  (form (type exe r) type exe:
    ?arrays(r)),
  (form (inj l, type exe r) type exe:
    ?array(l, r)))}}

{justify
  An {i array} is an {goto object execution} instance that represents an
  ordered, finite series of zero or more other execution instances, all of the
  same type.
  This type is called the array's {i base type,} and the instances are called
  the array's {i elements.}
  The number of elements in the array is a nonnegative {goto int integer}
  {goto constant} called its {i length.}
  There may be a {goto limit} on the number of elements in an array.

  Each element of an array is uniquely identified by a nonnegative integer
  called its {i index.}
  In an array of length {i n,} the first element has index 0, the second
  element has index 1, etc.
  The {i n}th element has index {i n}\ −\ 1.
  An array of length 0 has no elements, and therefore no indexes.

  Suppose that {i l} {goto transform transforms} to a nonnegative integer
  constant, and that {i r} transforms to an execution type without
  {goto joker jokers.}
  Then the {goto term} [{i l}]\ {i r} transforms to the type of an array whose
  length is {i l} and whose base type is {i r.}
  It is an {goto errors error} if {i l} does not transform to a constant.

  Suppose that {i l} transforms to a nonnegative integer constant, and that
  {i r} transforms to an execution type with jokers.
  Then [{i l}]\ {i r} transforms to a new joker that describes any array whose
  length is {i l} and whose base type is a {goto subtype} of {i r.}
  It is an error if {i l} does not transform to a constant.

  Suppose that {i r} transforms to an execution type, with or without jokers.
  Then []\ {i r} transforms to a new joker that describes an array of any
  length, and whose base type is a subtype of {i r.}

  {goto rule Rule} {b 73} describes how an array type can be a subtype of
  another array type.
  Rule {b 74} describes how an array type (whose base type may include jokers)
  can be a subtype of an array joker.
  Rule {b 75} describes how an array joker can be a subtype of another array
  joker.}

{narrow
 {label rule73}
 {label rule74}
 {label rule75}
 {layout
  {row
   {over
    {center [{i k}] {i t} ⊆ [{i k}] {i T}}
    {left \ {b 73}}
    {center {i t} ⊆ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center [{i k}] {i t} ⊆ [] {i T}}
    {left \ {b 74}}
    {center {i t} ⊆ {i T}}}
   {left \ \ \ \ \ }
   {over
    {center [] {i t} ⊆ [] {i T}}
    {left \ {b 75}}
    {center {i t} ⊆ {i T}}}}}}

{justify
  In memory, an array's elements are stored in ascending order of their
  indexes, without gaps between them.
  This allows using simple {goto pointer} arithmetic to traverse the elements
  of an array.
  If an array type contains no jokers, then its {goto typesize size} is
  {i size}([{i k}]\ {i t})\ =\ {i k}\ {i size}({i t}).}

{label uparrow}
{left {b 7.3.35. {i "}{q ^}{i "} and {i "}↑{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}{q ^}{i "} and {i "}↑{i "} like this.}

{narrow{orson
"^" :−
 (gen (type exe lType)
   form (row lType l) exe:
    ?rowTo(l))

"↑" :− "^"}}

{justify
  The {goto unit units} {i l}^ and {i l}↑ are called {i dereferencers,} the
  opposite of {goto at enreferencers.}
  Suppose that {i l} {goto evaluate evaluates} to a {goto {i ref}} pointer of
  {goto type} {b ref}\ {i t,} or to a {goto {i row}} pointer of type
  {b row}\ {i t.}
  Then {i l}{q ^} and {i l}↑ evaluate to the {goto object execution} instance
  of type {i t} that is referenced by the pointer.
  It is an {goto errors error} if {i l} evaluates to {goto null {i nil,}} or
  {goto transform transforms} to an expression of type {goto null {i null.}}
  It is also an error if {i l} evaluates to a pointer that does not reference
  an instance, that references an {goto undefined} instance, or that references
  an instance whose {goto typesize size} is 0.
  Contrary to {goto stdform convention,} if {i l} transforms to a {goto string}
  constant, then {i l}^ and {i l}↑ do not transform to a {goto char character}
  {goto constant constant.}}

{label bar}
{left {b 7.3.36. {i "}|{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}|{i "} like this.}

{narrow{orson
"|" :−
 (form (inj l, inj r) inj:
   ?intOr(l, r))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Then the {goto sum} {i l}\ |\ {i r} evaluates to the integer bitwise
  inclusive {c or} of {i l} and {i r.}}

{label barequal}
{left {b 7.3.37. {i "}|={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}|={i "} like this.}

{narrow{orson
"|=" :−
 (gen (type inj lBase)
   gen (type lBase rType)
    form (var lBase l, rType r) void:
     ?intOrSet(l, r))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment} {i l}\ |=\ {i r} sets the value of {i l} to the
  integer bitwise {goto bar inclusive {c or}} of {i l} and {i r.}
  It evaluates to {goto void {i skip.}}}

{label tilde}
{left {b 7.3.38. {i "}~{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}~{i "} like this.}

{narrow{orson
"~" :−
 (alt
  (form (inj r) inj:
    ?intNot(r)),
  (form (inj l, inj r) inj:
    ?intXor(l, r)){g)}}}

{justify
  If {i r} {goto evaluate evaluates} to an {goto int integer,} then the
  {goto term} ~\ {i r} evaluates to the integer bitwise {c not} of {i r.}
  If {i l} and {i r} both evaluate to integers, then the {goto sum}
  {i l}\ ~\ {i r} evaluates to the integer bitwise exclusive {c or} of {i l}
  and {i r.}}

{label tildeequal}
{left {b 7.3.39. {i "}~={i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}~={i "} like this.}

{narrow{orson
"~=" :−
 (gen (type inj lBase)
   gen (type lBase rType)
    form (var lBase l, rType r) void:
     ?intXorSet(l, r))}}

{justify
  Suppose that {i l} {goto evaluate evaluates} to a {goto vartype variable} of
  {goto type} {b var}\ {i t,} where {i t} is an {goto int integer} type.
  Also suppose that {i r} evaluates to an integer of type {i t.}
  Then the {goto assignment} {i l}\ ~=\ {i r} sets the value of {i l} to the
  integer bitwise {goto tilde exclusive {c or}} of {i l} and {i r.}
  It evaluates to {goto void {i skip.}}}

{label catch}
{left {b 7.3.40. {i "}catch{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}catch{i "} to a form that is discussed along with
  {goto catchclause {i catch}} clauses.}

{label for}
{left {b 7.3.41. {i "}for{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}for{i "} to a form that is discussed along with {goto forclause {i for}}
  clauses.}

{label mod}
{left {b 7.3.42. {i "}mod{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} name
  {i "}mod{i "} like this.}

{narrow{orson
"mod" :−
 (form (inj l, inj r) inj:
   ?intMod(l, r))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto int integers.}
  Then the {goto product} {i l}\ {b mod}\ {i r} evaluates to the integer
  remainder after dividing {i l} by {i r.}
  If {i l} is greater than or equal to 0, and {i r} is greater than 0, then
  {i l}\ {b mod}\ {i r} is less than {i r.}
  If {i l} is less than 0, or {i r} is less than 0, then the absolute value of
  {i l}\ {b mod}\ {i r} is less than the absolute value of {i r}
  {goto ker1988 {c [ker 1988].}}
  It is an {goto errors error} if {i r} evaluates to 0.}

{label not}
{left {b 7.3.43. {i "}not{i "} and {i "}¬{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto quoted} names
  {i "}not{i "} and {i "}¬{i "} like this.}

{narrow{orson
"not" :−
 (form (inj r) bool:
   r = 0)

"¬" :− "not"}}

{justify
  Suppose that {i r} {goto evaluate evaluates} to an {goto int integer.}
  If {i r} {goto eq equals} 0, then the {goto term terms} {b not}\ {i r} and
  ¬\ {i r} evaluate to the {goto bool Boolean} {goto bool {i true.}}
  They evaluate to the Boolean {goto bool {i false}} otherwise.}

{label abs}
{left {b 7.3.44. {i abs.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i abs}
  like this.}

{narrow{orson
abs :−
 (gen (type num rType)
   form (rType r) num:
    (with r :− (past r)
     do (if r < 0\{rType\}
         then − r
         else r)))}}

{justify
  Suppose that {i r} {goto evaluate evaluates} to an {goto int integer} or to a
  {goto real real.}
  Then the {goto call} {i abs}({i r}) evaluates to the absolute value of
  {i r.}
  Because of two's-complement arithmetic, if {i r} {goto transform transforms}
  to the most negative {goto constant} integer of the largest available integer
  {goto type type,} then {i abs}({i r}) transforms to an {goto unspecified}
  integer constant of the same type.
  Similarly, if {i r} {goto execute executes} to the most negative integer of
  its type, then {i abs}({i r}) executes to an unspecified integer of the same
  type.}

{label align}
{left {b 7.3.45. {i align.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i align}
  like this.}

{narrow{orson
align :−
 (alt
  (form (exe r) inj:
    align(type r)),
  (form (type exe r) inj:
    ?typeAlign(r)))}}

{justify
  Each {goto object execution} {goto type} has an {i alignment,} which is a
  small positive {goto int integer} {goto constant constant.}
  Suppose that an {goto object instance} of an execution type {i t} resides in
  memory.
  Then the instance's address is said to be {i aligned} if it is a multiple of
  {i t}'s alignment {goto pat2005 {c [pat 2005].}}

  If {i r} {goto transform transforms} to an execution type without
  {goto joker jokers,} then the {goto call} {i align}({i r}) transforms to
  {i r}'s alignment.
  Some computers require all addresses to be aligned.
  On these computers, {i align}({i r}) transforms to the required alignment of
  {i r.}
  Others do not require addresses to be aligned, but can run more efficiently
  if they are.
  On these, {i align}({i r}) transforms to the alignment of {i r} that is
  suggested for best efficiency.
  Still others have neither required nor suggested alignments.
  On these, {i align}({i r}) transforms to 1.

  If {i r} transforms to an execution type with jokers, then {i align}({i r})
  transforms to the integer constant −1.
  If {i r} transforms to a {goto skolem Skolem} type, then {i align}({i r})
  transforms to the alignment of {i r}'s base type.
  If {i r} transforms to an {goto expression} of an execution type, then
  {i align}({i r}) transforms to the alignment of that type.}

{label argc}
{left {b 7.3.46. {i argc} and {i argv.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names {i argc}
  and {i argv} like this.}

{narrow{orson
argc :−
 (form () int:
   ?argc())

argv :−
 (form () row string:
   ?argv())}}

{justify
  In some operating systems, an Orson program is initiated by issuing a command
  to an interpreter, called a {i shell} {goto rit1974 {c [rit 1974].}}
  Each command is a {goto string} with zero or more additional strings as its
  arguments.
  The forms {i argv} and {i argc} let a program examine the command and
  arguments that initiated it.
  The forms are suggested by similar mechanisms in the programming language C
  {goto ker1988 {c [ker 1988].}}

  Suppose that a program runs under an operating system which uses a shell.
  Then the {goto call} {i argv}() {goto evaluate evaluates} to a {goto {i row}}
  pointer that references an {goto prebracket array} whose elements are one or
  more strings.
  The element at index 0 of the array is the command, or an {goto string empty}
  string if the command is not available.
  The remaining elements, except the last, are the command's arguments.
  The last element is {goto null {i nil.}}
  The call {i argc}() evaluates to an {goto int integer} that is the
  {goto length} of the array minus 1.

  Suppose that a program runs under an operating system which does not use a
  shell, or under an operating system which does not use strings as commands,
  or does not run under an operating system at all.
  Then {i argv}() evaluates to a {i row} pointer that references an array with
  one element, {i nil,} and {i argc}() evaluates to 0.}

{label base}
{left {b 7.3.47. {i base.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i base}
  like this.}

{narrow
 {orson
base :−
 (alt
  (gen (type exe rBase)
    form (type [] rBase) type rBase:
     rBase),
  (form (type plj r) type obj:
    ?metBase(r)),
  (form (type pro r) type mut:
    ?metBase(r)),
  (gen (type exe rBase)
    form (type ref rBase) type rBase:
     rBase),
  (gen (type exe rBase)
    form (type row rBase) type rBase:
     rBase),
  (gen (type obj rBase)
    form (type type rBase) type rBase:
     rBase),
  (gen (type mut rBase)
    form (type var rBase) type rBase:
     rBase))}}

{justify
  Suppose that {i r} {goto transform transforms} to a {goto type type} which
  has a base type.
  Then the {goto call} {i base}({i r}) transforms to that base type.
  If {i r} transforms to an {goto prebracket array} type [{i k}]\ {i t} or
  to an array {goto joker} type []\ {i t,} then {i base}({i r}) transforms to
  {i t.}
  If {i r} transforms to a {goto formtype plain} form type or to a
  {goto procclause procedure} type, then {i base}({i r}) transforms to {i r}'s
  yield type.
  If {i r} transforms to a {goto pointer} type {b ref}\ {i t,} to a pointer
  type {b row}\ {i t,} to a {goto typetype type} type {b type}\ {i t,} or to
  a {goto vartype variable} type {b var}\ {i t,} then {i base}({i r})
  transforms to the type {i t.}
  It is an {goto errors error} to call {i base} with any other type.}

{label car}
{left {b 7.3.48. {i car.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i car}
  like this.}

{narrow{orson
car :−
 (form (list r) obj:
   ?listCar(r))}}

{justify
  Suppose that {i r} {goto transform transforms} to a nonempty
  {goto list list.}
  Then the {goto call} {i car}({i r}) transforms to {i r}'s first element and
  its {goto type type.}
  It is an {goto errors error} if {i r} transforms to an empty list.
  The form {i car} is similar to the function of the same name in the
  programming languages Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}}

{label cdr}
{left {b 7.3.49. {i cdr.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i cdr}
  like this.}

{narrow{orson
cdr :−
 (form (list r) list:
   ?listCdr(r))}}

{justify
  Suppose that {i r} {goto transform transforms} to a nonempty
  {goto list list.}
  Then the {goto call} {i cdr}({i r}) transforms to the list {i r} without its
  first element.
  It is an {goto errors error} if {i r} transforms to an empty list.
  The form {i cdr} is similar to the function of the same name in the
  programming languages Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}}

{label comp}
{left {b 7.3.50. {i comp.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i comp}
  like this.}

{narrow{orson
comp :−
 (form (string l, string r) inj:
  (if isString(l) ∧ isString(r)
   then ?strComp(l, r)
   else (with
          var string l :− (past l)
          var string r :− (past r)
         do (while l↑ ∧ r↑ ∧ l↑ = r↑
             do l += 1
                r += 1)
            #FF & l↑ − #FF & r↑)))}}

{justify
  Suppose that {i l} and {i r} both {goto evaluate} to {goto string strings.}
  Then the {goto call} {i comp}({i l,}\ {i r}) compares {i l} and {i r}
  lexicographically.
  It evaluates to an {goto unspecified} negative {goto int integer} if {i l} is
  less than {i r,} it evaluates to zero if {i l} is equal to {i r,} and it
  evaluates to an unspecified positive integer if {i l} is greater than {i r.}
  The form {i comp} is similar to the function {i strcmp} in the programming
  language C {goto ker1988 {c [ker 1988].}}}

{label conc}
{left {b 7.3.51. {i conc.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i conc}
  like this.}

{narrow{orson
conc :−
 (form (list l, list r) list:
   ?listConc(l, r))}}

{justify
  Suppose that {i l} and {i r} both {goto transform} to {goto list lists.}
  Then the {goto call} {i conc}({i l,}\ {i r}) transforms to a list whose
  elements are those of {i l,} followed by those of {i r.}
  The form {i conc} is similar to the function {i append} in the programming
  languages Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}}

{label cons}
{left {b 7.3.52. {i cons.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i cons}
  like this.}

{narrow{orson
cons :−
 (form (obj l, list r) list:
   ?listCons(l, r))}}

{justify
  Suppose that {i l} {goto transform transforms} to an {goto expression} or
  {goto object object,} and that {i r} transforms to a {goto list list.}
  Then the {goto call} {i cons}({i l,}\ {i r}) transforms to a new list whose
  {goto {i car}} is {i l} and whose {goto {i cdr}} is {i r.}
  The form {i cons} is similar to the function of the same name in the
  programming languages Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}}

{label count}
{left {b 7.3.53. {i count.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i count}
  like this.}

{narrow{orson
count :−
 (form (string r) inj:
  (if isString(r)
   then ?strCount(r)
   else (with
          var int c :− 0
          var string r :− (past r)
         do (while r↑
             do c += (r↑ ≥ −64)
                r += 1)
            c)))}}

{justify
  Suppose that {i r} {goto evaluate evaluates} to a {goto string string.}
  Then the {goto call} {i count}({i r}) evaluates to a nonnegative
  {goto int integer} that is the number of {goto char {i char}1's} encoded in
  {i r,} ignoring the {goto slashed null} character at the end.
  This is not necessarily the same as the number of {goto char {i char}0's} in
  {i r,} which is obtained by calling {goto length {i length.}}}

{label devar}
{left {b 7.3.54. {i devar.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i devar}
  like this.}

{narrow{orson
devar :−
 (alt
  (form (type mut r) type mut:
    r),
  (gen (type mut r)
    form (type var r) type mut:
     r))}}

{justify
  If {i r} {goto transform transforms} to a {goto vartype variable} {goto type}
  {b var}\ {i t,} then the {goto call} {i devar}({i r}) transforms to the type
  {i t.}
  If {i r} transforms to an {goto object execution} type, but not a variable
  type, then {i devar}({i r}) transforms to {i r} instead.}

{label enum}
{left {b 7.3.55. {i enum.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i enum}
  like this.}

{narrow{orson
enum :−
 (alt
  (form () foj:
   (form () inj:
     ?enum(0, high(int), 1))),
  (form (inj e) foj:
   (form () inj:
     ?enum(0, e − 1, 1))),
  (form (inj b, inj e) foj:
   (form () inj:
     ?enum(b, e, 1))),
  (form (inj b, inj e, inj s) foj:
   (form () inj:
     ?enum(b, e, s))))}}

{justify
  The higher-order form {i enum} simulates the {i enumerated types} of
  programming languages like C {goto ker1988 {c [ker 1988]}} and Pascal
  {goto jen1974 {c [jen 1974].}}
  Suppose that {i b,} {i e,} and {i s} all {goto transform} to
  {goto int integer} {goto constant constants.}
  Then the {goto call} {i enum}({i b,}\ {i e,}\ {i s}) transforms to a new form
  with no parameters.
  Each call to the new form transforms to the next integer constant in a
  series.
  The first time it is called, it transforms to {i b.}
  The second time, it transforms to {i b}\ +\ {i s,} and the third time, it
  transforms to {i b}\ +\ {i s}\ +\ {i s,} etc.
  For example, the following {goto withclause equates} bind the plain names
  {i sunday} through {i saturday} to 0 through 6, respectively.}

{narrow
 {layout
  {row
   {left {i makeDay}}
   {center \ :−\ }
   {left {i enum}(0, 6, 1)}}
  {row
   {left {i sunday}}
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i monday}}
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i tuesday}}
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i wednesday}\ }
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i thursday}}
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i friday}}
   {center \ :−\ }
   {left {i makeDay}()}}
  {row
   {left {i saturday}}
   {center \ :−\ }
   {left {i makeDay}()}}}}

{justify
  It is an {goto errors error} if {i b,} {i e,} and {i s} do not all transform
  to integer constants.
  It is also an error if a call to the new form would transform to an integer
  constant that is not between {i b} and {i e.}

  The call {i enum}() specifies a series of integer constants whose lower bound
  is 0, whose upper bound is the most positive integer that can be represented
  as an {goto int {i int,}} and whose increment is 1.
  The call {i enum}({i e}) specifies a series whose lower bound is 0, whose
  upper bound is {i e}\ −\ 1, and whose increment is 1.
  The call {i enum}({i b,}\ {i e}) specifies a series whose lower bound is
  {i b,} whose upper bound is {i e,} and whose increment is 1.
  As a result, the call to {i enum} in the example could have been written as
  {i enum}(), as {i enum}(7), or as {i enum}(0,\ 6).}

{label error}
{left {b 7.3.56. {i error} and {i goat.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} names
  {i error} and {i goat} like this.}

{narrow{orson
error :−
 (alt
  (form (inj l) void:
    ?err(l)),
  (form (inj l, obj r) obj:
    ?symErr(sym, l) ; r),
  (form (list l, inj r) void:
    ?listErr(l, r)),
  (form (type sym l, inj r) void:
    ?symErr(l, r)),
  (form (list l, inj m, obj r) obj:
    ?listErr(l, m) ; r),
  (form (type sym l, inj m, obj r) obj:
    ?symErr(l, m) ; r))

goat :−
 (form () list:
   ?listGoat())}}

{justify
  The forms {i error} and {i goat} report {goto errors} that occur during
  {goto transform transformation,} and are described in the next few sections.
  These forms might be replaced or modified in future versions of Orson.}

{label errconst}
{left {b 7.3.56.1. Error constants.}}

{justify
  Orson represents {goto transform transformation} {goto errors} as
  {goto unspecified} nonnegative {goto int integer} {goto constant constants.}
  The standard {goto prelude} {goto bind binds} several {goto quoted} names to
  these constants.
  This Report shows the constants as being created by a {goto hook hook.}}

{narrow
 {layout
  {row
   {left {i inj} {i "}cannot close{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}cannot open{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}constant expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}division by zero{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}error number expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}exe expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}expression has unexpected type{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}foj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}internal error{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}internal limit exceeded{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}joker type expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}met expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}method has unexpected type{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}mut expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}negative inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}non joker type expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}non nil pointer expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}non null pointer type expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}non negative inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}non positive inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}nonzero inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}out of range{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}positive inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}too few elements{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}too many elements{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}transformation halted{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type exe expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type has no base type{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type mut expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type obj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type size too large{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}type type obj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}unexpected element{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}unexpected object{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}version does not match{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}
  {row
   {left {i inj} {i "}zero inj expression expected{i "}}
   {center \ :−\ }
   {right ?{i intErr}()}}}}

{justify
  Although all the error constants are nonnegative, nothing else should be
  assumed about them or their {goto type types.}
  Two or more error constants might even be equal.
  The form {goto iserror {i isError}} tests if an integer is an error constant.
  Error constants are not related to the {goto except exceptions} with which
  the form {goto catchclause {i throw}} is called.
  Although an error constant might be equal to an exception, this is only a
  coincidence, and correct Orson programs should not rely on it.}

{label errpos}
{left {b 7.3.56.2. Error positions.}}

{justify
  {goto list Lists} record the positions in a program where their elements were
  {goto transform transformed,} so they can be used to report where
  {goto errors} occurred during transformation.
  The {i k}th {goto list tail} of a nonempty list records the position
  associated with the element at index {i k.}
  The form {goto {i error}} reports an error at the position recorded in a
  list.

  Suppose that {i l} transforms to a list, and that {i r} transforms to an
  {goto int integer} {goto constant} which represents an {goto errconst error.}
  Then the {goto call} {i error}({i l,}\ {i r}) reports that the error {i r}
  occurred at the position recorded in {i l,} then transforms to
  {goto void {i skip.}}
  It is an error if {i l} transforms to the empty list, if {i r} does not
  transform to an integer constant, or if {i r} transforms to an integer
  constant that does not represent an error.

  Similarly, suppose that {i r} transforms to a list, that {i m} transforms to
  an integer constant which represents an error, and that {i r} transforms to
  an {goto expression expression.}
  Then the call {i error}({i l,}\ {i m,}\ {i r}) is equivalent to the
  {goto subsequence} ({i error}({i l,}\ {i m})\ ;\ {i r}).

  For example, a call to the form {i add} accepts a list of integer constants
  {i r,} and transforms to the {goto plus sum} of those constants.
  If {i add} finds an element in {i r} that is not an integer constant, then it
  calls {i error} to report an error.}

{narrow{orson
add :−
 (form (list r) inj:
  (if isEmpty(r)
   then 0
   else if isInt(car(r))
        then car(r) + add(cdr(r))
        else error(r, "constant expected")
             add(cdr(r))))}}

{justify
  After reporting the erroneous element, {i add} skips it and goes on to
  compute the sum of the remaining elements.
  When possible, forms should recover from errors in a similar way, so that
  transformation can continue.}

{label scapegoat}
{left {b 7.3.56.3. Scapegoat lists.}}

{justify
  Most form arguments are not elements of {goto list lists:} parameter
  {goto nametoken names} are {goto bind bound} to them instead.
  {goto errors Errors} in these arguments may be reported by using a
  {i scapegoat list.}
  It contains the positions of arguments that are to be blamed for errors.

  The {goto call} {i goat}() {goto transform transforms} to a scapegoat list.
  It {goto must} not appear outside the body of a form.
  Suppose that {i goat} is called in the body of a form {i f} whose parameter
  names are {i n}'s.
  Then the call transforms to a scapegoat list that is equivalent to this
  {goto listclause list} clause.}

{narrow
 {left
  (: {i sym,} ${i n}{- 1}, ${i n}{- 2} ..., ${i n}{-i k})}}

{justify
  The first element of a scapegoat list is always the {goto joker} {goto type}
  {goto sym {i sym.}}
  The remaining elements are zero or more {goto symbol} types, whose names are
  {i f}'s parameter names.
  If a parameter name is {goto missing missing,} then {i sym} appears in its
  place.
  {goto genclause Generic} names do not appear as symbol types in the list.}

{justify
  {b Positions as tails.}
  The position of {i f}'s call is recorded in the zeroth {goto list tail} of
  the scapegoat list, whose {goto {i car}} is {i sym.}
  As a result, if {i e} transforms to an {goto int integer} constant that
  represents an {goto errconst error,} then the call
  {i error}({i goat}(),\ {i e}) reports that the entire call to {i f} is to be
  blamed for {i e.}

  More often, however, the error should not be blamed on the call, but on one
  or more of its arguments.
  The position of the {i k}th argument is recorded in the scapegoat list's
  {i k}th tail.
  As a result, the {i k}th argument can be blamed by the following call to
  {i error,} in which the form {goto {i cdr}} is called on the scapegoat list
  {i k} times.}

{narrow
 {layout
  {row
   {left {i error}(}
   {left {i cdr}}
   {left ({i cdr}(\ ...\ }
   {left {i cdr}}
   {left ({i goat}())\ ...\ )), {i e})}}
  {row
   {left \ }
   {left │←}
   {center {i k}}
   {right →│}
   {left \ }}}}

{justify
  For example, suppose that {i n} and {i d} both transform to integer
  constants.
  Then the call {i divide}({i n,}\ {i d}) transforms to an integer constant
  that is the quotient of {i n} and {i d.}
  It is an {goto errors error} if {i n} and {i d} are not both constants, or
  if {i d} is the constant 0.}

{narrow{orson
divide :−
 (form (inj n, inj d) inj:
  (with
    inj n' :−
     (if isInt(n)
      then n
      else error(cdr(goat()), "constant expected", 0))
    inj d' :−
     (if isInt(d)
      then (if d = 0
            then error(cdr(cdr(goat())), "division by zero", 1)
            else d)
      else error(cdr(cdr(goat())), "constant expected", 1))
   do n' / d'))}}

{justify
  A call to {i divide} recovers from errors by transforming to an
  {goto unspecified} integer constant so that transformation can continue.

  The form {i error} can also be called without a scapegoat list.
  Suppose that {i l} transforms to an integer constant which represents an
  error.
  Then the call {i error}({i l}) is equivalent to the call
  {i error}({i goat}(),\ {i l}), and the call {i error}({i l,}\ {i r}) is
  equivalent to the {goto subsequence}
  ({i error}({i goat}(),\ {i l})\ ;\ {i r}).}

{justify
  {b Positions as slots.}
  The {goto dot} form {i "}.{i "} is often easier to use with scapegoat lists
  than {i cdr.}
  The call {i "}.{i "}({i goat}(),\ ${i n}) transforms to the first tail of a
  scapegoat list whose {i car} is the symbol type ${i n.}
  It is usually {goto abbreviate abbreviated} as {i goat}().{i n.}
  The tail records the position of the argument that is to be blamed for errors
  in the parameter {i n.}
  As a result, {i divide} could also be written like this.}

{narrow{orson
divide :−
 (form (inj n, inj d) inj:
  (with
    inj n' :−
     (if isInt(n)
      then n
      else error(goat().n, "constant expected", 0))
    inj d' :−
     (if isInt(d)
      then (if d = 0
            then error(goat().d, "division by zero", 1)
            else d)
      else error(goat().d, "constant expected", 1))
   do n' / d'))}}

{justify
  {b Positions as names.}
  Finally, the form {i error} can be called with a symbol type instead of a
  scapegoat list.
  Suppose that {i l} transforms to a symbol type, and that {i m} transforms to
  an integer constant which represents an error.
  Then the call {i error}({i l,}\ {i m}) is equivalent to the call
  {i error}({i "}.{i "}({i goat}(),\ {i l}),\ {i m}), and the call
  {i error}({i l,}\ {i m,}\ {i r}) is equivalent to the subsequence
  ({i error}({i "}.{i "}({i goat}(),\ {i l}),\ {i m})\ ;\ {i r}).
  Using these forms, {i divide} can be rewritten without explicitly calling
  {i goat} at all, like this.}

{narrow{orson
divide :−
 (form (inj n, inj d) inj:
  (with
    inj n' :−
     (if isInt(n)
      then n
      else error($n, "constant expected", 0))
    inj d' :−
     (if isInt(d)
      then (if d = 0
            then error($d, "division by zero", 1)
            else d)
      else error($d, "constant expected", 1))
   do n' / d'))}}

{justify
  Calling {i goat} explicitly is still necessary in some situations.
  For example, one form might call another form to report its errors.
  The first form might then pass its scapegoat list to the second form as an
  argument.}

{label except}
{left {b 7.3.57. {i except.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i except} like this.}

{narrow{orson
except :− enum(1, high(int))}}

{justify
  The form {i except} is created by {goto call calling} the higher-order form
  {goto enum {i enum.}}
  Each {goto call} to {i except} {goto transform transforms} to the next
  {goto int integer} {goto constant} in a series.
  The first time it is called, it transforms to 1.
  The next time, it transforms to 2, then 3, etc., ending with the
  {goto high largest} integer that can be represented as an
  {goto int {i int.}}
  It is an {goto errors error} to call {i except} after the series has ended.

  The form {i except} should be used to create the integer
  {goto constant constants} on which the form {goto catchclause {i throw}} will
  be called.
  These constants are informally called {i exceptions.}
  Each exception represents a reason for the unusual termination of a
  {goto catchclause {i catch}} clause.
  Exceptions are not related to the integer constants that the form
  {goto {i error}} uses to report transformation {goto errconst errors.}
  Although an exception might be equal to an error constant, this is only a
  coincidence, and correct Orson programs should not rely on it.}

{label exit}
{left {b 7.3.58. {i exit.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i exit}
  like this.}

{narrow{orson
exit :−
 (alt
  (form () void:
    exit(0)),
  (form (int r) void:
    ?exit(r)))}}

{justify
  Suppose that {i r} {goto evaluate evaluates} to an {goto int integer.}
  Then the {goto call} {i exit}({i r}) terminates the {goto execute execution}
  of the current program and sends {i r} to the operating system, which handles
  it in an {goto unspecified} way.
  In the Unix operating system, 0 indicates that a program terminated normally,
  and a nonzero integer indicates why it terminated abnormally
  {goto rit1974 {c [rit 1974].}} 
  (The call {i exit}() is equivalent to {i exit}(0).)
  If the program does not run under an operating system, then calling {i exit}
  is {goto undefined undefined.}

  During {goto transform transformation,} a call to {i exit} is treated as if
  it will evaluate to {goto void {i skip.}}
  (It is treated differently if it appears in an {goto ifclause {i if}}
  clause.)
  However, the call actually evaluates to no {goto object object,} because it
  always terminates the program in which it appears.}

{label flatten}
{left {b 7.3.59. {i flatten.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i flatten} like this.}

{narrow{orson
flatten :−
 (form (list r) list:
  (with
    flattening :−
     (alt
      (form (list r) list:
       (if isEmpty(r)
        then (:)
        else conc(flattening(car(r)), flattening(cdr(r))))),
      (form (obj r) list:
       (: r)))
   do flattening(r)))}}

{justify
  Suppose that {i r} {goto transform transforms} to a {goto list list.}
  Then the {goto call} {i flatten}({i r}) transforms to a {i flattened} version
  of {i r,} obtained by deleting each inner `(:' and its matching ')' from
  among {i r}'s elements.
  For example, flattening the {goto listclause list}
  (:\ (:\ {i a,}\ {i b}),\ (:\ (:\ {i c}),\ {i d})) results in a new list
  (:\ {i a,}\ {i b,}\ {i c,}\ {i d}).}

{label halt}
{left {b 7.3.60. {i halt.}}}

{justify
  The standard {i prelude} {goto bind binds} the {goto plain} name {i halt}
  like this.}

{narrow{orson
halt :−
 (form () void:
   ?halt())}}

{justify
  The {goto call} {i halt}() terminates the {goto transform transformation} of
  the current program, preventing its later {goto execute execution.}
  The call apparently transforms to {goto void {i skip,}} but it actually
  transforms to nothing, because it always terminates the program in which it
  appears.

  If an {goto errors error} occurs, then the form {goto {i error}} should
  usually be called instead of {i halt,} because {i error} lets transformation
  continue.
  The form {i halt} should be called only in response to errors so severe that
  continuing transformation would be pointless.
  Even then, the form {i error} should be called first to report that
  transformation will be terminated.
  For example, the form {goto {i version}} calls {i error} and {i halt} in
  this way.}

{label high}
{left {b 7.3.61. {i high.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i high}
  like this.}

{narrow{orson
high :−
 (alt
  (form (type cha r) cha:
    ?typeHigh(r)),
  (form (type num r) num:
    ?typeHigh(r)),
  (form (type type cha r) type cha:
    ?typeHigh(r)),
  (form (type type inj r) type inj:
    ?typeHigh(r)),
  (form (type type rej r) type rej:
    ?typeHigh(r)))}}

{justify
  {goto call Calls} to the form {i high} {goto transform} to the maximum
  {goto constant} {goto object objects} of certain {goto type types.}
  Calls to a similar form {goto {i low}} transform to the minimum constant
  objects.

  If {i r} transforms to a {goto char character} type, then the {goto call}
  {i high}({i r}) transforms to the character constant of type {i r} with the
  most positive code.
  If {i r} transforms to the {goto joker} type {goto cha {i cha,}} then
  {i high}({i r}) transforms to {q '\\#7FFFFFFF',} the character constant of
  the type {goto char {i char}1} with the most positive code.

  If {i r} transforms to an {goto int integer} type, then {i high}({i r})
  transforms to the most positive integer constant of type {i r.}
  If {i r} transforms to the joker type {goto inj {i inj,}} then
  {i high}({i r}) transforms to the most positive integer constant of the
  largest available integer type.

  If {i r} transforms to a {goto real} type, then {i high}({i r}) transforms to
  the real constant with the largest absolute value, of type {i r.}
  If {i r} transforms to the joker type {goto rej {i rej,}} then
  {i high}({i r}) transforms to the real constant with the largest absolute
  value, of the largest available real type.

  If {i r} transforms to the {goto typetype type} {b type}\ {i cha,} then
  {i high}({i r}) transforms to the type {i char}1, the largest character type.
  If {i r} transforms to the type {b type}\ {i inj,} then {i high}({i r})
  transforms to the largest available integer type.
  If {i r} transforms to the type {b type}\ {i rej,} then {i high}({i r})
  transforms to the largest available real type.}

{label ischar}
{left {b 7.3.62. {i isChar.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isChar} like this.}

{narrow{orson
isChar :−
 (form (obj r) bool:
   ?charCon(r))}}

{justify
  If {i r} {goto transform transforms} to a {goto char character}
  {goto constant constant,} then the {goto call} {i isChar}({i r}) transforms
  to the {goto bool Boolean} constant {goto bool {i true,}} and to the Boolean
  constant {goto bool {i false}} otherwise.}

{label iscotype}
{left {b 7.3.63. {i isCotype} and {i "}⊑{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isCotype} and the {goto quoted} name {i "}⊑{i "} like this.}

{narrow{orson
isCotype :−
 (form (type obj l, type obj r) bool:
   ?typeCotype(l, r))

"⊑" :− isCotype}}

{justify
  Suppose that {i l} and {i r} both {goto transform} to {goto type types.}
  If {i l} is a {goto cotype} of {i r,} then the {goto call}
  {i isCotype}({i l,}\ {i r}) and the {goto comparison} {i l}\ ⊑\ {i r}
  transform to the {goto bool Boolean} {goto constant} {goto bool {i true.}}
  They transform to the Boolean constant {goto bool {i false}} otherwise.}

{label isempty}
{left {b 7.3.64. {i isEmpty.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isEmpty} like this.}

{narrow{orson
isEmpty :−
 (alt
  (form (list r) bool:
    ?listEmpty(r)),
  (form (string r) bool:
   (if isString(r)
    then ?strEmpty(r)
    else r↑ = '\\0')))}}

{justify
  Suppose that {i r} {goto transform transforms} to a {goto list list.}
  If {i r} is an empty list, then the {goto call} {i isEmpty}({i r}) transforms
  to the {goto bool Boolean} {goto constant} {goto bool {i true.}}
  It transforms to the Boolean constant {goto bool {i false}} otherwise.
  This is similar to the function {i null} in the programming language Common
  Lisp {goto ste1990 {c [ste 1990]}} and the function {i null?} in the
  programming language Scheme {goto spe2007 {c [spe 2007].}}

  Suppose that {i r} {goto evaluate evaluates} to a {goto string string.}
  If {i r} is {goto comp lexicographically} equal to the empty string ϵ, then
  {i isEmpty}({i r}) evaluates to {i true.}
  It evaluates to {i false} otherwise.}

{label iserror}
{left {b 7.3.65. {i isError.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isError} like this.}

{narrow{orson
isError :−
 (form (inj r) bool:
   ?intErr(r))}}

{justify
  Suppose that {i r} {goto transform transforms} to an {goto int integer}
  {goto constant constant.}
  Then the {goto call} {i isError}({i r}) transforms to the {goto bool Boolean}
  constant {goto bool {i true}} if {i r} represents a transformation
  {goto errconst error.}
  It transforms to the Boolean constant {goto bool {i false}} otherwise.
  It is an {goto errors error} if {i r} does not transform to a constant.}

{label isint}
{left {b 7.3.66. {i isInt.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i isInt}
  like this.}

{narrow{orson
isInt :−
 (form (obj r) bool:
   ?intCon(r))}}

{justify
  If {i r} {goto transform transforms} to an {goto int integer}
  {goto constant constant,} then the {goto call} {i isInt}({i r}) transforms to
  the {goto bool Boolean} constant {goto bool {i true,}} and to the Boolean
  constant {goto bool {i false}} otherwise.}

{label isjoked}
{left {b 7.3.67. {i isJoked.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isJoked} like this.}

{narrow{orson
isJoked :−
 (form (type obj r) bool:
   ?typeJoked(r))}}

{justify
  Suppose that {i r} {goto transform transforms} to a {goto type type.}
  If {i r} is a {goto joker joker,} or contains one or more jokers as parts,
  then the {goto call} {i isJoked}({i r}) transforms to the {goto bool Boolean}
  {goto constant} {goto bool {i true.}}
  It transforms to the Boolean constant {goto bool {i false}} otherwise.}

{label isnil}
{left {b 7.3.68. {i isNull.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isNull} like this.}

{narrow{orson
isNull :−
 (form (obj r) bool:
   ?nullCon(r))}}

{justify
  If {i r} {goto transform transforms} to the {goto {i null}} {goto constant}
  {goto null {i nil,}} then the {goto call} {i isNull}({i r}) transforms to the
  {goto bool Boolean} constant {goto bool {i true,}} and to the Boolean
  constant {goto bool {i false}} otherwise.}

{label isreal}
{left {b 7.3.69. {i isReal.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isReal} like this.}

{narrow{orson
isReal :−
 (form (obj r) bool:
   ?realCon(r))}}

{justify
  If {i r} {goto transform transforms} to a {goto real}
  {goto constant constant,} then the {goto call} {i isReal}({i r}) transforms
  to the {goto bool Boolean} constant {goto bool {i true,}} and to the Boolean
  constant {goto bool {i false}} otherwise.}

{label isskol}
{left {b 7.3.70. {i isSkolem.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isSkolem} like this.}

{narrow{orson
isSkolem :−
 (form (type obj r) bool:
   ?typeSko(r))}}

{justify
  Suppose that {i r} {goto transform transforms} to a {goto type type.}
  If {i r} is a {goto skolem Skolem} type, then the {goto call}
  {i isSkolem}({i r}) transforms to the {goto bool Boolean} {goto constant}
  {goto bool {i true.}}
  It transforms to the Boolean constant {goto bool {i false}} otherwise.}

{label isstring}
{left {b 7.3.71. {i isString.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isString} like this.}

{narrow{orson
isString :−
 (form (obj r) bool:
   ?strCon(r))}}

{justify
  If {i r} {goto transform transforms} to a {goto string}
  {goto constant constant,} then the {goto call} {i isString}({i r}) transforms
  to the {goto bool Boolean} constant {goto bool {i true,}} and to the Boolean
  constant {goto bool {i false}} otherwise.}

{label issubsumed}
{left {b 7.3.72. {i isSubsumed} and {i "}≼{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isSubsumed} and the {goto quoted} name {i "}≼{i "} like this.}

{narrow{orson
isSubsumed :−
 (form (type foj l, type foj r) bool:
   ?typeSubsume(l, r))

"≼" :− isSubsumed}}

{justify
  Suppose that {i l} and {i r} both {goto transform} to {goto foj form} types.
  Then the {goto call} {i isSubsumed}({i l,}\ {i r}) and the {goto comparison}
  {i l}\ ≼\ {i r} transform to the {goto bool Boolean} {goto constant}
  {goto bool {i true}} if a form of type {i l} is {goto subsume subsumed} by a
  form of type {i r.}
  They transform to the Boolean constant {goto bool {i false}} otherwise.}

{label issubtype}
{left {b 7.3.73. {i isSubtype} and {i "}⊆{i ".}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i isSubtype} and the {goto quoted} name {i "}⊆{i "} like this.}

{narrow{orson
isSubtype :−
 (form (type obj l, type obj r) bool:
   ?typeSubtype(l, r))

"⊆" :− isSubtype}}

{justify
  Suppose that {i l} and {i r} both {goto transform} to {goto type types.}
  Then the {goto call} {i isSubtype}({i l,}\ {i r}) and the {goto comparison}
  {i l}\ ⊆\ {i r} transform to the {goto bool Boolean} {goto constant}
  {goto bool {i true}} if {i l} is a {goto subtype} of {i r.}
  They transform to the Boolean constant {goto bool {i false}} otherwise.}

{label length}
{left {b 7.3.74. {i length.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i length} like this.}

{narrow{orson
length :−
 (alt
  (form (type [] exe r) inj:
    ?typeLen(r)),
  (gen (type [] exe r)
    form (type var r) inj:
     ?typeLen(r)),
  (form ([] exe r) inj:
    ?typeLen(type r)),
  (form (list r) inj:
    ?listLen(r)),
  (form (string r) inj:
   (if isString(r)
    then ?strLength(r)
    else (with
           var int l :− 0
           var string r :− (past r)
          do (while r↑
              do l += 1
                 r += 1)
             l))))}}

{justify
  Suppose that {i r} {goto transform transforms} to an {goto prebracket array}
  {goto type} [{i k}]\ {i t} or to an array {goto vartype variable} type
  {b var}\ [{i k}]\ {i t.}
  Then the {goto call} {i length}({i r}) transforms to the nonnegative
  {goto int integer} {goto constant} {i k,} the length of the array described
  by the type.

  Suppose that {i r} transforms to an {goto expression} with an array type.
  Then {i length}({i r}) transforms to the length of that type.

  Suppose that {i r} transforms to a {goto list list.}
  Then {i length}({i r}) transforms to a nonnegative integer constant that is
  the number of elements in {i r.}
  This is similar to the function {i length} in the programming languages
  Common Lisp {goto ste1990 {c [ste 1990]}} and Scheme
  {goto spe2007 {c [spe 2007].}}

  Suppose that {i r} {goto evaluate evaluates} to a {goto string string.}
  Then {i length}({i r}) evaluates to a nonnegative integer that is the number
  of {goto char {i char}0's} in {i r,} ignoring the {goto slashed null}
  character at the end.
  This is not necessarily the same as the number of {goto char {i char}1's}
  encoded in {i r,} which is obtained by calling {goto count {i count.}}
  It is similar to the function {i strlen} in the programming language C
  {goto ker1988 {c [ker 1988].}}}

{label low}
{left {b 7.3.75. {i low.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i low}
  like this.}

{narrow{orson
low :−
 (alt
  (form (type cha r) cha:
    ?typeLow(r)),
  (form (type num r) num:
    ?typeLow(r)),
  (form (type type cha r) type cha:
    ?typeLow(r)),
  (form (type type inj r) type inj:
    ?typeLow(r)),
  (form (type type rej r) type rej:
    ?typeLow(r)))}}

{justify
  {goto call Calls} to the form {i low} {goto transform} to the minimum
  {goto constant} {goto object objects} of certain {goto type types.}
  Calls to a similar form {goto {i high}} transform to the maximum constant
  objects.

  If {i r} transforms to a {goto char character} type, or to the {goto joker}
  type {goto cha {i cha,}} then the call {i low}({i r}) transforms to the
  {goto slashed null} character constant of type {goto char {i char}0.}
  This is the character constant with the least positive code.

  If {i r} transforms to an {goto int integer} type, then {i low}({i r})
  transforms to the most negative integer constant of type {i r.}
  If {i r} transforms to the joker type {goto inj {i inj,}} then {i low}({i r})
  transforms to the most negative integer constant of the largest available
  integer type.

  If {i r} transforms to a {goto real} type, then {i low}({i r}) transforms to
  the real constant with the smallest absolute value, of type {i r.}
  If {i r} transforms to the joker type {goto rej {i rej,}} then {i low}({i r})
  transforms to the real constant with the smallest absolute value, of the
  largest available real type.

  If {i r} transforms to the {goto typetype type} {b type}\ {i cha,} then
  {i low}({i r}) transforms to {i char}0, the smallest character type.
  If {i r} transforms to the type {b type}\ {i inj,} then {i low}({i r})
  transforms to {goto int {i int}0,} the smallest integer type.
  If {i r} transforms to the type {b type}\ {i rej,} then {i low}({i r})
  transforms to the smallest available {goto real} type.}

{label max}
{left {b 7.3.76. {i max.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i max}
  like this.}

{narrow{orson
max :−
 (alt
  (form (inj l, inj r) inj:
   (with
     inj l :− (past l)
     inj r :− (past r)
    do (if l > r
        then l
        else r))),
  (form (rej l, rej r) rej:
   (with
     rej l :− (past l)
     rej r :− (past r)
    do (if l > r
        then l
        else r))))}}

{justify
  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then the {goto call} {i max}({i l,}\ {i r}) evaluates to either {i l} or
  {i r,} whichever is {goto gt greater.}}

{label min}
{left {b 7.3.77. {i min.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i min}
  like this.}

{narrow{orson
min :−
 (alt
  (form (inj l, inj r) inj:
   (with
     inj l :− (past l)
     inj r :− (past r)
    do (if l < r
        then l
        else r))),
  (form (rej l, rej r) rej:
   (with
     rej l :− (past l)
     rej r :− (past r)
    do (if l < r
        then l
        else r))))}}

{justify
  Suppose that {i l} and {i r} both evaluate to {goto int integers} or both
  evaluate to {goto real reals.}
  Then the {goto call} {i min}({i l,}\ {i r}) evaluates to either {i l} or
  {i r,} whichever is {goto lt lesser.}}

{label offset}
{left {b 7.3.78. {i offset.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i offset} like this.}

{narrow{orson
offset :−
 (alt
  (gen (type tup l)
    form (type var l, type sym r) inj:
     ?typeOffset(l, r)),
  (form (tup l, type sym r) inj:
    ?typeOffset(type l, r)),
  (form (type tup l, type sym r) inj:
    ?typeOffset(l, r)))}}

{justify
  Suppose that a {goto tupleclause tuple} resides at an address {i a} in
  memory, and that it has a slot whose {goto nametoken name} is {i n.}
  Then the slot resides at the address {i a}\ +\ {i o} in memory, where {i o}
  is a nonnegative {goto int integer} {goto constant} called the {i offset} of
  {i n.}
  A {goto call} to the {goto altclause alternate} form {i offset}
  {goto transform transforms} to the offset of a slot in a tuple or a tuple
  {goto type type.}

  Suppose that {i l} transforms to a tuple type with a slot {i n,} and that
  {i r} transforms to the {goto symbol} type ${i n.}
  Then the {goto call} {i offset}({i l,}\ {i r}) transforms to the offset of
  the slot named {i n} in {i l.}
  If {i l} transforms to a tuple type with no slot named {i n,} then
  {i offset}({i l,}\ {i r}) transforms to the integer constant −1.

  Suppose that {i l} transforms to a tuple type with at least one slot, and
  that {i r} transforms to the {goto joker} type {goto sym {i sym.}}
  Then {i offset}({i l,}\ {i r}) transforms to the offset of the first slot in
  {i l.}
  If {i l} transforms to a tuple type with no slots, then
  {i offset}({i l,}\ {i r}) transforms to the integer constant −1.

  Suppose that {i l} transforms to a {goto vartype variable} type whose base
  type is a tuple type.
  Then the offset is computed as described above, except that {i l}'s base type
  is used in place of {i l.}

  Suppose that {i l} transforms to an {goto expression} whose type is a tuple
  type.
  Then the offset is computed as described above, except that {i l}'s type is
  used in place of {i l.}}

{label refs}
{left {b 7.3.79. {i refs.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i refs}
  like this.}

{narrow{orson
refs :−
 (gen (type tup t)
   gen (type t b)
    form (type t, type b) foj:
     (form (form (row b) obj body) void:
       ?refs(body, t, b)))}}

{justify
  Some Orson programs {goto call} an {i allocator} form to request
  {goto tupleclause tuples} from a pool of available memory called the
  {i heap.}
  Each call takes a tuple {goto type} without {goto joker jokers} as its
  argument.
  It allocates a tuple of this type from the heap, then returns a
  {goto pointer} that references the tuple.
  After the program is finished with the tuple, it calls a {i deallocator}
  {goto call method} on the pointer.
  This call sends the memory used by the tuple back to the heap, so it can be
  reused by later calls to the allocator form.

  Other programs use a {i garbage collector} {goto jon1997 {c [jon 1997]}}
  instead of a deallocator method.
  The garbage collector periodically visits each tuple that was allocated from
  the heap.
  If it visits a tuple that is no longer referenced by any pointer, then it
  automatically deallocates the tuple.

  Using a garbage collector might be safer than using a deallocator method,
  because it never mistakenly deallocates a tuple while a program is still
  using it.
  However, a garbage collector requires a loop that visits each tuple which
  will survive garbage collection without being deallocated.
  The {goto forclause iterator} form {i refs} helps implement such a loop.}

{justify
  {b Base pointers.}
  A tuple can survive garbage collection in two ways.
  First, it can be referenced by a pointer that is part of a tuple which has
  already survived garbage collection.
  Second, it can be referenced by a special {i base pointer.}
  A {goto {i ref}} pointer {i p} is a base pointer if one or more of the
  following are true.}

{bullet
 {justify
   An {goto execute executing} {goto expression} uses a register or temporary
   memory location to store {i p.}}
 {justify
   An executing {goto procclause procedure} {goto bind binds} a parameter
   {goto nametoken name} to {i p.}}
 {justify
   An executing procedure binds a parameter name to a {goto vartype variable}
   whose value is {i p.}}
 {justify
   An {goto withclause equate} in an executing {goto withclause {i with}}
   clause binds a name to {i p.}}
 {justify
   An equate in an executing {i with} clause binds a name to a variable whose
   value is {i p.}}
 {justify
   An equate in an executing {goto progclause {i prog}} clause binds a name to
   {i p.}}
 {justify
   An equate in an executing {i prog} clause binds a name to a variable whose
   value is {i p.}}}

{justify
  Only {i ref} pointers can be base pointers.
  A {goto {i null}} pointer cannot be a base pointer because it cannot
  reference a tuple.
  A {goto {i row}} pointer cannot be a base pointer because it might have been
  obtained by an {goto at enreferencer,} or by pointer
  {goto pointer arithmetic,} and so might not reference a tuple from the heap.
  As a result, {i row} pointers can reference tuples that should not be visited
  by the garbage collector, like those used internally by the garbage collector
  itself.}

{justify
  {b Visiting tuples.}
  The iterator {i refs} visits all base pointers of a given type.
  Suppose that {i t} {goto transform transforms} to a tuple type, which may
  contain jokers.
  Also suppose that {i b} transforms to a tuple type, which {goto must} not
  contain jokers, but is a {goto subtype} of {i t.}
  Then the call {i refs}({i t,}\ {i b}) transforms to an iterator that is used
  in a {goto forclause {i for}} clause like this.}

{narrow{orson
(for row b q in refs(t, b) do s)}}

{justify
  The iterator starts by visiting the first base pointer of type
  {b ref}\ {i t.}
  It {goto postbrace casts} that pointer to the type {b row}\ {i b,} binds the
  name {i q} to the result, and executes the expression {i s.}
  The pointer {i q} is assumed to reference a tuple in a network of tuples
  that are linked together by their pointer slots.
  Executing {i s} should traverse this network, visiting each of its tuples,
  starting with the one referenced by {i q.}

  When {i s} finishes executing, the iterator goes on to visit the next base
  pointer of type {b ref}\ {i t} in the same way, and the next one after that,
  etc.
  It visits base pointers in an {goto unspecified} order, and it may visit the
  same base pointer many times.
  After it has visited each base pointer at least once, the iterator terminates
  and returns {goto void {i skip.}}
  The expression {i s} has then visited all tuples that will survive garbage
  collection.}

{justify
  {b Restrictions.}
  After {i refs}({i t,}\ {i b}) is transformed, Orson might change how it
  represents base pointers internally.
  To simplify the change, Orson restricts how {i refs} can be called.
  If {i refs} is called more than once in a program, then the type {i t} must
  be the same in every call.
  (The type {i b} may differ between calls.)
  As a result, Orson need not change its representation of base pointers more
  than once in a program.

  Orson also restricts which base pointers {i refs} will visit.
  Suppose that π is the first {i prog} clause in which {i refs} is called.
  Then {i refs} will visit only base pointers created during the execution of
  {i prog} clauses that follow π.
  It will not visit those created during the execution of {i prog} clauses that
   precede π, nor will it visit those created during the execution of π itself.
  As a result, Orson need not change its representation of base pointers
  partway through a {i prog} clause.

  This second restriction affects methods defined by π, and by the {i prog}
  clauses that precede it.
  When these methods are called, any base pointers they create will not be
  visited by {i refs.}
  This is because the methods use the representation for base pointers that
  was in effect when they were defined.}

{label rethrow}
{left {b 7.3.80. {i rethrow.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i rethrow} to a form that is discussed along with
  {goto catchclause {i catch}} clauses.}

{label size}
{left {b 7.3.81. {i size.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i size}
  like this.}

{narrow{orson
size :−
 (alt
  (form (exe r) inj:
    size(type r)),
  (form (type exe r) inj:
    ?typeSize(r)),
  (form (obj) inj:
    −1))}}

{justify
  If {i r} {goto transform transforms} to a {goto object execution} {goto type}
  without {goto joker jokers,} then the {goto call} {i size}({i r}) transforms
  to a nonnegative {goto int integer} {goto constant} that is the
  {goto typesize size} of {i r} in bytes.
  If {i r} transforms to an {goto expression} or an {goto object instance} that
  has an execution type, then {i size}({i r}) transforms to the size of its
  type.
  Otherwise, {i size}({i r}) transforms to the integer constant −1.
  The form {i size} is similar to the {i sizeof} operator in the programming
  language C {goto ker1988 {c [ker 1988].}}}

{label slot}
{left {b 7.3.82. {i slot.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i slot}
  like this.}

{narrow{orson
slot :−
 (form (type exe l, type sym r) type tup:
   ?tuples(l, r))}}

{justify
  Suppose that {i l} {goto transform transforms} to an {goto object execution}
  {goto type type,} and that {i r} transforms to a {goto symbol} type.
  Then the {goto call} {i slot}({i l,}\ {i r}) transforms to a {goto joker}
  type called a {i slot type.}
  It describes a {goto tupleclause tuple} with a slot whose type is a
  {goto subtype} of {i l,} and whose name matches {i r,} as in
  {goto rule rules} {b 76} and {b 77.}}

{narrow
 {label rule76}
 {over
  {center
   ({b tuple} {i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) ⊆ {i slot}({i T,} {i N})}
  {left \ {b 76}}
  {center
   {i t}{- 1} ⊆ {i T,} ${i n}{- 1} ⊆ {i N}}}

 {label rule77}
 {over
  {center
   ({b tuple} {i t}{- 1} {i n}{- 1}, {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) ⊆ {i slot}({i T,} {i N})}
  {left \ {b 77}}
  {center
   ({b tuple} {i t}{- 2} {i n}{- 2} ..., {i t}{-i k} {i n}{-i k}) ⊆ {i slot}({i T,} {i N})}}}

{justify
  A {i slot} type can also be a subtype of another {i slot} type, as in rule
  {b 78.}}

{narrow
 {label rule78}
 {over
  {center {i slot}({i t,}\ {i n}) ⊆ {i slot}({i T,}\ {i N})}
  {left \ {b 78}}
  {center {i t} ⊆ {i T,} {i n} ⊆ {i N}}}}

{justify
  The form {i slot} is primarily intended for use by the {goto dot} form
  {i "}.{i "} that obtains a slot from a tuple.
  However, it might also be used with the joker types {goto {i exe}} and
  {goto sym {i sym.}}
  The call {i slot}({i t,}\ {i sym}) transforms to a joker that describes a
  tuple type with at least one slot whose type is a subtype of {i t.}
  The call {i slot}({i exe,}\ {i sym}) transforms to a joker that describes a
  tuple type with at least one slot.}

{label sort}
{left {b 7.3.83. {i sort.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i sort}
  like this.}

{narrow{orson
sort :−
 (form (form (obj, obj) bool "≺", list u) list:
  (with
    sorting :−
     (form (list u) list:
      (if isEmpty(u) ∨ isEmpty(cdr(u))
       then u
       else (with inj k :− length(u) / 2
             do partitioning((:), u[k], (:), deleting(u, k)))))
    partitioning :−
     (form (list l, obj m, list r, list u) list:
      (if isEmpty(u)
       then conc(sorting(l), cons(m, sorting(r)))
       else (with bool t :− car(u) ≺ m
             do (if isInt(t) ∧ t
                 then partitioning(cons(car(u), l), m, r, cdr(u))
                 else partitioning(l, m, cons(car(u), r), cdr(u))))))
    deleting :−
     (form (list u, inj k) list:
      (if k = 0
       then cdr(u)
       else cons(car(u), deleting(cdr(u), k − 1))))
   do sorting(u)))}}

{justify
  Suppose that {i l} {goto transform transforms} to a form which implements a
  total ordering on its two arguments, of any {goto type types.}
  Also suppose that {i r} transforms to a {goto list list.}
  Then the {goto call} {i sort}({i l,}\ {i r}) transforms to a new list whose
  elements are those of {i r,} sorted into nondecreasing order by {i l.}
  Sorting is not necessarily stable.
  The form {i sort} is similar to the function of the same name in the
  programming language Common Lisp {goto ste1990 {c [ste 1990].}}

  The form {i sort} calls {i l} as few times as possible.
  Each call to {i l} transforms to the {goto bool Boolean} {goto constant}
  {goto bool {i true}} if its first argument is less than its second in the
  total ordering, and to the Boolean constant {goto bool {i false}} otherwise.
  If a call to {i l} does not transform to a constant, or if {i l} does not
  implement a total ordering, then the elements of the sorted list appear in an
  {goto unspecified} order.}

{label throw}
{left {b 7.3.84. {i throw.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name {i throw}
  to a form that is discussed along with {goto catchclause {i catch}} clauses.}

{label thrown}
{left {b 7.3.85. {i thrown.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i thrown} to a form that is discussed along with
  {goto catchclause {i catch}} clauses.}

{label version}
{left {b 7.3.86. {i version.}}}

{justify
  The standard {goto prelude} {goto bind binds} the {goto plain} name
  {i version} like this.}

{narrow{orson
version :−
 (alt
  (form () string:
    ?strVer()),
  (form (string r) void:
   (if isString(r)
    then (if r ≠ ?strVer()
          then error($r, "version does not match")
               error("transformation halted")
               halt())
    else error($r, "constant expected")
         error("transformation halted")
         halt())))}}

{justify
  Each version of Orson is uniquely identified by an {goto unspecified} short
  {goto constant} {goto string string.}
  The {goto call} {i version}() {goto transform transforms} to this constant
  string.
  If the identifying string is not available, then {i version}() transforms to
  an {goto string empty} string.

  If {i r} transforms to a constant string that is
  {goto comp lexicographically} equal to the string which identifies
  this version of Orson, then the call {i version}({i r}) transforms to
  {goto void {i skip.}}
  Otherwise, it reports an {goto errors error} and {goto halt terminates} the
  transformation of the program.

  Some programs work only under a specific version of Orson.
  For example, they might use {goto hook hooks} that are not available in all
  versions.
  These programs should call {i version} to make sure they are running under
  the intended version.}

{rule}

{label syntax}
{left {b 8. Syntax.}}

{narrow
 {display
since feeling is first
who pays any attention
to the syntax of things
will never wholly kiss you}
 {right
  {goto eec1965 {c [eec 1965]}}}}

{justify
  This Report uses a {c bnf} grammar {goto nau1963 {c [nau 1963]}} to describe
  the context-free portion of Orson's syntax.
  Nonterminal symbols appear between sharp angle brackets `\ <\ ' and `\ >\ '.
  Terminal symbols appear in bold, italic, or ordinary type.
  A Naur arrow `\ ::=\ ' defines a nonterminal symbol, a bar `|' denotes
  alternation, and juxtaposition denotes concatenation.

  A nonterminal whose name ends in {i char} denotes a character, so that
  <10ary\ char> is a decimal {goto digit digit.}
  A nonterminal whose name is a plural denotes a series, so that
  <10ary\ chars> is a series of decimal digits.
  A nonterminal whose name ends in {i op} denotes an operator, so that
  <sum\ op> is an operator which is part of a sum.
  A nonterminal whose name begins with {i opt} denotes an optional appearance,
  so that <opt\ assignments> is a series of zero or more assignments.}

{label charsyntax}
{left {b 8.1. Characters.}}

{justify
  These productions describe sets of characters that help define
  {goto tokensyntax tokens.}
  Each nonterminal <{i n}ary\ char> denotes a radix-{i n} digit, where {i n}
  is between 2 and 36.
  Only the nonterminals for radixes 2, 10, 16, and 36 are shown.
  The nonterminal <non\ apostrophe\ char> denotes any visible character except
  an {goto apostrophe apostrophe.}
  The nonterminal <non\ quote\ char> denotes any visible character except a
  {goto quote quote.}}

{layout
 {row
  {right <2ary char>}
  {center \ ::=\ }
  {center 0}
  {center |}
  {center 1}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}
 {row
  {right \ }
  {center ⋮}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <10ary char>}
  {center \ ::=\ }
  {center 0}
  {center |}
  {center 1}
  {center |}
  {center 2}
  {center |}
  {center 3}
  {center |}
  {center 4}
  {center |}
  {center 5}
  {center |}
  {center 6}
  {center |}
  {center 7}
  {center |}
  {center 8}
  {center |}
  {center 9}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}
 {row
  {right \ }
  {center ⋮}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <16ary char>}
  {center \ ::=\ }
  {center 0}
  {center |}
  {center 1}
  {center |}
  {center 2}
  {center |}
  {center 3}
  {center |}
  {center 4}
  {center |}
  {center 5}
  {center |}
  {center 6}
  {center |}
  {center 7}
  {center |}
  {center 8}
  {center |}
  {center 9}
  {center |}
  {center A}
  {center |}
  {center B}
  {center |}
  {center C}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center D}
  {center |}
  {center E}
  {center |}
  {center F}
  {center |}
  {center a}
  {center |}
  {center b}
  {center |}
  {center c}
  {center |}
  {center d}
  {center |}
  {center e}
  {center |}
  {center f}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}
 {row
  {right \ }
  {center ⋮}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <36ary char>}
  {center \ ::=\ }
  {center 0}
  {center |}
  {center 1}
  {center |}
  {center 2}
  {center |}
  {center 3}
  {center |}
  {center 4}
  {center |}
  {center 5}
  {center |}
  {center 6}
  {center |}
  {center 7}
  {center |}
  {center 8}
  {center |}
  {center 9}
  {center |}
  {center A}
  {center |}
  {center B}
  {center |}
  {center C}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center D}
  {center |}
  {center E}
  {center |}
  {center F}
  {center |}
  {center G}
  {center |}
  {center H}
  {center |}
  {center I}
  {center |}
  {center J}
  {center |}
  {center K}
  {center |}
  {center L}
  {center |}
  {center M}
  {center |}
  {center N}
  {center |}
  {center O}
  {center |}
  {center P}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center Q}
  {center |}
  {center R}
  {center |}
  {center S}
  {center |}
  {center T}
  {center |}
  {center U}
  {center |}
  {center V}
  {center |}
  {center W}
  {center |}
  {center X}
  {center |}
  {center Y}
  {center |}
  {center Z}
  {center |}
  {center a}
  {center |}
  {center b}
  {center |}
  {center c}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center d}
  {center |}
  {center e}
  {center |}
  {center f}
  {center |}
  {center g}
  {center |}
  {center h}
  {center |}
  {center i}
  {center |}
  {center j}
  {center |}
  {center k}
  {center |}
  {center l}
  {center |}
  {center m}
  {center |}
  {center n}
  {center |}
  {center o}
  {center |}
  {center p}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center q}
  {center |}
  {center r}
  {center |}
  {center s}
  {center |}
  {center t}
  {center |}
  {center u}
  {center |}
  {center v}
  {center |}
  {center w}
  {center |}
  {center x}
  {center |}
  {center y}
  {center |}
  {center z}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <e char>}
  {center \ ::=\ }
  {center E}
  {center |}
  {center e}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <lowercase char>}
  {center \ ::=\ }
  {center {i a}}
  {center |}
  {center {i b}}
  {center |}
  {center {i c}}
  {center |}
  {center {i d}}
  {center |}
  {center {i e}}
  {center |}
  {center {i f}}
  {center |}
  {center {i g}}
  {center |}
  {center {i h}}
  {center |}
  {center {i i}}
  {center |}
  {center {i j}}
  {center |}
  {center {i k}}
  {center |}
  {center {i l}}
  {center |}
  {center {i m}}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center {i n}}
  {center |}
  {center {i o}}
  {center |}
  {center {i p}}
  {center |}
  {center {i q}}
  {center |}
  {center {i r}}
  {center |}
  {center {i s}}
  {center |}
  {center {i t}}
  {center |}
  {center {i u}}
  {center |}
  {center {i v}}
  {center |}
  {center {i w}}
  {center |}
  {center {i x}}
  {center |}
  {center {i y}}
  {center |}
  {center {i z}}
  {center \ }}

 {row
  {right <math char>}
  {center \ ::=\ }
  {center Γ}
  {center |}
  {center Δ}
  {center |}
  {center Θ}
  {center |}
  {center Λ}
  {center |}
  {center Ξ}
  {center |}
  {center Π}
  {center |}
  {center Σ}
  {center |}
  {center ϒ}
  {center |}
  {center Φ}
  {center |}
  {center Ψ}
  {center |}
  {center Ω}
  {center |}
  {center α}
  {center |}
  {center β}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center γ}
  {center |}
  {center δ}
  {center |}
  {center ϵ}
  {center |}
  {center ε}
  {center |}
  {center ζ}
  {center |}
  {center η}
  {center |}
  {center θ}
  {center |}
  {center ϑ}
  {center |}
  {center ι}
  {center |}
  {center κ}
  {center |}
  {center λ}
  {center |}
  {center μ}
  {center |}
  {center ν}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center ξ}
  {center |}
  {center π}
  {center |}
  {center ϖ}
  {center |}
  {center ρ}
  {center |}
  {center ϱ}
  {center |}
  {center σ}
  {center |}
  {center ς}
  {center |}
  {center τ}
  {center |}
  {center υ}
  {center |}
  {center ϕ}
  {center |}
  {center φ}
  {center |}
  {center χ}
  {center |}
  {center ψ}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center ω}
  {center |}
  {center ∀}
  {center |}
  {center ∃}
  {center |}
  {center ∅}
  {center |}
  {center ∞}
  {center |}
  {center ⊥}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <sign char>}
  {center \ ::=\ }
  {center +}
  {center |}
  {center -}
  {center |}
  {center −}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <slashable char>}
  {center \ ::=\ }
  {center {q '}}
  {center |}
  {center 0}
  {center |}
  {center A}
  {center |}
  {center B}
  {center |}
  {center E}
  {center |}
  {center F}
  {center |}
  {center N}
  {center |}
  {center R}
  {center |}
  {center T}
  {center |}
  {center V}
  {center |}
  {center \\}
  {center |}
  {center a}
  {center |}
  {center b}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center e}
  {center |}
  {center f}
  {center |}
  {center n}
  {center |}
  {center r}
  {center |}
  {center t}
  {center |}
  {center v}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <subscript char>}
  {center \ ::=\ }
  {center ₀}
  {center |}
  {center ₁}
  {center |}
  {center ₂}
  {center |}
  {center ₃}
  {center |}
  {center ₄}
  {center |}
  {center ₅}
  {center |}
  {center ₆}
  {center |}
  {center ₇}
  {center |}
  {center ₈}
  {center |}
  {center ₉}
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }
  {center \ }}

 {row
  {right <uppercase char>}
  {center \ ::=\ }
  {center {i A}}
  {center |}
  {center {i B}}
  {center |}
  {center {i C}}
  {center |}
  {center {i D}}
  {center |}
  {center {i E}}
  {center |}
  {center {i F}}
  {center |}
  {center {i G}}
  {center |}
  {center {i H}}
  {center |}
  {center {i I}}
  {center |}
  {center {i J}}
  {center |}
  {center {i K}}
  {center |}
  {center {i L}}
  {center |}
  {center {i M}}
  {center |}}
 {row
  {right \ }
  {center \ }
  {center {i N}}
  {center |}
  {center {i O}}
  {center |}
  {center {i P}}
  {center |}
  {center {i Q}}
  {center |}
  {center {i R}}
  {center |}
  {center {i S}}
  {center |}
  {center {i T}}
  {center |}
  {center {i U}}
  {center |}
  {center {i V}}
  {center |}
  {center {i W}}
  {center |}
  {center {i X}}
  {center |}
  {center {i Y}}
  {center |}
  {center {i Z}}
  {center \ }}}

{label tokensyntax}
{left {b 8.2. Tokens.}}

{justify
  These productions use {goto charsyntax characters} to help describe
  {goto token tokens,} which in turn help describe
  {goto expsyntax expressions} and {goto progsyntax programs.}
  Each nonterminal <{i n}ary\ chars> denotes a series of one or more digits in
  radix {i n,} where {i n} is between 2 and 36.
  Only the nonterminals for radixes 2, 10, 16, and 36 are shown.
  Tokens may be separated by {goto comment comments} and
  {goto token whitespace,} but this is not shown.}

{layout
 {row
  {right <empty>}
  {center \ ::=\ }
  {left \ }}

 {row
  {right <character literal>}
  {center \ ::=\ }
  {left {q '} <character> {q '}}}

 {row
  {right <character>}
  {center \ ::=\ }
  {left <non apostrophe char> | \\ <slashed char>}}

 {row
  {right <slashed char>}
  {center \ ::=\ }
  {left <slashable char> | # <16ary chars> <opt code end>}}

 {row
  {right <opt code end>}
  {center \ ::=\ }
  {left <empty> | \\ _}}

 {row
  {right <name>}
  {center \ ::=\ }
  {left <plain name> | <quoted name> | <secret name>}}

 {row
  {right <plain name>}
  {center \ ::=\ }
  {left <lowercase char> | <math char> | <plain name> <name char>}}

 {row
  {right <name char>}
  {center \ ::=\ }
  {left <10ary char> | <lowercase char> | <math char> |}}
 {row
  {right \ }
  {center \ }
  {left <subscript char> | <uppercase char> | {q '}}}

 {row
  {right <quoted name>}
  {center \ ::=\ }
  {left {i "} <opt quoted chars> {i "}}}

 {row
  {right <opt\ quoted\ chars>}
  {center \ ::=\ }
  {left <empty> | <opt quoted chars> <non quote char>}}

 {row
  {right <secret name>}
  {center \ ::=\ }
  {left <uppercase char> | <secret name> <name char>}}

 {row
  {right <hook>}
  {center \ ::=\ }
  {left ? <plain name>}}

 {row
  {right <integer literal>}
  {center \ ::=\ }
  {left 2 # <2ary chars> ... | 10 # <10ary chars> | ...}}
 {row
  {right \ }
  {center \ }
  {left 16 # <16ary chars> ... | 36 # <36ary chars>}}

 {row
  {right <2ary chars>}
  {center \ ::=\ }
  {left <2ary char> | <2ary chars> <2ary char> | <2ary chars> _}}

 {row
  {right \ }
  {center ⋮}
  {left \ }}

 {row
  {right <10ary chars>}
  {center \ ::=\ }
  {left <10ary char> | <10ary chars> <10ary char> | <10ary chars> _}}

 {row
  {right \ }
  {center ⋮}
  {left \ }}

 {row
  {right <16ary chars>}
  {center \ ::=\ }
  {left <16ary char> | <16ary chars> <16ary char> | <16ary chars> _}}

 {row
  {right \ }
  {center ⋮}
  {left \ }}

 {row
  {right <36ary chars>}
  {center \ ::=\ }
  {left <36ary char> | <36ary chars> <36ary char> | <36ary chars> _}}

 {row
  {right <real literal>}
  {center \ ::=\ }
  {left <10ary chars> . <10ary chars> <opt scale factor>}}

 {row
  {right <opt scale factor>}
  {center \ ::=\ }
  {left <empty> | <e char> <opt sign char> <10ary chars>}}

 {row
  {right <opt sign char>}
  {center \ ::=\ }
  {left <empty> | <sign char>}}

 {row
  {right <string literal>}
  {center \ ::=\ }
  {left {q ' '} <opt string> {q ' '} <opt apostrophe>}}

 {row
  {right <opt string>}
  {center \ ::=\ }
  {left <empty> | <character> <opt string> | {q '} <character> <opt string>}}

 {row
  {right <opt apostrophe>}
  {center \ ::=\ }
  {left <empty> | {q '}}}}

{justify
  A portable {goto pathname} is a kind of string literal that is used along
  with {goto loadclause {i load}} clauses.}

{layout
 {row
  {right <pathname>}
  {center \ ::=\ }
  {left {q ' '} <opt directories> <file> <opt suffix> {q ' '}}}

 {row
  {right <opt directories>}
  {center \ ::=\ }
  {left <empty> | <directories> .}}

 {row
  {right <directories>}
  {center \ ::=\ }
  {left <directory> | <directories> . <directory>}}

 {row
  {right <directory>}
  {center \ ::=\ }
  {left <pathname char> | <directory> <pathname char>}}

 {row
  {right <file>}
  {center \ ::=\ }
  {left <pathname char> | <file> <pathname char>}}

 {row
  {right <opt suffix>}
  {center \ ::=\ }
  {left <empty> | : <suffix>}}

 {row
  {right <suffix>}
  {center \ ::=\ }
  {left <pathname char> | <suffix> <pathname char>}}

 {row
  {right <pathname char>}
  {center \ ::= }
  {left <10ary char> | <lowercase char> | <uppercase char>}}}

{label expsyntax}
{left {b 8.3. Expressions.}}

{justify
  These productions use {goto tokensyntax tokens} to help describe
  expressions.}

{layout
 {row
  {right <sequence>}
  {center \ ::=\ }
  {left <subsequence> | <subsequence> {b also} <subsequence>}}

 {row
  {right <subsequence>}
  {center \ ::=\ }
  {left <assignment> <opt semicolon> | <assignment> ; <subsequence>}}

 {row
  {right <assignment>}
  {center \ ::=\ }
  {left <disjunction> | <disjunction> <assignment op> <disjunction>}}

 {row
  {right <opt semicolon>}
  {center \ ::=\ }
  {left <empty> | ;}}

 {row
  {right <assignment op>}
  {center \ ::=\ }
  {left &= | ⁎= | += | -= | /= | := | <<= | >>= | |= | ~= | ×= | −= |}}
 {row
  {right \ }
  {center \ }
  {left  ∘= | {t ∙}= | ∩= | ∪= | ⊓= | ⊔= | ⊕= | ⊖= | ⊗= | ⊘= | ⊙= }}

 {row
  {right <disjunction>}
  {center \ ::=\ }
  {left <conjunction> | <conjunction> <disjunction op> <disjunction>}}

 {row
  {right <disjunction op>}
  {center \ ::=\ }
  {left {b or} | ∨}}

 {row
  {right <conjunction>}
  {center \ ::=\ }
  {left <comparison> | <comparison> <conjunction op> <conjunction>}}

 {row
  {right <conjunction op>}
  {center \ ::=\ }
  {left {b and} | ∧}}

 {row
  {right <comparison>}
  {center \ ::=\ }
  {left <sum> | <sum> <comparison op> <comparison>}}

 {row
  {right <comparison op>}
  {center \ ::=\ }
  {left < | <= | <> | = | > | >= | ∊ | ∍ | ≠ | ≡ | ≢ | ≤ | ≥ | ≺ | ≻ |}}

 {row
  {right \ }
  {center \ }
  {left ≼ | ≽ | ⊂ | ⊃ | ⊆ | ⊇ | ⊏ | ⊐ | ⊑ | ⊒}}

 {row
  {right <sum>}
  {center \ ::=\ }
  {left <product> | <product> <sum op> <sum>}}

 {row
  {right <sum op>}
  {center \ ::=\ }
  {left + | - | | | ~ | − | ∘ | ∪ | ⊔ | ⊕ | ⊖}}

 {row
  {right <product>}
  {center \ ::=\ }
  {left <term> | <term> <product op> <product>}}

 {row
  {right <product op>}
  {center \ ::=\ }
  {left & | ⁎ | / | << | >> | × | ← | → | {t ∙} | ∩ | ⊓ | ⊗ | ⊘ | ⊙ | {b mod}}}

 {row
  {right <term>}
  {center \ ::=\ }
  {left <unit> | <term op> <term>}}

 {row
  {right <term op>}
  {center \ ::=\ }
  {left + | - | [ <opt arguments> ] | \{ <opt arguments> \} | ~ | ¬ | − |}}
 {row
  {right \ }
  {center \ }
  {left
    ⊕ | ⊖ | <opt gen prefixes> {b form} ( <opt parameters> ) | {b not} |}}
 {row
  {right \ }
  {center \ }
  {left {b proc} ( <opt parameters> ) | {b ref} | {b row} | {b type} |
   {b var}}}

 {row
  {right <opt gen prefixes>}
  {center \ ::=\ }
  {left <empty> | <gen prefix> <opt gen prefixes>}}

 {row
  {right <gen prefix>}
  {center \ ::=\ }
  {left {b gen} ( <gen parameters> )}}

 {row
  {right <unit>}
  {center \ ::=\ }
  {left <character literal> | ( <clause> ) | <hook> | <name> |}}
 {row
  {right \ }
  {center \ }
  {left <integer literal> | <real literal> | <string literal> | <symbol> |}}
 {row
  {right \ }
  {center \ }
  {left <unit> <unit op>}}

 {row
  {right <unit op>}
  {center \ ::=\ }
  {left @ | {q ^} | . <name> | ( <opt arguments> ) | [ <opt arguments> ] |}}
 {row
  {right \ }
  {center \ }
  {left ↑ | ↓ | \{ <opt arguments> \}}}

 {row
  {right <symbol>}
  {center \ ::=\ }
  {left $ <name>}}

 {row
  {right <opt arguments>}
  {center \ ::=\ }
  {left <opt assignments> <opt list clause>}}

 {row
  {right <opt assignments>}
  {center \ ::=\ }
  {left <empty> | <assignments>}}

 {row
  {right <assignments>}
  {center \ ::=\ }
  {left <assignment> | <assignment> , <assignments>}}

 {row
  {right <opt list clause>}
  {center \ ::=\ }
  {left <empty> | <list clause>}}

 {row
  {right <opt parameters>}
  {center \ ::=\ }
  {left <empty> | <parameters>}}

 {row
  {right <parameters>}
  {center \ ::=\ }
  {left <parameter> | <parameter> , <parameters>}}

 {row
  {right <parameter>}
  {center \ ::=\ }
  {left <term> <opt name>}}

 {row
  {right <opt name>}
  {center \ ::=\ }
  {left <empty> | <name>}}

 {row
  {right <gen parameters>}
  {center \ ::=\ }
  {left <gen parameter> | <gen parameter> , <gen parameters>}}

 {row
  {right <gen parameter>}
  {center \ ::=\ }
  {left <term> <name>}}

 {row
  {right <clause>}
  {center \ ::=\ }
  {left <alt clause> | <alts clause> | <case clause> | <catch clause> |}}
 {row
  {right \ }
  {center \ }
  {left <for clause> | <form clause> | <if clause> | <list clause> |}}
 {row
  {right \ }
  {center \ }
  {left <past clause> | <proc clause> | <tuple clause> |}}
 {row
  {right \ }
  {center \ }
  {left <while clause> | <with clause> | <sequence>}}

 {row
  {right <alt clause>}
  {center \ ::=\ }
  {left {b alt} <opt assignments>}}

 {row
  {right <alts clause>}
  {center \ ::=\ }
  {left {b alts} <opt assignments>}}

 {row
  {right <case clause>}
  {center \ ::=\ }
  {left {b case} <sequence> {b of} <opt cases>}}

 {row
  {right <opt cases>}
  {center \ ::=\ }
  {left <empty> | <labeled cases> <opt other cases> <opt semicolon> |}}
 {row
  {right \ }
  {center \ }
  {left <none case> <opt labeled cases> <opt semicolon>}}

 {row
  {right <labeled cases>}
  {center \ ::=\ }
  {left <labeled case> | <labeled case> ; <labeled cases>}}

 {row
  {right <labeled case>}
  {center \ ::=\ }
  {left <assignments> : <assignment>}}

 {row
  {right <opt other cases>}
  {center \ ::=\ }
  {left <empty> | ; <none case> <opt labeled cases>}}

 {row
  {right <none case>}
  {center \ ::=\ }
  {left {b none} : <assignment>}}

 {row
  {right <opt labeled cases>}
  {center \ ::=\ }
  {left <empty> | ; <labeled cases>}}

 {row
  {right <catch clause>}
  {center \ ::=\ }
  {left {b catch} <sequence>}}

 {row
  {right <for clause>}
  {center \ ::=\ }
  {left {b for} <parameters> <opt in> {b do} <sequence> |}}
 {row
  {right \ }
  {center \ }
  {left {b in} <assignments> {b do} <sequence>}}

 {row
  {right <opt in>}
  {center \ ::=\ }
  {left <empty> | {b in} <assignments>}}

 {row
  {right <form clause>}
  {center \ ::=\ }
  {left {b form} ( <opt parameters> ) <term> : <sequence>}}

 {row
  {right <if clause>}
  {center \ ::=\ }
  {left {b if} <sequence> {b then} <sequence> <opt else>}}

 {row
  {right <opt else>}
  {center \ ::=\ }
  {left <empty> | {b else} <if clause> | {b else} <sequence>}}

 {row
  {right <list clause>}
  {center \ ::=\ }
  {left : <opt assignments>}}

 {row
  {right <past clause>}
  {center \ ::=\ }
  {left {b past} <name>}}

 {row
  {right <proc clause>}
  {center \ ::=\ }
  {left {b proc} ( <opt parameters> ) <term> : <sequence>}}

 {row
  {right <tuple clause>}
  {center \ ::=\ }
  {left {b tuple} <opt parameters>}}

 {row
  {right <while clause>}
  {center \ ::=\ }
  {left {b while} <sequence> <opt do>}}

 {row
  {right <opt do>}
  {center \ ::=\ }
  {left <empty> | {b do} <sequence>}}

 {row
  {right <with clause>}
  {center \ ::=\ }
  {left {b with} <opt equates> {b do} <sequence>}}

 {row
  {right <opt equates>}
  {center \ ::=\ }
  {left <empty> | <equates>}}

 {row
  {right <equates>}
  {center \ ::=\ }
  {left <equate> <opt semicolon> | <equate> ; <equates>}}

 {row
  {right <equate>}
  {center \ ::=\ }
  {left <term> <name> | <name> <equate arrow> <assignment> |}}
 {row
  {right \ }
  {center \ }
  {left <term> <name> <equate arrow> <assignment>}}

 {row
  {right <equate arrow>}
  {center \ ::=\ }
  {left :- | :−}}}

{label progsyntax}
{left {b 8.4. Programs.}}

{justify
  These productions use {goto expsyntax expressions} and
  {goto expsyntax equates} to help define programs.}

{layout
 {row
  {right <program>}
  {center \ ::=\ }
  {left <subprogram> <opt semicolon> | <subprogram> ; <program>}}

 {row
  {right <subprogram>}
  {center \ ::=\ }
  {left ( <subprogram clause> )}}

 {row
  {right <subprogram clause>}
  {center \ ::=\ }
  {left <load clause> | <prog clause>}}

 {row
  {right <load clause>}
  {center \ ::=\ }
  {left {b load} <sequence>}}

 {row
  {right <prog clause>}
  {center \ ::=\ }
  {left {b prog} <opt equates>}}}

{label semicolon}
{left {b 8.5. Semicolons.}}

{justify
  Even though {goto symboltoken semicolons} appear in Orson's formal
  {goto syntax syntax,} they almost never appear in real Orson programs.
  This is because if Orson encounters a {goto token newline} where a semicolon
  could legally appear, then it automatically adds a semicolon there
  {goto mid1978 {c [mid 1978].}}
  For example, the {goto procclause procedure} on the left, which does not use
  semicolons, is equivalent to the procedure on the right, which does.}

{layout
 {row
  {left \ \ \ \ }
  {orson
binarySearch :−
 (proc ([k] int keys, int key) int:
  (with
    var int left :− 0
    var int mid
    var int right :− k − 1
   do (while
       (if left > right
        then mid := −1
             false
        else if mid := (left + right) / 2
                key < keys[mid]
             then right := mid − 1
                  true
             else if key > keys[mid]
                  then left := mid + 1
                       true
                  else false))
      mid))}
  {left \ \ \ \ \ \ }
  {orson
binarySearch :−
 (proc ([k] int keys, int key) int:
  (with
    var int left :− 0 ;
    var int mid ;
    var int right :− k − 1 ;
   do (while
       (if left > right ;
        then mid := −1 ;
             false ;
        else if mid := (left + right) / 2 ;
                key < keys[mid] ;
             then right := mid − 1 ;
                  true ;
             else if key > keys[mid] ;
                  then left := mid + 1 ;
                       true ;
                  else false)) ;
      mid)) ;}}}

{justify
  Orson usually adds semicolons only where they are required, or where they
  will do no harm.
  However, care should be taken with {goto expression expressions} that extend
  over many {goto token lines.}
  For example, this {goto assignment} is intended to set a
  {goto vartype variable} {i atoz} to the {goto sum} of {i a} through {i z.}}

{narrow{orson
atoz :=
  a + b + c + d + e + f + g + h + i + j + k + l + m
    + n + o + p + q + r + s + t + u + v + w + x + y + z}}

{justify
  Unfortunately, because a semicolon could legally appear after {i m,} Orson
  treats the assignment as a {goto subsequence subsequence,} as if it had been
  written like this.
  It sets {i atoz} to the sum of {i a} through {i m} only, then
  {goto evaluate evaluates} to the sum of {i n} through {i z.}}

{narrow{orson
atoz := a + b + c + d + e + f + g + h + i + j + k + l + m ;
+ n + o + p + q + r + s + t + u + v + w + x + y + z ;}}

{justify
  The easiest way to avoid this mistake is to never write an assignment that
  extends over multiple lines.
  If writing such an assignment is unavoidable, then each line should end with
  an infix {goto expression operator} to prevent Orson from adding a semicolon
  there.}

{narrow{orson
atoz :=
  a + b + c + d + e + f + g + h + i + j + k + l + m +
    n + o + p + q + r + s + t + u + v + w + x + y + z}}

{rule}

{label reference}
{left {b 9. References.}}

{narrow
 {justify
   [E]very quotation contributes something to the stability or enlargement of
   the language.}
 {right
  {goto joh1755 {c [joh 1755]}}}}

{layout
 {row
  {left
   {label ans1986}
   {c [ans\ 1986]\ \ }}
  {justify
    American National Standards Institute.
    ``American National Standard Code for Information Interchange.''
    {c Ansi} X3.4–1986.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label bel1981}
   {c [bel\ 1981]\ \ }}
  {justify
    Clive Bell.
    {i Art.}
    Perigee Books.
    G. P. Putnam's Sons.
    New York, New York.
    1981.
    Pages 184–185.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label car1997}
   {c [car\ 1997]\ \ }}
  {justify
    Luca Cardelli.
    ``Type Systems.''
    In {i The Handbook of Computer Science and Engineering.}
    Chapter 103.
    {c Crc} Press.
    Cleveland, Ohio.
    1997.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label cha1989}
   {c [cha\ 1989]\ \ }}
  {justify
    Graham Chapman, John Cleese, Terry Gilliam, Eric Idle, Terry Jones,
    Michael Palin.
    {i Monty Python's Flying Circus: All The Words.}
    Volume One.
    Pantheon Books.
    New York, New York.
    1989.
    Pages 153–154.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label dis1969}
   {c [dis\ 1969]\ \ }}
  {justify
    Thomas M. Disch.
    {i Camp Concentration.}
    Doubleday and Company.
    Garden City, New York.
    1969.
    Page 128.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label eec1965}
   {c [eec\ 1965]\ \ }}
  {justify
    E. E. Cummings.
    Untitled.
    In {i A Selection of Poems.}
    Harcourt, Brace, and World.
    New York, New York.
    1965.
    Page 76.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label end1972}
   {c [end\ 1972]\ \ }}
  {justify
    Herbert B. Enderton.
    {i A Mathematical Introduction to Logic.}
    Academic Press.
    New York, New York.
    1972.
    Page 274.}}    

 {row {left \ } {left \ }}

 {row
  {left
   {label gim1976}
   {c [gim\ 1976]\ \ }}
  {justify
    James F. Gimpel.
    {i Algorithms in {c Snobol4.}}
    John Wiley and Sons.
    New York, New York.
    1976.
    Page {i viii.}}}

 {row {left \ } {left \ }}

 {row
  {left
   {label gos1996}
   {c [gos\ 1996]\ \ }}
  {justify
    James Gosling, Bill Joy, Guy Steele.
    {i The Java Language Specification.}
    Addison-Wesley.
    Reading, Massachusetts.
    1996.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label hem1999}
   {c [hem\ 1999]\ \ }}
  {justify
    Robin Hemley.
    ``Sympathy for the Devil: What to Do About Difficult Characters.''
    In {i Creating Fiction.}
    Julie Checkoway, editor.
    Story Press.
    Cincinatti, Ohio.
    1999.
    Page 81.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label hop2007}
   {c [hop\ 2007]\ \ }}
  {justify
    John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman.
    {i Introduction to Automata Theory, Languages, and Computation.}
    Third Edition.
    Pearson Addison Wesley.
    Boston, Massachusetts.
    2007.
    Page 29.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label iee1987}
   {c [iee\ 1987]\ \ }}
  {justify
    Anonymous.
    ``{c Ieee} Standard for Binary Floating Point Arithmetic.''
    {c Ansi/Ieee} Std 754–1985.
    {i {c Acm Sigplan} Notices.}
    Volume 22.
    Number 2.
    February 1987.
    Pages 9–25.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label jen1974}
   {c [jen\ 1974]\ \ }}
  {justify
    Kathleen Jensen, Niklaus Wirth.
    {i {c Pascal} User Manual and Report.}
    Lecture Notes in Computer Science Number 18.
    Springer Verlag.
    Berlin, Germany.
    1974.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label joh1755}
   {c [joh\ 1755]\ \ }}
  {justify
    Samuel Johnson.
    {i Dictionary of the English Language.}
    Preface.
    1755.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label jon1997}
   {c [jon\ 1997]\ \ }}
  {justify
    Richard Jones, Rafael Lins.
    {i Garbage Collection: Algorithms for Automatic Dynamic Memory Management.}
    John Wiley & Sons.
    Chichester, United Kingdom.
    1997.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label ker1988}
   {c [ker\ 1988]\ \ }}
  {justify
    Brian W. Kernighan, Dennis M. Ritchie.
    {i The C Programming Language.}
    Second Edition.
    Prentice-Hall.
    Upper Saddle River, New Jersey.
    1988.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label knu1975}
   {c [knu\ 1975]\ \ }}
  {justify
    Donald E. Knuth.
    {i The Art of Computer Programming.
    Fundamental Algorithms.}
    Second Edition.
    Addison-Wesley.
    Reading, Massachusetts.
    1975.
    Pages 234–238.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label knu1986}
   {c [knu\ 1986]\ \ }}
  {justify
    Donald E. Knuth.
    {i The T{c e}XBook.}
    Addison-Wesley.
    Reading, Massachusetts.
    1986.
    Pages 434–436.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label lev1984}
   {c [lev\ 1984]\ \ }}
  {justify
    Steven Levy.
    {i Hackers: Heroes of the Computer Revolution.}
    Anchor Press Doubleday.
    Garden City, New York.
    1984.
    Pages 132–133.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label lis1981}
   {c [lis\ 1981]\ \ }}
  {justify
    Barbara Liskov, Russell Atkinson, Toby Bloom, Elliot Moss,
    J. Craig Schaffert, Robert Scheifler, Alan Snyder.
    {i {c Clu} Reference Manual.}
    Lecture Notes in Computer Science Number 114.
    Springer-Verlag.
    Berlin, Germany.
    1981.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label mcc1987}
   {c [mcc\ 1987]}}
  {justify
    Robert McCrum, William Cran, Robert MacNeil.
    {i The Story of English.}
    Elizabeth Sifton Books.
    Viking Penguin.
    New York, New York.
    1987.
    Page 19.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label mid1978}
   {c [mid\ 1978]\ \ }}
  {justify
    Michael Middleton.
    ``The Importance of Syntactic Trivia.''
    {i {c Acm Sigplan} Notices.}
    Volume 13.
    Number 3.
    March 1978.
    Pages 17–19.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label mit1935}
   {c [mit\ 1935]\ \ }}
  {justify
    Naomi Mitchison.
    {i We Have Been Warned.}
    Constable and Company.
    London, United Kingdom.
    1935.
    Page 428.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label moe2014}
   {c [moe\ 2014]\ \ }}
  {justify
    James B. Moen.
    ``The Bracy Manual.''
    Unpublished technical report.
    2014.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label nau1963}
   {c [nau\ 1963]\ \ }}
  {justify
    J. W. Backus,
    F. L. Bauer,
    J. Green,
    C. Katz,
    J. McCarthy,
    P. Naur (editor),
    A. J. Perlis,
    H. Rutishauser,
    K. Samelson,
    B. Vauquois,
    J. H. Wegstein,
    A. van Wijngaarden,
    M. Woodger.
    ``Revised Report on the Algorithmic Language Algol 60.''
    {i Communications of the {c Acm.}}
    Volume 6.
    Number 1.
    January 1963.
    Pages 1–17.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label nie1954}
   {c [nie\ 1954]\ \ }}
  {justify
    Friedrich Nietzsche.
    {i Thus Spake Zarathrustra.}
    Thomas Common, translator.
    Modern Library.
    Random House.
    New York, New York.
    1954.
    Page 328.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label pat2005}
   {c [pat\ 2005]\ \ }}
  {justify
    David A. Patterson, John L. Hennessy.
    {i Computer Organization and Design.}
    Third Edition.
    Morgan-Kauffman.
    San Francisco, California.
    2005.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label pow2001}
   {c [pow\ 2001]\ \ }}
  {justify
    Thomas A. Powell.
    {i {c Html}: The Complete Reference.}
    Third Edition.
    Osborne/McGraw Hill.
    Berkeley, California.
    2001.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label rit1974}
   {c [rit\ 1974]}}
  {justify
    Dennis M. Ritchie, Ken Thompson.
    ``The {c Unix} Time-Sharing System.''
    {i Communications of the {c Acm.}}
    Volume 17.
    Number 7.
    1974.
    Pages 364–375.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label sal1998}
   {c [sal\ 1998]\ \ }}
  {justify
    Peter H. Salus, editor.
    {i Handbook of Programming Languages, Volume I: Object-Oriented Programming
    Languages.}
    Macmillan Technical Publishing.
    Boston, Massachusetts.
    1998.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label spe2007}
   {c [spe\ 2007]\ \ }}
  {justify
    Michael Sperber, R. Kent Dybvig, Matthew Flatt, Anton van Straaten.
    ``Revised⁶ Report on the Algorithmic Language Scheme.''
    September 26, 2007.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label ste1990}
   {c [ste\ 1990]\ \ }}
  {justify
    Guy L. Steele Jr.
    {i Common Lisp: The Language.}
    Second Edition.
    Digital Press.
    Bedford, Massachusetts.
    1990.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label sto2007}
   {c [sto\ 2007]\ \ }}
  {justify
    Bram Stoker.
    {i Dracula.}
    New American Library.
    New York, New York.
    2007.
    Page 332.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label uda1935}
   {c [uda\ 1935]\ \ }}
  {justify
    Nicholas Udall.
    {i Roister Doister.}
    Act {c iii.}
    Scene {c i.}
    Oxford University Press.
    London, United Kingdom.
    1935.
    Lines 772–773.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label uni2006}
   {c [uni\ 2006]\ \ }}
  {justify
    The Unicode Consortium.
    {i The Unicode Standard, Version 5.0.}
    Fifth Edition.
    Addison-Wesley Professional.
    Reading, Massachusetts.
    2006.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label usp1941}
   {c [usp\ 1941]\ \ }}
  {justify
    United States Playing Card Company.
    {i Poker: Official Rules and Suggestions for Players.}
    Whitman Publishing Company.
    Racine, Wisconsin.
    1941.}}

 {row {left \ } {left \ }}

 {row
  {left
   {label vwi1977}
   {c [vwi\ 1977]\ \ }}
  {justify
    A. van Wijngaarden,
    B. J. Mailloux,
    J. E. L. Peck,
    C. H. A. Koster,
    M. Sintzoff,
    C. H. Lindsey,
    L. G. L. T. Meertens,
    R. G. Fisker.
    ``Revised Report on the Algorithmic Language Algol 68.''
    {i {c Acm Sigplan} Notices.}
    Volume 12.
    Number 5.
    May 1977.
    Pages 1–70.}}

 {row {left \ } {left \ }}}

{rule}

{label colophon}
{left {b 10. Colophon.}}

{narrow
 {justify
   The alert reader will note that this book was prepared by a computer.}
 {right
  {goto gim1976 {c [gim 1976]}}}}

{justify
  This Report was rendered by {i Bracy} {goto moe2014 {c [moe 2014],}} a simple
  document compiler that produces {c html} {goto pow2001 {c [pow 2001].}}
  Bracy was written in Orson as an exercise to find errors in the prototype
  Orson compiler and its libraries.
  Text appears in the browser's default fonts, with the styles {b bold,}
  {c capital,} {i italic,} Roman, {- subscript,} {-= subsubscript,}
  {+ superscript,} and {t typescript.}}

{rule}

{label gfdl}
{b
 {center
   {c Gnu} Free Documentation License
   Version 1.3, 3 November 2008}}

{center
  Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
  {goto http://fsf.org/ {t <http://fsf.org/>}}}

{justify
  Everyone is permitted to copy and distribute verbatim copies of this license
  document, but changing it is not allowed.}

{left {b 0. Preamble.}}

{justify
  The purpose of this License is to make a manual, textbook, or other
  functional and useful document ``free'' in the sense of freedom: to assure
  everyone the effective freedom to copy and redistribute it, with or without
  modifying it, either commercially or noncommercially.
  Secondarily, this License preserves for the author and publisher a way to get
  credit for their work, while not being considered responsible for
  modifications made by others.

  This License is a kind of ``copyleft'', which means that derivative works of
  the document must themselves be free in the same sense.
  It complements the {c Gnu} General Public License, which is a copyleft
  license designed for free software.

  We have designed this License in order to use it for manuals for free
  software, because free software needs free documentation: a free program
  should come with manuals providing the same freedoms that the software does.
  But this License is not limited to software manuals; it can be used for any
  textual work, regardless of subject matter or whether it is published as a
  printed book.  We recommend this License principally for works whose purpose
  is instruction or reference.}

{left {b 1. Applicability and definitions.}}

{justify
  This License applies to any manual or other work, in any medium, that
  contains a notice placed by the copyright holder saying it can be distributed
  under the terms of this License.
  Such a notice grants a world-wide, royalty-free license, unlimited in
  duration, to use that work under the conditions stated herein.
  The ``Document'', below, refers to any such manual or work.
  Any member of the public is a licensee, and is addressed as ``you''.
  You accept the license if you copy, modify or distribute the work in a way
  requiring permission under copyright law.

  A ``Modified Version'' of the Document means any work containing the Document
  or a portion of it, either copied verbatim, or with modifications and/or
  translated into another language.

  A ``Secondary Section'' is a named appendix or a front-matter section of the
  Document that deals exclusively with the relationship of the publishers or
  authors of the Document to the Document's overall subject (or to related
  matters) and contains nothing that could fall directly within that overall
  subject.
  (Thus, if the Document is in part a textbook of mathematics, a Secondary
  Section may not explain any mathematics.)
  The relationship could be a matter of historical connection with the subject
  or with related matters, or of legal, commercial, philosophical, ethical or
  political position regarding them.

  The ``Invariant Sections'' are certain Secondary Sections whose titles are
  designated, as being those of Invariant Sections, in the notice that says
  that the Document is released under this License.
  If a section does not fit the above definition of Secondary then it is not
  allowed to be designated as Invariant.
  The Document may contain zero Invariant Sections.
  If the Document does not identify any Invariant Sections then there are none.

  The ``Cover Texts'' are certain short passages of text that are listed, as
  Front-Cover Texts or Back-Cover Texts, in the notice that says that the
  Document is released under this License.
  A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at
  most 25 words.

  A ``Transparent'' copy of the Document means a machine-readable copy,
  represented in a format whose specification is available to the general
  public, that is suitable for revising the document straightforwardly with
  generic text editors or (for images composed of pixels) generic paint
  programs or (for drawings) some widely available drawing editor, and that is
  suitable for input to text formatters or for automatic translation to a
  variety of formats suitable for input to text formatters.
  A copy made in an otherwise Transparent file format whose markup, or absence
  of markup, has been arranged to thwart or discourage subsequent modification
  by readers is not Transparent.
  An image format is not Transparent if used for any substantial amount of
  text.  A copy that is not ``Transparent'' is called ``Opaque''.

  Examples of suitable formats for Transparent copies include plain {c ascii}
  without markup, Texinfo input format, L{c a}T{c e}X input format, {c sgml} or
  {c xml} using a publicly available {c dtd,} and standard-conforming simple
  {c html,} PostScript or {c pdf} designed for human modification.
  Examples of transparent image formats include {c png,} {c xcf,} and {c jpg.}
  Opaque formats include proprietary formats that can be read and edited only
  by proprietary word processors, {c sgml} or {c xml} for which the {c dtd}
  and/or processing tools are not generally available, and the
  machine-generated {c html,} PostScript or {c pdf} produced by some word
  processors for output purposes only.

  The ``Title Page'' means, for a printed book, the title page itself, plus
  such following pages as are needed to hold, legibly, the material this
  License requires to appear in the title page.
  For works in formats which do not have any title page as such, ``Title Page''
  means the text near the most prominent appearance of the work's title,
  preceding the beginning of the body of the text.

  The ``publisher'' means any person or entity that distributes copies of the
  Document to the public.

  A section ``Entitled {c xyz}'' means a named subunit of the Document whose
  title either is precisely {c xyz} or contains {c xyz} in parentheses
  following text that translates {c xyz} in another language.
  (Here {c xyz} stands for a specific section name mentioned below, such as
  ``Acknowledgements'', ``Dedications'', ``Endorsements'', or ``History''.)  To
  ``Preserve the Title'' of such a section when you modify the Document means
  that it remains a section ``Entitled {c xyz}'' according to this definition.

  The Document may include Warranty Disclaimers next to the notice which states
  that this License applies to the Document.
  These Warranty Disclaimers are considered to be included by reference in this
  License, but only as regards disclaiming warranties: any other implication
  that these Warranty Disclaimers may have is void and has no effect on the
  meaning of this License.}

{left {b 2. Verbatim copying.}}

{justify
  You may copy and distribute the Document in any medium, either commercially
  or noncommercially, provided that this License, the copyright notices, and
  the license notice saying this License applies to the Document are reproduced
  in all copies, and that you add no other conditions whatsoever to those of
  this License.
  You may not use technical measures to obstruct or control the reading or
  further copying of the copies you make or distribute.
  However, you may accept compensation in exchange for copies.  If you
  distribute a large enough number of copies you must also follow the
  conditions in section 3.

  You may also lend copies, under the same conditions stated above, and you may
  publicly display copies.}

{left {b 3. Copying in quantity.}}

{justify
  If you publish printed copies (or copies in media that commonly have printed
  covers) of the Document, numbering more than 100, and the Document's license
  notice requires Cover Texts, you must enclose the copies in covers that
  carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the
  front cover, and Back-Cover Texts on the back cover.
  Both covers must also clearly and legibly identify you as the publisher of
  these copies.
  The front cover must present the full title with all words of the title
  equally prominent and visible.
  You may add other material on the covers in addition.
  Copying with changes limited to the covers, as long as they preserve the
  title of the Document and satisfy these conditions, can be treated as
  verbatim copying in other respects.

  If the required texts for either cover are too voluminous to fit legibly, you
  should put the first ones listed (as many as fit reasonably) on the actual
  cover, and continue the rest onto adjacent pages.

  If you publish or distribute Opaque copies of the Document numbering more
  than 100, you must either include a machine-readable Transparent copy along
  with each Opaque copy, or state in or with each Opaque copy a
  computer-network location from which the general network-using public has
  access to download using public-standard network protocols a complete
  Transparent copy of the Document, free of added material.  If you use the
  latter option, you must take reasonably prudent steps, when you begin
  distribution of Opaque copies in quantity, to ensure that this Transparent
  copy will remain thus accessible at the stated location until at least one
  year after the last time you distribute an Opaque copy (directly or through
  your agents or retailers) of that edition to the public.

  It is requested, but not required, that you contact the authors of the
  Document well before redistributing any large number of copies, to give them
  a chance to provide you with an updated version of the Document.}

{left {b 4. Modifications.}}

{justify
  You may copy and distribute a Modified Version of the Document under the
  conditions of sections 2 and 3 above, provided that you release the Modified
  Version under precisely this License, with the Modified Version filling the
  role of the Document, thus licensing distribution and modification of the
  Modified Version to whoever possesses a copy of it.
  In addition, you must do these things in the Modified Version:}

{narrow
 {layout
  {row
   {left {c a.}\ \ }
   {justify
     Use in the Title Page (and on the covers, if any) a title distinct from
     that of the Document, and from those of previous versions (which should,
     if there were any, be listed in the History section of the Document).
     You may use the same title as a previous version if the original publisher
     of that version gives permission.}}
  {row
   {left {c b.}\ \ }
   {justify
     List on the Title Page, as authors, one or more persons or entities
     responsible for authorship of the modifications in the Modified Version,
     together with at least five of the principal authors of the Document (all
     of its principal authors, if it has fewer than five), unless they release
     you from this requirement.}}
  {row
   {left {c c.}\ \ }
   {justify
     State on the Title page the name of the publisher of the Modified Version,
     as the publisher.}}
  {row
   {left {c d.}\ \ }
   {justify
     Preserve all the copyright notices of the Document.}}
  {row
   {left {c e.}\ \ }
   {justify
     Add an appropriate copyright notice for your modifications adjacent to the
     other copyright notices.}}
  {row
   {left {c f.}\ \ }
   {justify
     Include, immediately after the copyright notices, a license notice giving
     the public permission to use the Modified Version under the terms of this
     License, in the form shown in the Addendum below.}}
  {row
   {left {c g.}\ \ }
   {justify
     Preserve in that license notice the full lists of Invariant Sections and
     required Cover Texts given in the Document's license notice.}}
  {row
   {left {c h.}\ \ }
   {justify
     Include an unaltered copy of this License.}}
  {row
   {left {c i.}\ \ }
   {justify
     Preserve the section Entitled ``History'', Preserve its Title, and add to
     it an item stating at least the title, year, new authors, and publisher of
     the Modified Version as given on the Title Page.
     If there is no section Entitled ``History'' in the Document, create one
     stating the title, year, authors, and publisher of the Document as given
     on its Title Page, then add an item describing the Modified Version as
     stated in the previous sentence.}}
  {row
   {left {c j.}\ \ }
   {justify
     Preserve the network location, if any, given in the Document for public
     access to a Transparent copy of the Document, and likewise the network
     locations given in the Document for previous versions it was based on.
     These may be placed in the ``History'' section.
     You may omit a network location for a work that was published at least
     four years before the Document itself, or if the original publisher of the
     version it refers to gives permission.}}
  {row
   {left {c k.}\ \ }
   {justify
     For any section Entitled ``Acknowledgements'' or ``Dedications'',
     Preserve the Title of the section, and preserve in the section all the
     substance and tone of each of the contributor acknowledgements and/or
     dedications given therein.}}
  {row
   {left {c l.}\ \ }
   {justify
     Preserve all the Invariant Sections of the Document, unaltered in their
     text and in their titles.
     Section numbers or the equivalent are not considered part of the section
     titles.}}
  {row
   {left {c m.}\ \ }
   {justify
     Delete any section Entitled ``Endorsements''.
     Such a section may not be included in the Modified Version.}}
  {row
   {left {c n.}\ \ }
   {justify
v     Do not retitle any existing section to be Entitled ``Endorsements'' or to
     conflict in title with any Invariant Section.}}
  {row
   {left {c o.}\ \ }
   {justify
     Preserve any Warranty Disclaimers.}}}}

{justify
  If the Modified Version includes new front-matter sections or appendices that
  qualify as Secondary Sections and contain no material copied from the
  Document, you may at your option designate some or all of these sections as
  invariant.
  To do this, add their titles to the list of Invariant Sections in the
  Modified Version's license notice.
  These titles must be distinct from any other section titles.

  You may add a section Entitled ``Endorsements'', provided it contains nothing
  but endorsements of your Modified Version by various parties — for example,
  statements of peer review or that the text has been approved by an
  organization as the authoritative definition of a standard.

  You may add a passage of up to five words as a Front-Cover Text, and a
  passage of up to 25 words as a Back-Cover Text, to the end of the list of
  Cover Texts in the Modified Version.
  Only one passage of Front-Cover Text and one of Back-Cover Text may be added
  by (or through arrangements made by) any one entity.
  If the Document already includes a cover text for the same cover, previously
  added by you or by arrangement made by the same entity you are acting on
  behalf of, you may not add another; but you may replace the old one, on
  explicit permission from the previous publisher that added the old one.

  The author(s) and publisher(s) of the Document do not by this License give
  permission to use their names for publicity for or to assert or imply
  endorsement of any Modified Version.}

{left {b 5. Combining documents.}}

{justify
  You may combine the Document with other documents released under this
  License, under the terms defined in section 4 above for modified versions,
  provided that you include in the combination all of the Invariant Sections of
  all of the original documents, unmodified, and list them all as Invariant
  Sections of your combined work in its license notice, and that you preserve
  all their Warranty Disclaimers.

  The combined work need only contain one copy of this License, and multiple
  identical Invariant Sections may be replaced with a single copy.
  If there are multiple Invariant Sections with the same name but different
  contents, make the title of each such section unique by adding at the end of
  it, in parentheses, the name of the original author or publisher of that
  section if known, or else a unique number.
  Make the same adjustment to the section titles in the list of Invariant
  Sections in the license notice of the combined work.

  In the combination, you must combine any sections Entitled ``History'' in the
  various original documents, forming one section Entitled ``History'';
  likewise combine any sections Entitled ``Acknowledgements'', and any sections
  Entitled ``Dedications''.
  You must delete all sections Entitled ``Endorsements''.}

{left {b 6. Collections of documents.}}

{justify
  You may make a collection consisting of the Document and other documents
  released under this License, and replace the individual copies of this
  License in the various documents with a single copy that is included in the
  collection, provided that you follow the rules of this License for verbatim
  copying of each of the documents in all other respects.

  You may extract a single document from such a collection, and distribute it
  individually under this License, provided you insert a copy of this License
  into the extracted document, and follow this License in all other respects
  regarding verbatim copying of that document.}

{left {b 7. Aggregation with independent works.}}

{justify
  A compilation of the Document or its derivatives with other separate and
  independent documents or works, in or on a volume of a storage or
  distribution medium, is called an ``aggregate'' if the copyright resulting
  from the compilation is not used to limit the legal rights of the
  compilation's users beyond what the individual works permit.
  When the Document is included in an aggregate, this License does not apply
  to the other works in the aggregate which are not themselves derivative works
  of the Document.

  If the Cover Text requirement of section 3 is applicable to these copies of
  the Document, then if the Document is less than one half of the entire
  aggregate, the Document's Cover Texts may be placed on covers that bracket
  the Document within the aggregate, or the electronic equivalent of covers if
  the Document is in electronic form.  Otherwise they must appear on printed
  covers that bracket the whole aggregate.}

{left {b 8. Translation.}}

{justify
  Translation is considered a kind of modification, so you may distribute
  translations of the Document under the terms of section 4.  Replacing
  Invariant Sections with translations requires special permission from their
  copyright holders, but you may include translations of some or all Invariant
  Sections in addition to the original versions of these Invariant Sections.
  You may include a translation of this License, and all the license notices in
  the Document, and any Warranty Disclaimers, provided that you also include
  the original English version of this License and the original versions of
  those notices and disclaimers.
  In case of a disagreement between the translation and the original version of
  this License or a notice or disclaimer, the original version will prevail.

  If a section in the Document is Entitled ``Acknowledgements'',
  ``Dedications'', or ``History'', the requirement (section 4) to Preserve its
  Title (section 1) will typically require changing the actual title.}

{left {b 9. Termination.}}

{justify
  You may not copy, modify, sublicense, or distribute the Document except as
  expressly provided under this License.
  Any attempt otherwise to copy, modify, sublicense, or distribute it is void,
  and will automatically terminate your rights under this License.

  However, if you cease all violation of this License, then your license from a
  particular copyright holder is reinstated (a) provisionally, unless and until
  the copyright holder explicitly and finally terminates your license, and (b)
  permanently, if the copyright holder fails to notify you of the violation by
  some reasonable means prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is reinstated
  permanently if the copyright holder notifies you of the violation by some
  reasonable means, this is the first time you have received notice of
  violation of this License (for any work) from that copyright holder, and you
  cure the violation prior to 30 days after your receipt of the notice.

  Termination of your rights under this section does not terminate the licenses
  of parties who have received copies or rights from you under this License.
  If your rights have been terminated and not permanently reinstated, receipt
  of a copy of some or all of the same material does not give you any rights to
  use it.}

{left {b 10. Future revisions of this license.}}

{justify
  The Free Software Foundation may publish new, revised versions of the {c gnu}
  Free Documentation License from time to time.
  Such new versions will be similar in spirit to the present version, but may
  differ in detail to address new problems or concerns.
  See {goto http://www.gnu.org/copyleft/ {t <http://www.gnu.org/copyleft/>.}}

  Each version of the License is given a distinguishing version number.
  If the Document specifies that a particular numbered version of this License
  ``or any later version'' applies to it, you have the option of following the
  terms and conditions either of that specified version or of any later version
  that has been published (not as a draft) by the Free Software Foundation.
  If the Document does not specify a version number of this License, you may
  choose any version ever published (not as a draft) by the Free Software
  Foundation.
  If the Document specifies that a proxy can decide which future versions of
  this License can be used, that proxy's public statement of acceptance of a
  version permanently authorizes you to choose that version for the Document.}

{left {b 11. Relicensing.}}

{justify
  ``Massive Multiauthor Collaboration Site'' (or ``{c mmc} Site'') means any
  World Wide Web server that publishes copyrightable works and also provides
  prominent facilities for anybody to edit those works.
  A public wiki that anybody can edit is an example of such a server.
  A ``Massive Multiauthor Collaboration'' (or ``{c mmc}'') contained in the
  site means any set of copyrightable works thus published on the {c mmc} site.

  ``{c Cc-by-sa}'' means the Creative Commons Attribution-Share Alike 3.0
  license published by Creative Commons Corporation, a not-for-profit
  corporation with a principal place of business in San Francisco, California,
  as well as future copyleft versions of that license published by that same
  organization.

  ``Incorporate'' means to publish or republish a Document, in whole or in
  part, as part of another Document.

  An {c mmc} is ``eligible for relicensing'' if it is licensed under this
  License, and if all works that were first published under this License
  somewhere other than this {c mmc}, and subsequently incorporated in whole or
  in part into the {c mmc}, (1) had no cover texts or invariant sections, and
  (2) were thus incorporated prior to November 1, 2008.

  The operator of an {c mmc} Site may republish an {c mmc} contained in the
  site under {c cc-by-sa} on the same site at any time before August 1, 2009,
  provided the {c mmc} is eligible for relicensing.}

{left {b 12. Addendum: How to use this License for your documents.}}

{justify
  To use this License in a document you have written, include a copy of the
  License in the document and put the following copyright and license notices
  just after the title page:}

{narrow
 {justify
   Copyright © {c year} {c your name.}
   Permission is granted to copy, distribute and/or modify this document under
   the terms of the {c Gnu} Free Documentation License, Version 1.3 or any
   later version published by the Free Software Foundation; with no Invariant
   Sections, no Front-Cover Texts, and no Back-Cover Texts.
   A copy of the license is included in the section entitled ``{c Gnu} Free
   Documentation License''.}}

{justify
  If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
  replace the ``with ... Texts.'' line with this:}

{narrow
 {justify
   with the Invariant Sections being {c list their titles,} with the
   Front-Cover Texts being {c list,} and with the Back-Cover Texts being
   {c list.}}}

{justify
  If you have Invariant Sections without Cover Texts, or some other combination
  of the three, merge those two alternatives to suit the situation.

  If your document contains nontrivial examples of program code, we recommend
  releasing these examples in parallel under your choice of free software
  license, such as the {c Gnu} General Public License, to permit their use in
  free software.}
