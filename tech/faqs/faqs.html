<!-- Created by Bracy 0.4 on Sunday, January 26, 2014 at 4:36 PM CST -->
<html>
 <head>
  <title>
   FAQ's About Orson
  </title>
  <style>
   a:active
    { color: purple;
      font-weight: bold;
      text-decoration: none }
   a:link
    { color: blue;
      font-weight: bold;
      text-decoration: none }
   a:visited
    { color: purple;
      font-weight: bold;
      text-decoration: none }
   hr
    { background-color: black; 
      border: none;
      color: black;
      height: 1px }
   table
    { border-collapse: collapse }
  </style>
 </head>
 <body bgcolor="#FFFFFF">
  <p align="center">
   <b>F<small>AQ</small>&rsquo;s About Orson</b>
   <br />
   <br />
   James B. Moen
   <br />
   January 19, 2014
  </p>
  <p align="justify">
   Copyright &#169; 2014 James B. Moen. Permission is granted to copy,
   distribute, and/or modify this document under the terms of the
   G<small>NU</small> Free Documentation License, Version 1.3 or any later
   version published by the Free Software Foundation; with no Invariant
   Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
   license may be obtained at
   <a href="http://fsf.org/">
    <tt>&lt;http://fsf.org/&gt;.</tt>
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This document uses special characters.
   Without proper rendering support, you may see question marks, boxes, or
   other symbols in place of these characters. This document must be rendered
   using a font where a quote &lsquo;&nbsp;"&nbsp;&rsquo;, an italic quote
   &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;, and two apostrophes
   &lsquo;&nbsp;''&nbsp;&rsquo; all look different.
  </p>
  <hr />
  <p>
   <b>0. Introduction.</b>
  </p>
  <blockquote>
   <p align="justify">
    F<small>AQ</small>: Free at Quay.
   </p>
   <p align="right">
    <a href="#des1967">
     [<small>DES</small> 1967]
    </a>
   </p>
  </blockquote>
  <p align="justify">
   F<small>AQ</small>&rsquo;s are Frequently Asked Questions, but since
   Orson is new, no one has asked questions about it. These are Fictionally
   Anticipated Questions instead. Some of these questions were suggested by the
   <small>FAQ</small> lists for other languages, notably those for C. I
   may add new questions to the list from time to time.
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#general">
        1.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       General questions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#arraytups">
        2.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about arrays and tuples.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#chars">
        3.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about characters.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#coercions">
        4.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about coercions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#constvars">
        5.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about constants and variables.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#equates">
        6.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about equates and declarations.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#forms">
        7.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about forms.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#parens">
        8.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about parentheses.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#pointers">
        9.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about pointers.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#string">
        10.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about strings.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#tokens">
        11.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about tokens.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#types">
        12.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about types.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#current">
        13.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about the current implementation of Orson.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#misc">
        14.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Miscellaneous questions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#references">
        15.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       References.
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <hr />
  <a name="general">
  </a>
  <p>
   <b>1. General questions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> What is Orson?
  </p>
  <p align="justify">
   <b>A.</b> <i>Orson</i> is a small, general purpose programming
   language. It&rsquo;s designed to be used by individuals instead of groups,
   so it omits the complex information hiding mechanisms of other languages,
   like classes, modules, and packages. In their place, Orson emphasizes
   extendability and expressiveness, and provides access to low level objects
   like that of C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   However, you can still write safe, modular programs in Orson.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson divides computation into two phases,
   called transformation and execution. In <i>transformation,</i> Orson
   creates new expressions by calling <i>forms,</i> which are much like
   macros that expand to abstract syntax trees. Forms are written in an
   applicative language that is similar to Scheme, but with an algebraic
   notation and an explicit type system. In <i>execution,</i> Orson
   evaluates the expressions produced by transformation, as in a conventional
   compiler.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Although the parts of Orson that perform
   transformation and execution are tightly integrated, the language may be
   implemented so that all transformations are performed at compile time, and
   all executions at run time. This allows programming with forms in an
   abstract, general style, while still producing efficiently executable
   programs.
  </p>
  <p align="justify">
   <b>Q.</b> Why is it called <i>Orson</i>?
  </p>
  <p align="justify">
   <b>A.</b> I thought the name sounded good. <i>Orson</i>
   isn&rsquo;t an acronym, so it doesn&rsquo;t properly appear in capital
   letters. The name doesn&rsquo;t refer to any group, person, place, or thing:
   Orson is not named after Orson Bean, Orson Scott Card, or Orson Welles.
   Orson also has nothing to do with the <small>BRIT</small>-award-winning
   rock band of the same name.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Since Orson uses forms so much, I once
   considered calling it <i>Formula,</i> as a pun on <i>Modula</i>
   (which uses modules) and <i>Simula</i> (which does simulations). Alas,
   someone else had already used the name for a music composition language
   <a href="#and1991">
    [<small>AND</small> 1991].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A very early version of Orson was called
   <i>Who,</i> intended as a joking reference to the many languages that
   are named after famous people (like <i>Ada, Eiffel, Haskell,
   Pascal,</i> etc.) However, this presented obvious problems with what to
   call the compiler in a Unix environment, as the names <tt>who</tt> and
   <tt>wc</tt> are already taken.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson look like C? All the other new
   languages do.
  </p>
  <p align="justify">
   <b>A.</b> C&rsquo;s syntax is poorly designed. For example, consider
   (1) the need for semicolons as terminators for some (but not all)
   statements, (2) the error-prone infix operators, such as = and ==, (3) the
   inside-out notation for function types, (4) the bizarre infix operator
   priorities, (5) the need for <i>break</i> statements inside
   <i>switch</i> statements, (6) the lack of delimiting names like
   <b>then</b> and <b>of,</b> whose presence promotes readability and
   good error recovery.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C is great because of its
   <i>semantics,</i> not its syntax. Unfortunately, designers of new
   programming languages haven&rsquo;t understood this, because they&rsquo;ve
   imitated its syntax, not its semantics. Perhaps they think making their
   languages look like C will make them easier to learn. This is a mistake,
   because learning a new syntax is only a small part of learning a new
   language. It also misleads new users. When I was a professor, I often met
   students who thought they knew Java, but actually knew C or C++, and had
   trouble with the transition.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson doesn&rsquo;t look like C because
   it&rsquo;s different from C. C is a statement language; Orson is an
   expression language. C uses name compatibility for some of its types; Orson
   uses structure compatibility for all. C programs are collections of
   functions; most Orson programs are collections of forms. C doesn&rsquo;t
   really have arrays; Orson does.
  </p>
  <p align="justify">
   <b>Q.</b> Why isn&rsquo;t Orson object oriented? All the other new
   languages are.
  </p>
  <p align="justify">
   <b>A.</b> In the 1960&rsquo;s, programmers thought you couldn&rsquo;t
   use linked data structures without using someone&rsquo;s fancy list
   processing system, like <small>IPL</small>
   <a href="#sam1969">
    [<small>SAM</small> 1969]
   </a>
   or Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990].
   </a>
   Knuth&rsquo;s books debunked this idea
   <a href="#knu1975">
    [<small>KNU</small> 1975].
   </a>
   Of course you can use linked structures in any modern language.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now programmers think you can&rsquo;t write
   in an object oriented style without using someone&rsquo;s fancy object
   oriented system, like C++ or Java. Actually you can approximate an object
   oriented style in any modern language. Orson contains several mechanisms
   (alternate forms and secret names) that support such approximations.
   <i>Objects may be closer than they appear!</i>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;m skeptical about object
   orientedness. It works well for games, graphics, and
   <small>GUI</small>&rsquo;s (the three <small>G</small>&rsquo;s).
   However, it works less well for other kinds of programs, in which it may
   make simple things unnecessarily complicated. Maybe someday, object oriented
   programming will go back into our bag of tricks along with everything else,
   to be taken out and used only when appropriate.
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson come with an <small>IDE</small>? All the
   other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Of course an <small>IDE</small> is an
   Integrated Development Environment, essentially a text editor that automates
   the troublesome tasks of programming. Orson doesn&rsquo;t have one because I
   don&rsquo;t use <small>IDE</small>&rsquo;s when I write my own stuff. I
   use Emacs and G<small>NU</small> command line tools instead. I
   don&rsquo;t know if it would be possible to take an existing
   <small>IDE</small> and adapt it to Orson, or vice-versa.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A lot of people want to make badly designed
   programming languages easier to use by giving them a fancy
   <small>IDE</small>. This makes sense if someone (like a boss) is
   forcing you to use a badly designed language. I think it would be better to
   try making well designed languages instead. I don&rsquo;t know if Orson is
   well designed or not.
  </p>
  <p align="justify">
   <b>Q.</b> Why isn&rsquo;t Orson an interpreted language? All the other
   new languages are.
  </p>
  <p align="justify">
   <b>A.</b> There&rsquo;s a place for interpreted languages.
   They&rsquo;re good for fast prototyping and for portability. Also, the speed
   of compiled languages isn&rsquo;t needed for many applications. Some people
   therefore argue that programming ought to be done exclusively with
   interpreters. At the risk of attacking a straw man, I think this is a bad
   idea.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Using interpreted languages means we
   don&rsquo;t benefit from faster hardware. My present computer is many times
   faster than the one I owned in the 1980&rsquo;s, and its hard disk has a far
   larger capacity. But my (interpreted) Java programs now seem to run about as
   fast as my (compiled) Pascal programs did back then, and they&rsquo;re not
   that much easier to write.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interpreted languages also prevent
   programmers from accessing the hardware directly. Here&rsquo;s a paranoid
   fantasy: suppose a big operating systems company wished to prevent
   competition. It might then support only interpreted languages that
   aren&rsquo;t powerful enough to write new operating systems. This would make
   it hard for small companies to rise up and challenge them. Now imagine what
   would happen if this company also held a monopoly on all software available
   to the public...
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson support concurrency, parallel computation,
   multi-processing, or threads? All the other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Future versions may do so. It may be possible
   to use P<small>OSIX</small> threads
   <a href="#stv2005">
    [<small>STV</small> 2005]
   </a>
   with the current Orson compiler, but there&rsquo;s no explicit support for
   this, and I&rsquo;ve never tried it. Orson&rsquo;s catch-throw mechanism and
   the garbage collector in the Orson library are probably not safe for
   threads. Also, Orson is currently translated to C, so in principle it should
   be possible to do anything in Orson that can be done in C.
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson have a formally defined semantics? All the other
   new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Why? (1) I wanted to describe Orson in a way
   that would be accessible to a wide audience, so I wrote most of the
   Revised&#8315;&#185; Report
   <a href="#moe2014">
    [<small>MOE</small> 2014]
   </a>
   in English instead of mathematics. However, Orson&rsquo;s type system is
   described using a semi-formal notation. (2) All the Orson documentation is
   in <small>HTML</small>, so it can be read with a browser, but browsers
   can&rsquo;t display mathematics well enough to handle the typography of
   formal semantics. (3) I don&rsquo;t know enough about formal semantics to
   describe Orson. This is the real reason.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;d be happy to hear from anyone who
   wants to write a formal semantics for Orson, or from anyone who has already
   done so. I don&rsquo;t guarantee that I can help you write such a thing, or
   even that I&rsquo;ll understand it after you&rsquo;re written it.
  </p>
  <p align="justify">
   <b>Q.</b> Orson sucks. No one will ever use Orson instead of C (or C++,
   Cobol, Java, etc.).
  </p>
  <p align="justify">
   <b>A.</b> No one has to. I didn&rsquo;t write Orson to replace any
   other language, and to paraphrase <i>The Rocky Horror Picture Show</i>
   <a href="#hen1979">
    [<small>HEN</small> 1979],
   </a>
   I didn&rsquo;t write it for you. I wrote it because I wanted to use it
   myself. Many people think something must be popular to be successful. This
   is the high school cheerleader&rsquo;s definition of success. Don&rsquo;t be
   misled by it.
  </p>
  <p align="justify">
   <b>Q.</b> Orson sucks. I can&rsquo;t use it to make web pages that talk
   to databases. (Insert your favorite commercial programming task.)
  </p>
  <p align="justify">
   <b>A.</b> Orson is a low level language with a high level library. You
   might be able to write Orson programs like the ones you want if there was
   library support for them. If you&rsquo;d rather use some other language,
   then why are you using Orson?
  </p>
  <hr />
  <a name="arraytups">
  </a>
  <p>
   <b>2. Questions about arrays and tuples.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Is there a way to compare arrays or tuples automatically?
  </p>
  <p align="justify">
   <b>A.</b> No. The only way to do that is to write a form or procedure
   that compares two arrays element by element, or two tuples slot by slot.
   However, you can write a higher-order form that makes a comparison form
   automatically, like this.
  </p>
  <blockquote>
   <p>
    <i>makeEquality</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<b>type</b>&nbsp;<i>tup</i>&nbsp;<i>t</i>,&nbsp;<i>list</i>&nbsp;<i>s</i>)&nbsp;<i>foj</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>form</b>&nbsp;(<i>t</i>&nbsp;<i>l</i>,&nbsp;<i>t</i>&nbsp;<i>r</i>)&nbsp;<i>bool</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b></font><i>makingEquality</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i></font>(<b>form</b>&nbsp;(<i>list</i>&nbsp;<i>s</i>)&nbsp;<i>bool</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>(</font>(<b>if</b>&nbsp;<i>isEmpty</i>(<i>s</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>((</font><b>then</b>&nbsp;<i>true</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>((</font><b>else</b>&nbsp;<i>"</i>.<i>"</i>(<i>l</i>,&nbsp;<i>car</i>(<i>s</i>))&nbsp;=&nbsp;<i>"</i>.<i>"</i>(<i>r</i>,&nbsp;<i>car</i>(<i>s</i>))&nbsp;&#8743;&nbsp;<i>makingEquality</i>(<i>cdr</i>(<i>s</i>))))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((</font><b>do</b>&nbsp;<i>makingEquality</i>(<i>s</i>))))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>
    <br />
    <i>comp</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>"</i>=<i>"</i>&nbsp;:&#8722;&nbsp;<i>makeEquality</i>(<i>comp</i>:&nbsp;$<i>re</i>,&nbsp;$<i>im</i>)
   </p>
  </blockquote>
  <p align="justify">
   This is one of the few times when you must call <i>"</i>.<i>"</i>
   explicitly, instead of writing <i>e</i>.<i>n.</i>
  </p>
  <p align="justify">
   <b>Q.</b> Can I write a constant whose type is an array or a tuple?
  </p>
  <p align="justify">
   <b>A.</b> No. But you can simulate such a thing with a form or a
   procedure. For example, the form <i>makeComp</i> returns a complex
   number, given values for its slots <i>re</i> and <i>im.</i>
  </p>
  <blockquote>
   <p>
    <i>comp</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>makeComp</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;<i>comp</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>comp</i>&nbsp;<i>z</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>do</b>&nbsp;<i>z</i>.<i>re</i>&nbsp;:=&nbsp;<i>re</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;</font><i>z</i>.<i>im</i>&nbsp;:=&nbsp;<i>im</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;</font><i>z</i>))
   </p>
  </blockquote>
  <p align="justify">
   Orson doesn&rsquo;t have a notation for array or tuple constants because
   it&rsquo;s easy to write a form like this, which acts like such a constant.
   The Orson library may someday provide more efficient versions of these
   forms.
  </p>
  <hr />
  <a name="chars">
  </a>
  <p>
   <b>3. Questions about characters.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson support Unicode? All the other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Yes. Orson uses a 31-bit character set that includes the
   21-bit Unicode
   <a href="#uni2006">
    [<small>UNI</small> 2006]
   </a>
   and the 7-bit <small>ASCII</small>
   <a href="#ans1986">
    [<small>ANS</small> 1986]
   </a>
   character sets as subsets. (Some people think Unicode is a 16-bit character
   set, but they&rsquo;re wrong.) Orson uses the <small>UTF</small>-8
   encoding for strings.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The good news is that you can still write
   Orson programs in <small>ASCII</small>, even on old systems that
   don&rsquo;t support Unicode, and that Orson characters and strings are
   completely compatible with those of C and Unix. The bad news is that you
   can&rsquo;t access string characters using simple pointer arithmetic any
   more, unless those strings contain only <small>ASCII</small>
   characters. However, the Orson library contains forms that make this
   relatively painless.
  </p>
  <p align="justify">
   <b>Q.</b> If Orson supports Unicode, then why can&rsquo;t I use
   Cyrillic letters in names, like I can in Java? (Insert your favorite
   non-Roman alphabet.)
  </p>
  <p align="justify">
   <b>A.</b> Orson allows only unaccented Roman and Greek letters in plain
   and secret names, along with a few mathematical symbols. Here&rsquo;s why.
  </p>
  <ul>
   <li>
   <p align="justify">
    Most programming languages use English reserved names (like <b>if</b>
    and <b>while</b>), and their syntaxes assume English word order. They
    can&rsquo;t be made international just by allowing unreserved names to use
    letters from multiple alphabets. This would work only in languages that
    don&rsquo;t need reserved names, and that use a syntax which is not based
    on word order.
   </p>
   <li>
   <p align="justify">
    Many alphabets have letters that look like other letters. For example, the
    Roman capital letter &lsquo;A&rsquo; (U+0041) looks like the Greek capital
    letter &lsquo;A&rsquo; (U+0391), and the letter &lsquo;LJ&rsquo; (U+01C7)
    looks like the letter &lsquo;L&rsquo; (U+004C) followed by the letter
    &lsquo;J&rsquo; (U+004A)
    <a href="#gos1996">
     [<small>GOS</small> 1996].
    </a>
    Allowing such letters in names would make it possible to write confusing
    programs, with names that seem to be identical, but are not.
   </p>
   <li>
   <p align="justify">
    Programs should be written to be as understood by as many people as
    possible. It is claimed that more people read English than any other
    language
    <a href="#mcc1987">
     [<small>MCC</small> 1987],
    </a>
    and all programmers know some mathematics, so programs should be written
    with English or mathematical names. For example, Linus Torvalds, a native
    of Finland whose first language is Swedish, chose to write his famous
    operating system kernel in English
    <a href="#moo2001">
     [<small>MOO</small> 2001].
    </a>
    No English chauvinism is intended: the status of English is due to
    historical accidents, not to any inherent superiority.
   </p>
  </ul>
  <p align="justify">
   Orson does allow most characters (including those from non-Roman alphabets)
   in quoted names. For example, you can write
   <i>"</i>&#1056;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;<i>"</i>
   in Cyrillic letters, but you must include the double quotes, since
   they&rsquo;re part of the name.
  </p>
  <p align="justify">
   <b>Q.</b> I just tried to write an Orson program, but your compiler
   complained when I used tabs. How can I make it stop doing that?
  </p>
  <p align="justify">
   <b>A.</b> Don&rsquo;t use tabs. They&rsquo;re handled inconsistently by
   different output devices and utility programs. A program with tabs might
   look properly indented on one computer, but not on another. This can&rsquo;t
   happen if you use blanks, which look the same way everywhere. Orson makes
   you use blanks by treating tabs (and all other control characters except
   newlines) as illegal characters.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Just because you shouldn&rsquo;t use tabs,
   doesn&rsquo;t mean you shouldn&rsquo;t use the <small>TAB</small> key.
   Some text editors can insert an appropriate number of blanks when you press
   <small>TAB</small>. Consider using such an editor.
  </p>
  <hr />
  <a name="coercions">
  </a>
  <p>
   <b>4. Questions about coercions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> When I write the equate
   <b>real</b>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;0, I get an error
   message. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> 0 isn&rsquo;t a real constant. It&rsquo;s an integer
   constant. Unlike other languages, Orson doesn&rsquo;t automatically coerce
   integers to reals. Write
   <b>real</b>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;0.0 instead. Orson
   has only the bare minimum of coercions, and has no way to define new ones.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson coerce integers to reals? All the
   other languages do.
  </p>
  <p align="justify">
   <b>A.</b> There are several reasons.
  </p>
  <ul>
   <li>
   <p align="justify">
    Coercion should occur only in situations where no information will be lost.
    On most computers, some integers cannot be exactly represented as reals, so
    information would be lost if they were coerced.
   </p>
   <li>
   <p align="justify">
    Integers and reals are very different kinds of objects inside a computer,
    and have different properties. For example, it is meaningful to test
    integers for equality, but in many algorithms it is not meaningful to test
    reals for equality. Often you test if they are within some small number
    &#949; of each other, by writing
    <i>abs</i>(<i>u</i>&nbsp;&#8722;&nbsp;<i>v</i>)&nbsp;&#8804;&nbsp;&#949;.
   </p>
   <li>
   <p align="justify">
    Suppose that Orson coerced integers to reals, but someone implemented
    complex numbers, perhaps by using tuples. Then for consistency, there
    should be a way to coerce reals to complexes, too. That would require a
    user-defined coercion mechanism, something which would complicate Orson
    tremendously. (An early version of Orson included this: it was a mess.) The
    simplest fix, which maintains consistency, is not to coerce integers to
    reals.
   </p>
   <li>
   <p align="justify">
    Coercions from integers to reals can be simulated easily by casts. Using an
    explicit cast alerts the reader when an object of one type is being
    converted to an object of another type, which an implicit coercion does not
    do. Also, it&rsquo;s possible to define new casts.
   </p>
  </ul>
  <hr />
  <a name="constvars">
  </a>
  <p>
   <b>5. Questions about constants and variables.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I declared an integer variable <i>j</i> with an initial
   value of 0. When I tried resetting <i>j</i> to 4, I got an error
   message about an undefined method.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    (<b>with</b>&nbsp;<i>int</i>&nbsp;<i>j</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>do</b>&nbsp;<i>j</i>&nbsp;:=&nbsp;2&nbsp;+&nbsp;2&nbsp;
    <br />
    <font color="#FFFFFF">(<b>do</b>&nbsp;</font><i>writeln</i>(<i>j</i>))
   </p>
  </blockquote>
  <p align="justify">
   What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> The name <i>j</i> isn&rsquo;t a variable. It&rsquo;s a
   constant. You got an error message because the form
   <i>"</i>:=<i>"</i> expects a variable as its first argument, but
   you gave it a constant instead. Orson searched for a member of
   <i>"</i>:=<i>"</i> that works with constants, but it
   couldn&rsquo;t find one, so it scolded you about an undefined method. You
   should have written this.
  </p>
  <blockquote>
   <p>
    (<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>j</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>do</b>&nbsp;<i>j</i>&nbsp;:=&nbsp;2&nbsp;+&nbsp;2&nbsp;
    <br />
    <font color="#FFFFFF">(<b>do</b>&nbsp;</font><i>writeln</i>(<i>j</i>))
   </p>
  </blockquote>
  <p align="justify">
   Orson is fussier than other languages about distinguishing constants and
   variables. This is so it can do computation with constants during
   transformation. Variable types have <b>var</b> prefixes. Constant types
   don&rsquo;t.
  </p>
  <p align="justify">
   <b>Q.</b> When I wrote this, I got an error message about
   <i>"</i>:=<i>"</i> being an undefined method.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;<i>x</i>&nbsp;:=&nbsp;&#8722;&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font><i>x</i>)
   </p>
  </blockquote>
  <p align="justify">
   What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> The name <i>x</i> isn&rsquo;t a variable. It&rsquo;s a
   constant. You got an error message because the form
   <i>"</i>:=<i>"</i> expects a variable as its first argument, but
   you gave it a constant instead. Orson searched for a member of
   <i>"</i>:=<i>"</i> that works with constants, but it
   couldn&rsquo;t find one, so it scolded you about an undefined method. You
   could have written this, which makes a local variable <i>x</i> and
   initializes it to the value of the parameter <i>x.</i>
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>do</b>&nbsp;(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((<b>do</b>&nbsp;(</font><b>then</b>&nbsp;<i>x</i>&nbsp;:=&nbsp;&#8722;&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((<b>do</b>&nbsp;</font><i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   However, it&rsquo;s simpler to write it without a variable, like this. Orson
   often uses variables less than other languages.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>else</b>&nbsp;<i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   Some programmers like to represent the state of a program using the values
   of variables. They write their code as a linear series of steps, where each
   step changes the program&rsquo;s state by resetting the variables. Call this
   &rsquo;&rsquo;state as value.&rsquo;&rsquo;
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Other programmers like to represent state
   using the place that&rsquo;s currently being executed in a program. They
   write their code as a branching structure instead, with a different place
   for each state that their program can assume. Call this &rsquo;&rsquo;state
   as place.&rsquo;&rsquo;
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I personally prefer to write in the
   &lsquo;&lsquo;state as place&rsquo;&rsquo; style whenever possible, because
   I think it&rsquo;s easier to read and understand. It&rsquo;s also closer to
   the &lsquo;&lsquo;spirit&rsquo;&rsquo; of Orson, whose design steals ideas
   from languages that use variables sparingly or not at all.
  </p>
  <p align="justify">
   <b>Q.</b> I want to declare a variable <i>v</i> whose value can be
   an integer of any type. I wrote the equate
   <b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v,</i> but Orson gave me
   an error message about a missing &lsquo;:&#8722;&rsquo;. So I wrote the
   equate
   <b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v</i>&nbsp;:&#8722;&nbsp;0
   instead, but then Orson gave me an error message about 0 having the wrong
   type. How can I declare a variable of type
   <b>var</b>&nbsp;<i>inj</i>?
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t declare a variable of type
   <b>var</b>&nbsp;<i>inj,</i> or indeed any variable whose base type
   contains jokers. This is because variables are execution instances (they
   exist only during execution) but jokers are transformation types (they exist
   only during transformation). I admit the error messages are misleading, but
   they are correctly saying that you can&rsquo;t do what you&rsquo;re trying
   to do.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are infinitely many possible integer
   types: <i>int</i>0, <i>int</i>1, <i>int</i>2, etc., with
   increasing sizes. A variable whose value is an integer of any type would
   have an infinitely large size, and so could not be represented inside a real
   computer. You might be able to approximate what you want by using a pointer
   variable of a type like
   <b>var</b>&nbsp;<b>ref</b>&nbsp;<i>void,</i> and then casting
   it so that it points to whatever sort of integer you want to reference with
   it.
  </p>
  <p align="justify">
   <b>Q.</b> If I can&rsquo;t declare a variable of type
   <b>var</b>&nbsp;<i>inj,</i> then what good is the type
   <b>var</b>&nbsp;<i>inj</i>? Why does Orson even let me write such
   a type?
  </p>
  <p align="justify">
   <b>A.</b> There are no objects whose type is <i>exactly</i>
   <b>var</b>&nbsp;<i>inj.</i> However, there are objects whose types
   are <i>subtypes</i> of <b>var</b>&nbsp;<i>inj.</i> For
   example, a <b>var</b>&nbsp;<i>int</i>0 variable has a type that is
   a subtype of <b>var</b>&nbsp;<i>inj.</i> As a result, a type like
   <b>var</b>&nbsp;<i>inj</i> can be used in situations where we want
   to <i>describe</i> an existing object, not <i>make</i> a new
   object. For example, I can write a form <i>zeroer</i> that takes an
   integer variable of any size as its argument, and sets its value to 0.
  </p>
  <blockquote>
   <p>
    <i>zeroer</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>z</i></font>(<b>form</b>&nbsp;(<b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>z</i>(<b>f</b></font><i>v</i>&nbsp;:=&nbsp;0)
   </p>
  </blockquote>
  <p align="justify">
   Here <b>var</b>&nbsp;<i>inj</i> is simply describing the objects
   to which <i>v</i> can be bound. It says that <i>v</i> can be bound
   to a variable of type <b>var</b>&nbsp;<i>int</i>0, or of type
   <b>var</b>&nbsp;<i>int</i>1, or of type
   <b>var</b>&nbsp;<i>int</i>2, etc.
  </p>
  <p align="justify">
   <b>Q.</b> But doesn&rsquo;t <i>v</i> have the type
   <b>var</b>&nbsp;<i>inj</i> inside the body of the form
   <i>zeroer</i>?
  </p>
  <p align="justify">
   <b>A.</b> No, it has the type of the constant or expression with which
   <i>zeroer</i> was called. If <i>zeroer</i> was called with an
   expression of type <b>var</b>&nbsp;<i>int</i>0, then <i>v</i>
   has the type <b>var</b>&nbsp;<i>int</i>0, and if it was called
   with an expression of type <b>var</b>&nbsp;<i>int</i>1, then it
   has the type <b>var</b>&nbsp;<i>int</i>1 instead. Arguments to
   forms can be coerced to <i>subtypes</i> of their corresponding
   parameter types, not necessarily to <i>exactly</i> those parameter
   types. The &lsquo;&lsquo;Revised&#8315;&#185; Report&rsquo;&rsquo; calls
   this <i>permissive coercion.</i>
  </p>
  <hr />
  <a name="equates">
  </a>
  <p>
   <b>6. Questions about equates and declarations.</b>
  </p>
  <p align="justify">
   <b>Q.</b> How do I declare a variable whose value is a procedure?
  </p>
  <p align="justify">
   <b>A.</b> Write the equate
   <b>var</b>&nbsp;<i>p</i>&nbsp;<i>n</i>&nbsp;:&#8722;&nbsp;<i>e,</i>
   where <i>p</i> is the type of the procedure you want, <i>n</i> is
   the name of the variable, and <i>e</i> is an expression that returns a
   procedure of type <i>p.</i> You can write just
   <b>var</b>&nbsp;<i>p</i>&nbsp;<i>n</i> if you want. For
   example, if you want a variable whose values are procedures that take
   integer arguments and return integers, then you&rsquo;d write
   <b>var</b>&nbsp;<b>proc</b>&nbsp;(<i>int</i>)&nbsp;<i>int</i>&nbsp;<i>n.</i>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do not use a pointer to a procedure as you
   would in C, unless you&rsquo;re doing something weird (see below).
   You&rsquo;ll get something that Orson thinks is different from a procedure
   itself.
  </p>
  <p align="justify">
   <b>Q.</b> How do I declare an array of <i>n</i> procedures
   returning procedures returning pointers to characters?
  </p>
  <p align="justify">
   <b>A.</b> Write the equate
   [<i>n</i>]&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>row</b>&nbsp;<i>char</i>&nbsp;<i>p</i>&nbsp;:&#8722;&nbsp;<i>e,</i>
   where <i>e</i> returns such an array. You can leave out the
   <i>e</i> if you declare <i>p</i> as a variable. Note that unlike
   the corresponding type in C, this is easily read from left to right.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I assume you want to represent characters as
   <i>char</i>&rsquo;s, but it will also work with
   <i>char</i>0&rsquo;s. I also assume that you want procedures without
   arguments, and that you want a <i>row</i> pointer to a character. If
   you want the procedure to return a string, then you should use the type
   <i>string</i> instead of <b>row</b>&nbsp;<i>char.</i>
  </p>
  <p align="justify">
   <b>Q.</b> How can I declare a procedure that returns a procedure of the
   same type? I&rsquo;m building a state machine with one procedure for each
   state, each of which returns a procedure for the next state. But I
   can&rsquo;t find a way to declare the procedures.
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t, but you can have the procedure return a
   pointer to a procedure of the same type. (This is what I meant by
   &lsquo;&lsquo;something weird&rsquo;&rsquo; in an earlier question.) For
   example:
  </p>
  <blockquote>
   <p>
    <i>state</i>&nbsp;:&#8722;&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>ref</b>&nbsp;<i>state</i>&nbsp;
    <br />
    <i>nextState</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;()&nbsp;<b>ref</b>&nbsp;<i>state</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(<b>p</b></font>...)
   </p>
  </blockquote>
  <p align="justify">
   You&rsquo;d then dereference the pointer to get the procedure. This is one
   of the few places where you really have to use a pointer to a procedure. I
   assume you want procedures that don&rsquo;t accept arguments, but it&rsquo;s
   easy to modify the above procedures so they do.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If <i>p</i> is a pointer to a procedure
   that doesn&rsquo;t accept arguments, then you call it by writing
   <i>p</i>&#8593;() or <i>p</i>^(). You must include the explicit
   dereference operator &lsquo;&#8593;&rsquo; or &lsquo;^&rsquo;, because Orson
   thinks a pointer to a procedure is different from a procedure itself.
  </p>
  <p align="justify">
   <b>Q.</b> What is the initial value of a variable that is not
   explicitly initialized? For example, suppose I write the equate
   <b>var</b>&nbsp;<i>int</i>&nbsp;<i>v,</i> without the
   :&#8722;&nbsp;<i>e</i> part.
  </p>
  <p align="justify">
   <b>A.</b> In Orson, the value of an uninitialized variable is
   unspecified, which means it&rsquo;s probably garbage. This is true whether
   the variable is declared in a <i>prog</i> clause or in a
   <i>with</i> clause. If you want a variable with a specific initial
   value, you must initialize it yourself.
  </p>
  <p align="justify">
   <b>Q.</b> I used an equate like
   <i>"</i>&#8743;<i>"</i>&nbsp;:&#8722;&nbsp;<i>x</i> to
   redefine the &lsquo;&#8743;&rsquo; operator. But later, when I wrote
   <i>a</i>&nbsp;&#8743;&nbsp;<i>b,</i> Orson used the old
   definition. Why?
  </p>
  <p align="justify">
   <b>A.</b> You can redefine an operator only if it is implemented as a
   method. The operators <b>also</b>, <b>and</b>, <b>or</b>,
   <b>ref</b>, <b>row</b>, <b>type</b>, <b>var</b>,
   &lsquo;&nbsp;;&nbsp;&rsquo;, &lsquo;&#8743;&rsquo;, and
   &lsquo;&#8744;&rsquo; are not implemented as methods. They&rsquo;re built
   directly into Orson, so you can&rsquo;t redefine them. You can bind quoted
   names that resemble these operators (like
   <i>"</i>&#8743;<i>"</i>), but the operators themselves
   aren&rsquo;t affected. You could call
   <i>"</i>&#8743;<i>"</i>(<i>a,</i>&nbsp;<i>b</i>) if you
   want, however.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The operators <b>also, var,</b> and
   &lsquo;&nbsp;;&nbsp;&rsquo; are built in because I don&rsquo;t know why
   you&rsquo;d want to redefine them, unless you want to write programs that
   are hard to understand. Also, they&rsquo;re used a lot, and building them
   into Orson makes them more efficient than if they were defined as methods.
   The operators <b>and, or, ref, row, type,</b> &lsquo;&#8743;&rsquo;,
   and &lsquo;&#8744;&rsquo; are built in because they don&rsquo;t evaluate all
   their arguments, or because they evaluate them in special ways.
  </p>
  <p align="justify">
   <b>Q.</b> I used an equate like
   <i>"</i>&#8730;<i>"</i>&nbsp;:&#8722;&nbsp;<i>y</i> to define
   a square-root operator. But later, when I wrote &#8730;<i>a</i> to
   compute the square root of <i>a,</i> Orson gave me an error message.
   Why?
  </p>
  <p align="justify">
   <b>A.</b> Orson doesn&rsquo;t know that &lsquo;&#8730;&rsquo; is an
   operator. It only knows about a few operator tokens, and you can&rsquo;t add
   new ones. Binding the quoted name <i>"</i>&#8730;<i>"</i>
   doesn&rsquo;t make a new operator. You could call
   <i>"</i>&#8730;<i>"</i>(<i>a</i>) if you want, however.
  </p>
  <p align="justify">
   <b>Q.</b> Why didn&rsquo;t Orson give me error messages when I wrote
   <i>"</i>&#8743;<i>"</i>&nbsp;:&#8722;&nbsp;<i>x</i> and
   <i>"</i>&#8730;<i>"</i>&nbsp;:&#8722;&nbsp;<i>y</i> then?
  </p>
  <p align="justify">
   <b>A.</b> Quoted names can have any visible characters inside them
   (except for quotes), so <i>"</i>&#8743;<i>"</i> and
   <i>"</i>&#8730;<i>"</i> are perfectly reasonable. Why should they
   be errors? I can imagine uses for them.
  </p>
  <hr />
  <a name="forms">
  </a>
  <p>
   <b>7. Questions about forms.</b>
  </p>
  <p align="justify">
   <b>Q.</b> How are forms different from Lisp macros?
  </p>
  <p align="justify">
   <b>A.</b> By <i>Lisp,</i> I&rsquo;ll assume you mean Common Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990].
   </a>
   If you meant some other dialect, then the following may only provide partial
   answers to your question.
  </p>
  <ul>
   <li>
   <p align="justify">
    Form bodies use the same notation as everything else in Orson. This in not
    true of Common Lisp, in which most macros are written as expressions that
    return lists, which in turn represent other expressions. Common
    Lisp&rsquo;s <i>backquote</i> mechanism helps abbreviate this. Orson
    doesn&rsquo;t use (and doesn&rsquo;t need) anything like backquotes.
   </p>
   <li>
   <p align="justify">
    The arguments of a form are evaluated (they&rsquo;re
    <i>transformed</i>) before the form is applied. This is not true of
    Common Lisp macros, whose arguments are not evaluated.
   </p>
   <li>
   <p align="justify">
    Forms are properly lexically scoped. This is not true of Common Lisp
    macros, whose arguments can violate lexical scoping. For example, if an
    argument <tt>x</tt> is passed to a macro that uses <tt>x</tt> as
    a local variable, then the two <tt>x</tt>&rsquo;s will be confused.
    Such <i>name capture</i> cannot occur in Orson.
   </p>
   <li>
   <p align="justify">
    Forms are typed. Specifically, form parameters have types, and the result
    returned by a form also has a type. This is not true of Common Lisp macros,
    because the language doesn&rsquo;t really have types in the sense that
    Orson does.
   </p>
   <li>
   <p align="justify">
    Generic forms require that their arguments have types which are related to
    each other in specific ways. This is not true of Common Lisp macros, again
    because the language doesn&rsquo;t really have types.
   </p>
   <li>
   <p align="justify">
    Forms can automatically inherit behavior from other forms that are defined
    in surrounding scopes. This is not true of Common Lisp macros.
   </p>
   <li>
   <p align="justify">
    Alternate forms can be called with varying numbers and types of arguments.
    Common Lisp macros can be written to simulate this (except for the part
    about types).
   </p>
  </ul>
  <p align="justify">
   Having said all that, Common Lisp macros work at a lower level of
   abstraction than Orson forms, and are therefore potentially more powerful.
   However, after writing lots of Orson code, I haven&rsquo;t found anything
   that I wanted to do with Orson forms, but could not. Your experience may be
   different.
  </p>
  <p align="justify">
   <b>Q.</b> How are forms different from C macros?
  </p>
  <p align="justify">
   <b>A.</b> Some parts of the previous answer are applicable here. Also,
   C macros work with strings of characters, or with strings of tokens, while
   Orson forms work directly with the internal representations of expressions.
   (Some authors call these internal representations &lsquo;&lsquo;abstract
   syntax trees.&rsquo;&rsquo;) As a result, you need not include extra
   parentheses in Orson forms as you must in C macros.
  </p>
  <p align="justify">
   <b>Q.</b> My Orson program takes a very long time to compile, and/or
   makes very large binary files. I had to tell the Orson compiler to use more
   memory, too. Why is Orson so slow and so inefficient?
  </p>
  <p align="justify">
   <b>A.</b> It isn&rsquo;t. You probably have large forms that are used
   repeatedly in your program. If possible, change them to procedures.
   Sometimes this requires nothing more than changing the name <b>form</b>
   to <b>proc.</b> This works because forms use the same notation for
   expressions as the rest of Orson, the subject of a previous question.
  </p>
  <p align="justify">
   <b>Q.</b> Form subsumption doesn&rsquo;t always detect a member form
   that can never be called. Here&rsquo;s an alternate form which returns a
   string that is the name of an integer type.
  </p>
  <blockquote>
   <p>
    <i>intkToString</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>0)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int0''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>1)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int1''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>2)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int2''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>inj</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''unknown''))
   </p>
  </blockquote>
  <p align="justify">
   Here the last member form can never be called, because an integer type
   (<i>inj</i>) is either <i>int</i>0, <i>int</i>1, or
   <i>int</i>2. However, the last member form is not subsumed.
  </p>
  <p align="justify">
   <b>A.</b> You&rsquo;re wrong, because Orson doesn&rsquo;t say how many
   integer types there are. All it says is that an implementation of Orson must
   provide <i>int</i>0, <i>int</i>1, and <i>int</i>2, at
   minimum. However, the last member form could still be called in an
   implementation of Orson that provides <i>int</i>3. You could add a
   member that handles <i>int</i>3&rsquo;s, but then the last member could
   be called in an implementation that provides <i>int</i>4, etc.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are infinitely many integer types, but
   only finitely many are provided by any given implementation. Someday, when
   we&rsquo;re all using computers with 1024-bit words, Orson will be ready
   with the integer type <i>int</i>7 (2&#8311;&nbsp;byte
   &#215;&nbsp;8&nbsp;bit&nbsp;byte&#8315;&#185;&nbsp;= 1024 bits). It could
   happen.
  </p>
  <p align="justify">
   <b>Q.</b> But form subsumption <i>still</i> doesn&rsquo;t always
   detect a member form that can never be called. Here&rsquo;s an alternate
   form which returns a string that is the name of a numeric type.
  </p>
  <blockquote>
   <p>
    <i>numToString</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>inj</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''integer''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>rej</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''real''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>num</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''unknown''))
   </p>
  </blockquote>
  <p align="justify">
   The last member form can never be called, because a numeric type
   (<i>num</i>) is either an integer type (<i>inj</i>) or a real type
   (<i>rej</i>). However, the last member form is not subsumed.
  </p>
  <p align="justify">
   <b>A.</b> You&rsquo;re <i>still</i> wrong, because if jokers are
   considered to be sets of objects, then no joker is necessarily the union of
   any other jokers. The joker <i>num</i> is not necessarily the union of
   <i>inj</i> and <i>rej.</i> For example, in a prelude that provides
   complex numbers, <i>num</i> might be the union of <i>coj</i> (a
   joker describing complex numbers), <i>inj,</i> and <i>rej.</i> If
   <i>z</i> is a complex number, then
   <i>numToString</i>(<i>z</i>) would call the last member form, and
   return ''unknown''.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jokers are defined this way is so Orson might
   be extended without breaking existing programs. A program that works under
   the present Orson compiler, where the numeric jokers are <i>inj</i> and
   <i>rej,</i> should work the same way under a future Orson compiler,
   where the numeric jokers are <i>inj, rej,</i> and <i>coj.</i>
  </p>
  <p align="justify">
   <b>Q.</b> I can write a form that takes a variable number of arguments,
   by using a list. How can I write a procedure that takes a variable number of
   arguments?
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t. You can, however, write a form that takes
   its arguments in a list, then calls a procedure to do its work. It might
   copy its arguments into an execution object and then call the procedure on
   that object. For example, the form <i>sum</i> uses the procedure
   <i>Sum</i> to compute the sum of zero or more integers, so that the
   call <i>sum</i>(:&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4) returns 10.
  </p>
  <blockquote>
   <p>
    <i>sum</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i></font>(<b>form</b>&nbsp;(<i>list</i>&nbsp;<i>l</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>(</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>w</b></font><i>int</i>&nbsp;<i>n</i>&nbsp;:&#8722;&nbsp;<i>length</i>(<i>l</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>w</b></font><b>var</b>&nbsp;[<i>n</i>]&nbsp;<i>int</i>&nbsp;<i>a</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((</font><b>do</b>&nbsp;(<b>for</b>&nbsp;<i>inj</i>&nbsp;<i>k</i>&nbsp;<b>in</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>do</b>&nbsp;(</font><b>do</b>&nbsp;<i>a</i>[<i>k</i>]&nbsp;:=&nbsp;<i>l</i>[<i>k</i>])&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>do</b>&nbsp;</font><i>Sum</i>(<i>n</i>,&nbsp;<i>a</i>&#8595;)))&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i></font>
    <br />
    <i>Sum</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>,&nbsp;<b>row</b>&nbsp;<i>int</i>&nbsp;<i>a</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>s</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((</font><b>do</b>&nbsp;(<b>for</b>&nbsp;<i>int</i>&nbsp;<i>k</i>&nbsp;<b>in</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((<b>do</b>&nbsp;(</font><b>do</b>&nbsp;<i>s</i>&nbsp;+=&nbsp;<i>a</i>[<i>k</i>])&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((<b>do</b>&nbsp;</font><i>s</i>))
   </p>
  </blockquote>
  <p align="justify">
   For simplicity, I&rsquo;ve left out error checking on the list
   <i>l.</i> Using an array isn&rsquo;t necessarily the only way to do
   something like this. There&rsquo;s a technical report that explains other
   ways.
  </p>
  <p align="justify">
   <b>Q.</b> I&rsquo;ve redefined the form <i>"</i>+<i>"</i> so
   it can add two complex numbers, like this:
  </p>
  <blockquote>
   <p>
    <i>compl</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>"</i>+<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>form</b>&nbsp;(<i>compl</i>&nbsp;<i>l</i>,&nbsp;<i>compl</i>&nbsp;<i>r</i>)&nbsp;<i>compl</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>compl</i>&nbsp;<i>z</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((</font><b>do</b>&nbsp;<i>z</i>.<i>re</i>&nbsp;:=&nbsp;<i>l</i>.<i>re</i>&nbsp;+&nbsp;<i>l</i>.<i>re</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>do</b>&nbsp;</font><i>z</i>.<i>im</i>&nbsp;:=&nbsp;<i>l</i>.<i>im</i>&nbsp;+&nbsp;<i>r</i>.<i>im</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>do</b>&nbsp;</font><i>z</i>))
   </p>
  </blockquote>
  <p align="justify">
   That works fine, but if <i>z</i>&#8321; has the type
   <b>var</b>&nbsp;<i>compl,</i> and <i>z</i>&#8322; has the
   type <i>compl,</i> I get an error message when I write
   <i>z</i>&#8321;&nbsp;+=&nbsp;<i>z</i>&#8322;. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> Orson doesn&rsquo;t know about the relationship between
   <i>"</i>+<i>"</i> and <i>"</i>+=<i>"</i>. Redefining one
   doesn&rsquo;t also redefine the other. If you want
   <i>z</i>&#8321;&nbsp;+=&nbsp;<i>z</i>&#8322; to work, you must
   redefine <i>"</i>+=<i>"</i> yourself, maybe like this.
  </p>
  <blockquote>
   <p>
    <i>"</i>+=<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>form</b>&nbsp;(<b>var</b>&nbsp;<i>compl</i>&nbsp;<i>l</i>,&nbsp;<i>compl</i>&nbsp;<i>r</i>)&nbsp;<i>comp</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>f</b></font><i>l</i>&nbsp;:=&nbsp;<i>l</i>&nbsp;+&nbsp;<i>r</i>)
   </p>
  </blockquote>
  <p align="justify">
   This works because the <i>"</i>+<i>"</i> inside the form knows how
   to do complex addition: it&rsquo;s the operator you redefined above. As long
   as they&rsquo;re redefined in the same <i>prog</i> or <i>with</i>
   clause, you can redefine the forms in any order (<i>"</i>+<i>"</i>
   before <i>"</i>+=<i>"</i> or <i>"</i>+=<i>"</i> before
   <i>"</i>+<i>"</i>) and Orson won&rsquo;t get confused.
  </p>
  <p align="justify">
   <b>Q.</b> Then why does
   <i>z</i>&#8321;&nbsp;:=&nbsp;<i>z</i>&#8322; still work? Why
   didn&rsquo;t I have to redefine <i>"</i>:=<i>"</i> so it works
   with the type <i>comp</i>?
  </p>
  <p align="justify">
   <b>A.</b> The prelude defines <i>"</i>:=<i>"</i> like this,
   so it works with any object that can be the base type of a variable type
   (any <i>mut</i> object).
  </p>
  <blockquote>
   <p>
    <i>"</i>:=<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>mut</i>&nbsp;<i>lType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>g</b></font><b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>lType</i>&nbsp;<i>rType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>gg</b></font><b>form</b>&nbsp;(<b>var</b>&nbsp;<i>lType</i>&nbsp;<i>l</i>,&nbsp;<i>rType</i>&nbsp;<i>r</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>ggf</b></font>?<i>varSet</i>(<i>l</i>,&nbsp;<i>r</i>))
   </p>
  </blockquote>
  <p align="justify">
   The <i>gen</i> prefixes make sure the types of the variable and its new
   value are compatible. The hook ?<i>varSet</i> then does the assignment
   using &lsquo;&lsquo;magic&rsquo;&rsquo; mechanisms that are not available to
   ordinary programmers.
  </p>
  <p align="justify">
   <b>Q.</b> I want to write a form that evaluates to a variable, so I can
   call it on the left side of an assignment operator like
   <i>"</i>:=<i>".</i> However, I can&rsquo;t make it work.
  </p>
  <blockquote>
   <p>
    [256]&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>map</i>&nbsp;
    <br />
    <font color="#FFFFFF">[</font>
    <br />
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>mapped</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>int</i>&nbsp;<i>k</i>)&nbsp;<b>var</b>&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>if</b>&nbsp;0&nbsp;&#8804;&nbsp;<i>k</i>&nbsp;&lt;&nbsp;<i>length</i>(<i>map</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>then</b>&nbsp;<i>map</i>[<i>k</i>]&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>else</b>&nbsp;<i>throw</i>(<i>"</i>index&nbsp;out&nbsp;of&nbsp;range<i>"</i>)))
   </p>
  </blockquote>
  <p align="justify">
   The idea is that if <i>k</i> is a legal index for the array
   <i>map,</i> then <i>mapped</i>(<i>k</i>) should evaluate to
   the variable at that index. If <i>k</i> isn&rsquo;t a legal index, then
   it should throw an exception. Unfortunately, Orson always coerces the
   variable to its value.
  </p>
  <p align="justify">
   <b>A.</b> The problem is that if an expression inside an <i>if</i>
   clause evaluates to a variable, then the variable gets coerced to its value.
   So your form doesn&rsquo;t evaluate to the integer variable at index
   <i>k,</i> but rather to the integer at index <i>k.</i> You might
   think that you could fix the form like this:
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>mapped</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>int</i>&nbsp;<i>k</i>)&nbsp;<b>var</b>&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>if</b>&nbsp;&#172;&nbsp;(0&nbsp;&#8804;&nbsp;<i>k</i>&nbsp;&lt;&nbsp;<i>length</i>(<i>map</i>))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>then</b>&nbsp;<i>throw</i>(<i>"</i>index&nbsp;out&nbsp;of&nbsp;range<i>"</i>))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font><i>map</i>[<i>k</i>])
   </p>
  </blockquote>
  <p align="justify">
   But this doesn&rsquo;t work either: it still transforms to the integer at
   index <i>k.</i> The reason is that <i>map</i>[<i>k</i>] is
   the last expression in a subsequence (Orson has silently inserted a
   semicolon after the <i>if</i> clause). An expression in a subsequence
   that returns a variable gets coerced to the variable&rsquo;s value. The
   solution maybe isn&rsquo;t obvious:
  </p>
  <blockquote>
   <p>
    <i>mapped</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>int</i>&nbsp;<i>k</i>)&nbsp;<b>var</b>&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b></font><i>map</i>[&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>m</i></font>(<b>if</b>&nbsp;0&nbsp;&#8804;&nbsp;<i>k</i>&nbsp;&lt;&nbsp;<i>length</i>(<i>map</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>m</i>(</font><b>then</b>&nbsp;<i>k</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>m</i>(</font><b>else</b>&nbsp;<i>throw</i>(<i>"</i>index&nbsp;out&nbsp;of&nbsp;range<i>"</i>))])
   </p>
  </blockquote>
  <p align="justify">
   Now <i>map</i>[...] appears directly as the form&rsquo;s body, so
   it&rsquo;s not part of a subsequence, and the variable to which it evaluates
   won&rsquo;t be coerced. Form bodies, lists, some arguments to methods, and
   <b>type</b> prefixes are the only places in Orson where variables
   aren&rsquo;t coerced to their values.
  </p>
  <hr />
  <a name="parens">
  </a>
  <p>
   <b>8. Questions about parentheses.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Orson gave me all kinds of error messages when I wrote this.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font><b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>else</b>&nbsp;<i>x</i>
   </p>
  </blockquote>
  <p align="justify">
   Why did it do that?
  </p>
  <p align="justify">
   <b>A.</b> You didn&rsquo;t put parentheses around the <i>proc</i>
   clause, or around the <i>if</i> clause. You should have written this.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>else</b>&nbsp;<i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   Parentheses are required parts of clauses. As a result, you don&rsquo;t need
   silly things like &lsquo;<tt>{</tt>&rsquo; and
   &lsquo;<tt>}</tt>&rsquo;, or like <b>begin</b> and
   <b>end.</b>
  </p>
  <p align="justify">
   <b>Q.</b> It&rsquo;s hard to keep all those parentheses balanced, so I
   started writing them like they&rsquo;re curly brackets in C.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font><b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b></font>(&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>else</b>&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b></font>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>)
   </p>
  </blockquote>
  <p align="justify">
   What do you think?
  </p>
  <p align="justify">
   <b>A.</b> I think it&rsquo;s ugly, because it uses too much whitespace.
   It also seems silly, since many text editors will help you balance
   parentheses. If you like it, though, go ahead and use it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As far as I&rsquo;m concerned, you can format
   and indent programs however you like, as long as you do so consistently.
   However, you may have to change your style if you write code that other
   people (colleagues or teachers) need to look at. This is true even in a
   language like Orson that&rsquo;s intended for programmers who don&rsquo;t
   work in big groups.
  </p>
  <p align="justify">
   <b>Q.</b> Orson uses too many parentheses. It&rsquo;s as bad as Lisp!
  </p>
  <p align="justify">
   <b>A.</b> Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990]
   </a>
   is my favorite programming language. If we all wrote in Lisp, then many of
   our programming problems would go away. But that&rsquo;s not what you meant.
   For the sake of argument, let&rsquo;s assume parentheses are evil, so
   languages should need as few as possible. I claim that for some programs,
   Orson uses <i>fewer</i> parentheses than other languages. Consider the
   following C fragment:
  </p>
  <blockquote>
   <p>
    <tt>if&nbsp;(a&nbsp;&lt;&nbsp;b)&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;count&nbsp;-=&nbsp;1;&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;-1;&nbsp;</tt>
    <br />
    <tt>}&nbsp;</tt>
    <br />
    <tt>else&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;count&nbsp;+=&nbsp;1;&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;1;&nbsp;</tt>
    <br />
    <tt>}&nbsp;</tt>
    <br />
    <tt>else&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;0;&nbsp;</tt>
    <br />
    <tt>}</tt>
   </p>
  </blockquote>
  <p align="justify">
   It uses ten parentheses, if you count braces. An equivalent Orson fragment
   looks like this.
  </p>
  <blockquote>
   <p>
    (<b>if</b>&nbsp;<i>a</i>&nbsp;&lt;&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>then</b>&nbsp;<i>count</i>&nbsp;&#8722;=&nbsp;1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>then</b>&nbsp;</font>&#8722;1&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>else</b>&nbsp;<b>if</b>&nbsp;<i>a</i>&nbsp;&gt;&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;</font><b>then</b>&nbsp;<i>count</i>&nbsp;+=&nbsp;1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;<b>then</b>&nbsp;</font>1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;</font><b>else</b>&nbsp;0)
   </p>
  </blockquote>
  <p align="justify">
   The Orson fragment uses only <i>two</i> parentheses, and it
   doesn&rsquo;t need semicolons or <i>return</i> statements either. Of
   course this is only a small fragment of a program, and the results will
   depend on the brace style you use. For example, you don&rsquo;t really need
   braces around the last <i>return</i> statement.
  </p>
  <p align="justify">
   <b>Q.</b> If you like Lisp so much, then why doesn&rsquo;t Orson look
   like Lisp?
  </p>
  <p align="justify">
   <b>A.</b> One of Lisp&rsquo;s many advantages is that its programs are
   expressed using a simple prefix notation, so programmers need not remember
   the details of a complex syntax. The syntax also makes it easy to extend the
   language, typically by using macros.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unfortunately, Lisp has scared most
   programmers away, maybe because it reminds them of mathematics (it has that
   spooky Greek letter &#955;). Even the functional programming community has
   switched to languages with a more familiar appearance, such as Haskell
   <a href="#hud1992">
    [<small>HUD</small> 1992].
   </a>
   It saddens me to say this, and I hope I&rsquo;m wrong, but Lisp is dying. We
   should try to steal what we can from its corpse before they bury it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson&rsquo;s syntax is intended as a
   compromise between the simplicity of Lisp and the familiarity of other
   languages. The <small>BNF</small> for Orson
   <a href="#moe2014">
    [<small>MOE</small> 2014]
   </a>
   fits on about four pages. I might have squeezed it into three if I
   hadn&rsquo;t restricted myself to classical 1960 <small>BNF</small>.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The current Orson-to-<small>GCC</small>
   translator resembles a Lisp interpreter internally, and Orson forms are
   really just a typed &#955;-calculus. However, you can write Orson programs
   without knowing that.
  </p>
  <hr />
  <a name="pointers">
  </a>
  <p>
   <b>9. Questions about pointers.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I&rsquo;m deliberately trying to dereference <i>nil</i>
   to cause an error during execution, so I can get the attention of a
   debugger. However, I can&rsquo;t figure out how to do it! If I write
   <i>nil</i>&#8593; or
   <i>nil</i>{<b>ref</b>&nbsp;<i>void</i>}&#8593;, Orson gives
   me an error message. How does Orson know what I&rsquo;m trying to do, and
   how can I fool it?
  </p>
  <p align="justify">
   <b>A.</b> The current implementation of Orson tests during
   transformation if (1) you&rsquo;re trying to dereference <i>nil,</i>
   (2) you&rsquo;re trying to dereference any pointer whose type is
   <i>null,</i> and (3) you&rsquo;re trying to cast a pointer other than
   <i>nil</i> to <i>null.</i> The way to avoid the tests is to use a
   pointer variable, since Orson can&rsquo;t test the values of variables
   during transformation.
  </p>
  <blockquote>
   <p>
    <b>var</b>&nbsp;<b>ref</b>&nbsp;<i>void</i>&nbsp;<i>p</i>&nbsp;:&#8722;&nbsp;<i>nil</i>&nbsp;
    <br />
    <i>bang</i>&nbsp;:&#8722;&nbsp;(<b>form</b>&nbsp;()&nbsp;<i>void</i>:&nbsp;<i>p</i>&#8593;)
   </p>
  </blockquote>
  <p align="justify">
   You can now call <i>bang</i>() to cause an execution error.
  </p>
  <hr />
  <a name="string">
  </a>
  <p>
   <b>10. Questions about strings.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Orson represents a string as a pointer to an array of bytes,
   terminated by a zero-byte. That is a poor representation, because you
   can&rsquo;t compute a string&rsquo;s length without traversing it. Why does
   Orson represent strings that way?
  </p>
  <p align="justify">
   <b>A.</b> Strings are the favorite data structure of bad programmers.
   They want to represent most objects as strings. They would be better off
   with data structures that are specifically designed for the objects they
   want to represent. You should use strings only when you want to print things
   (although there are exceptions to this general rule).
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This means the representation used for
   strings is largely irrelevant, and the designer of a programming language is
   free to pick any representation that is convenient. I designed Orson to use
   the same representation as does C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   It&rsquo;s convenient because it lets Orson use library procedures that have
   already been written for C, without change.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you&rsquo;re using strings only for
   printing, then you must traverse them anyway, to visit their characters. You
   might need to find the length of a string before you print it. However,
   traversing a string twice, first to find its length, and then to print it,
   shouldn&rsquo;t affect run time much, because traversal should be much
   faster than printing.
  </p>
  <hr />
  <a name="tokens">
  </a>
  <p>
   <b>11. Questions about tokens.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I get an error whenever I use a dash. For example, I get an
   error when I write <i>j</i>&nbsp;:&#8212;&nbsp;1, and I get another
   error when I write <i>j</i>&nbsp;&#8211;&nbsp;1. What am I doing wrong?
  </p>
  <p align="justify">
   <b>A.</b> Maybe you&rsquo;re using the wrong kind of dash. Orson
   programs can be written in Unicode
   <a href="#uni2006">
    [<small>UNI</small> 2006],
   </a>
   which has many characters that look like dashes. For example:
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;-&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>HYPHEN</small>-<small>MINUS</small> (U+002D),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8208;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>HYPHEN</small> (U+2010),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8209;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>NON</small>-<small>BREAKING HYPHEN</small>
       (U+2011),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8210;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>FIGURE DASH</small> (U+2012),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8211;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is an <small>EN DASH</small> (U+2013),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8212;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is an <small>EM DASH</small> (U+2014),
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8213;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>HORIZONTAL BAR</small> (U+2015), and
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8722;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>MINUS SIGN</small> (U+2212).
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <p align="justify">
   This may not be a complete list. Some of them may even look the same,
   depending on your browser&rsquo;s default font, but they are different
   characters, with different codes. Sheesh!
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson recognizes only two of these:
   &lsquo;&nbsp;-&nbsp;&rsquo;, a
   <small>HYPHEN</small>-<small>MINUS</small> (U+002D), which is the
   familiar <small>ASCII</small> character that you get from
   <small>US</small> keyboards, and &lsquo;&nbsp;&#8722;&nbsp;&rsquo;, a
   <small>MINUS SIGN</small> (U+2212), which you can get from a character
   palette. You can write sums and terms using either character. You can also
   write a colon-dash in an equate using either character.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Technically, the
   <small>HYPHEN</small>-<small>MINUS</small> character is preferred
   in English text, and the <small>MINUS SIGN</small> character is
   preferred in Orson code. The Orson library uses this convention. However,
   you don&rsquo;t need to care unless you&rsquo;re modifying the definition of
   the subtraction operator in the Standard Prelude, or unless you&rsquo;re
   anal-retentively fussy about how your programs look, like I am.
  </p>
  <p align="justify">
   <b>Q.</b> You use &lsquo;&lt;&gt;&rsquo; as the operator that tests for
   inequality. By analogy with &lsquo;&lt;=&rsquo; and &lsquo;&gt;=&rsquo;,
   this suggests <i>less than or greater than.</i> However, some objects,
   like complex numbers, can be unequal without being less or greater. You
   should use something else.
  </p>
  <p align="justify">
   <b>A.</b> I agree, but all the good choices in
   <small>ASCII</small> are taken. I can&rsquo;t use &lsquo;/=&rsquo;,
   &lsquo;|=&rsquo;, or &lsquo;~=&rsquo; because they&rsquo;re assignment
   operators. I can&rsquo;t use &lsquo;!=&rsquo; because an exclamation mark
   denotes a comment. I can&rsquo;t use &lsquo;#&rsquo; because it denotes an
   integer constant. I don&rsquo;t want to use &lsquo;\=&rsquo; because
   it&rsquo;s too easily confused with &lsquo;/=&rsquo;. Things like
   &lsquo;=/=&rsquo; and &lsquo;=/&rsquo; are ugly. A reserved name like
   <b>neq</b> is even uglier: it looks like Klingon
   <a href="#okr1992">
    [<small>OKR</small> 1992].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you use Orson on a system that supports
   Unicode (and most systems do) then you can write the not-equals sign
   &lsquo;&#8800;&rsquo; as a synonym for &lsquo;&lt;&gt;&rsquo;. If you
   don&rsquo;t, then you can still write
   <b>not</b>&nbsp;(<i>a</i>&nbsp;=&nbsp;<i>b</i>).
  </p>
  <p align="justify">
   <b>Q.</b> If &lsquo;&lt;&gt;&rsquo; and &lsquo;&#8800;&rsquo; test for
   inequality, then what about this?
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;A<small>LMOST</small>&nbsp;<small>WRONG</small>.&nbsp;
    <br />
    <i>nonzero</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>if</b>&nbsp;<i>n</i>&nbsp;!=&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;zero.'')))
   </p>
  </blockquote>
  <p align="justify">
   It works correctly. Why?
  </p>
  <p align="justify">
   <b>A.</b> Well, it <i>compiles</i> correctly; whether it
   <i>works</i> correctly is a different question. The exclamation point
   starts a comment, which includes the rest of the line. So you&rsquo;ve
   really written a procedure like this.
  </p>
  <blockquote>
   <p>
    <i>nonzero</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>if</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;zero.'')))
   </p>
  </blockquote>
  <p align="justify">
   It <i>seems</i> to work correctly because the <i>if</i> clause
   tests if the expression that comes after <b>if</b> is not zero. If so,
   then it evaluates the expression that comes after <b>then.</b> You got
   lucky, but you wouldn&rsquo;t have if you&rsquo;d written this.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>unequal</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>a</i>,&nbsp;<i>int</i>&nbsp;<i>b</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i>(</font>(<b>if</b>&nbsp;<i>a</i>&nbsp;!=&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;equal.'')))
   </p>
  </blockquote>
  <p align="justify">
   Something like this happened to me when I got C and Orson confused. I
   therefore considered changing the definition of comments so that the
   exclamation point must be followed by a blank. However, I realized that this
   wouldn&rsquo;t stop similarly confused people from using the exclamation
   mark as the <small>NOT</small> operator, so I never made the change.
  </p>
  <p align="justify">
   <b>Q.</b> There&rsquo;s something wrong with string literals. When I
   write <i>"</i>Hello,&nbsp;world!<i>"</i> with quotation marks, I
   get an error message about an undeclared name.
  </p>
  <p align="justify">
   <b>A.</b> That&rsquo;s because
   <i>"</i>Hello,&nbsp;world!<i>"</i> isn&rsquo;t a string literal.
   It&rsquo;s a quoted name. You get an error because the name isn&rsquo;t
   declared. Write ''Hello,&nbsp;world!'' instead. That&rsquo;s
   <i>apostrophe, apostrophe, hello, comma, blank, world, exclamation point,
   apostrophe, apostrophe.</i>
  </p>
  <p align="justify">
   <b>Q.</b> There&rsquo;s something wrong with character literals. When I
   write <i>"</i>x<i>"</i> with quotation marks I get an error
   message about an undeclared name.
  </p>
  <p align="justify">
   <b>A.</b> That&rsquo;s because <i>"</i>x<i>"</i> isn&rsquo;t
   a character literal. It&rsquo;s a quoted name. You get an error because the
   name isn&rsquo;t declared. Write 'x' instead. That&rsquo;s
   <i>apostrophe, x, apostrophe.</i>
  </p>
  <p align="justify">
   <b>Q.</b> Why does Orson use such a goofy notation for character
   literals and string literals?
  </p>
  <p align="justify">
   <b>A.</b> Orson needs to have quoted names for operators like
   <i>"</i>+<i>"</i> and <i>"</i>:=<i>".</i> I think quoted
   names should be delimited by single characters, and given the limitations of
   the <small>ASCII</small> character set, the best choice is the
   quotation mark &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;. Orson must be
   compatible with <small>ASCII</small>, so its programs can be typed on
   ordinary <small>US</small> keyboards, and so they can be run on
   computers that don&rsquo;t support Unicode.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Once I&rsquo;d used the quotation mark, I had
   to use other characters to notate character and string literals. I also had
   to notate character and string literals in different ways, so Orson can tell
   them apart. For example, Pascal
   <a href="#jen1974">
    [<small>JEN</small> 1974]
   </a>
   used a single quote &lsquo;&nbsp;'&nbsp;&rsquo; to notate both
   characters and strings, so that 'x' was a character literal. It had
   <i>no way</i> to notate a string literal with exactly one character!
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Given these constraints, I decided to notate
   characters with single apostrophes, like 'x', because it&rsquo;s what C
   uses
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   Since strings are like characters but &lsquo;&lsquo;bigger,&rsquo;&rsquo; I
   decided to notate them with two apostrophes, like
   ''Hello,&nbsp;world!''. If Orson had objects bigger than strings, but
   still like strings, then maybe I&rsquo;d notate them using <i>three</i>
   apostrophes.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By the way, Orson&rsquo;s notation for
   strings makes it easy to write ''Type&nbsp;"quit"&nbsp;to&nbsp;exit''
   and ''Type&nbsp;'exit'&nbsp;to&nbsp;quit'' without escape characters
   such as backslashes. I hope these examples are easy to read on your browser.
  </p>
  <p align="justify">
   <b>Q.</b> How can I write the name of a constant in upper case letters,
   like in C and Java? A name that starts with an upper case letter is a secret
   name, so I can&rsquo;t use it outside the <i>prog</i> clause where
   it&rsquo;s defined.
  </p>
  <p align="justify">
   <b>A.</b> There&rsquo;s no way to do that. This is deliberate. Writing
   constant names in upper case is a bad idea, even in C-like languages,
   despite what style guides, teachers, and textbooks say. Here&rsquo;s why.
  </p>
  <ul>
   <li>
   <p align="justify">
    Someday you might want to turn the constant into a variable. For example,
    you might decide that its value should be a run-time option. Then you must
    change the name wherever it appears.
   </p>
   <li>
   <p align="justify">
    In Orson, a name&rsquo;s type tells you if it&rsquo;s a constant or a
    variable, not the way it&rsquo;s spelled. You shouldn&rsquo;t encode an
    object&rsquo;s type into its name, as in the &lsquo;&lsquo;Hungarian
    Style,&rsquo;&rsquo; because then you must change the name if you ever
    change its type.
   </p>
   <li>
   <p align="justify">
    Orson constant names are different from C constant names. For example, in
    Orson you can bind a constant name to the value of a variable during
    execution. You can&rsquo;t do that in C, so you shouldn&rsquo;t write
    constant names as you do in C.
   </p>
   <li>
   <p align="justify">
    Orson uses constant names more often than C. It&rsquo;s a hassle to spell
    them in a special way.
   </p>
   <li>
   <p align="justify">
    It&rsquo;s ugly. It looks like you&rsquo;re SHOUTING at the person reading
    your code. I don&rsquo;t like to be shouted at, and probably you
    don&rsquo;t either.
   </p>
  </ul>
  <p align="justify">
   If you really must use capital letters for some reason, you can write a
   quoted name, as in <i>"</i>CONSTANT<i>",</i> but that&rsquo;s ugly
   too. If you&rsquo;d rather use C, then why are you using Orson?
  </p>
  <p align="justify">
   <b>Q.</b> But then why are secret names spelled differently from other
   names? If you want to change a secret name into a plain name, then you must
   change it whenever it appears.
  </p>
  <p align="justify">
   <b>A.</b> Yes, secret names are inconsistent with what I just said.
   However, having secret names spelled with initial upper case letters was
   very easy to implement. It also lets secret names be parts of types, like
   tuple types and symbol types.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It&rsquo;s also simpler than declaring names
   with a special secret type prefix, like <b>sec</b>, so that
   <b>sec</b>&nbsp;<b>var</b>&nbsp;<i>t</i>&nbsp;<i>v</i>
   would declare <i>v</i> to be a secret variable name. If Orson had a
   <b>sec</b> prefix, then it would raise lots of questions that I
   don&rsquo;t know how to answer. For example, is
   <b>sec</b>&nbsp;<b>var</b>&nbsp;<i>t</i> different from
   <b>var</b>&nbsp;<b>sec</b>&nbsp;<i>t,</i> and if so, how? Is
   <b>sec</b>&nbsp;<b>sec</b>&nbsp;<i>t</i> different from
   <b>sec</b>&nbsp;<i>t,</i> and if so, how? What does it mean to use
   <b>sec</b>&nbsp;<i>t</i> as a parameter type in a method, or as a
   yield type in a method? Orson&rsquo;s type system is complex enough already.
  </p>
  <p align="justify">
   <b>Q.</b> How can I make a name that&rsquo;s both a quoted name and a
   secret name?
  </p>
  <p align="justify">
   <b>A.</b> There ought to be a way to do this, but there isn&rsquo;t.
   Sorry. A secret name starts with an upper case Roman letter. A quoted name
   starts with a quote &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I suppose Orson could be changed so a quoted
   name is secret if the first character after the double quote is an upper
   case Roman letter. That way a name like <i>"</i>Secret<i>"</i>
   would be a secret quoted name. However, that doesn&rsquo;t solve the
   problem, since there would still be no way to make something like
   <i>"</i>+<i>"</i> be a secret name.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An early version of Orson used backslashes to
   notate secret names, so \<i>secret</i> was a secret plain name, and
   \<i>"</i>secret<i>"</i> was a secret quoted name. This was hard to
   read and write, especially for programs with many secret names, so I changed
   it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I personally use quoted names only for
   operators (like <i>"</i>+<i>"</i>) and for constants in
   enumerations (like <i>"</i>unexpected&nbsp;value<i>"</i>). I
   haven&rsquo;t found a situation yet where these should be secret.
  </p>
  <p align="justify">
   <b>Q.</b> If names that start with capital letters are secret names,
   then how can I write a proper name that&rsquo;s not a secret name?
  </p>
  <p align="justify">
   <b>A.</b> You could use lower case letters, as in
   <i>johnSmith,</i> or you could use a quoted name, as in
   <i>"</i>John&nbsp;Smith<i>".</i> Maybe you could write
   <i>mrJohnSmith</i> if Smith thinks he&rsquo;s being insulted otherwise.
   However, maybe he&rsquo;d also be insulted if he knew you&rsquo;re
   representing him as a data structure that has so little state information.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This reminds me of the (apocryphal?) story
   about why early computer printers used only upper case letters, even though
   everyone knew lower case letters were easier to read. The reason is that you
   can&rsquo;t spell <i>God</i> correctly with lower case letters. I
   don&rsquo;t have a good answer for that, except to say that it seems
   presumptuous to write a program with <i>God</i> in it. John
   Updike&rsquo;s novel <i>Roger&rsquo;s Version</i>
   <a href="#upd1986">
    [<small>UPD</small> 1986]
   </a>
   discusses such a program in detail. It even includes Lisp code.
  </p>
  <hr />
  <a name="types">
  </a>
  <p>
   <b>12. Questions about types.</b>
  </p>
  <p align="justify">
   <b>Q.</b> In Orson, types have types. Doesn&rsquo;t that lead to
   contradictions or paradoxes?
  </p>
  <p align="justify">
   <b>A.</b> There are paradoxes in set theory that result from having
   sets of sets. Perhaps the best known is <i>Russell&rsquo;s paradox</i>
   <a href="#ruc1982">
    [<small>RUC</small> 1982],
   </a>
   where the members of a set <i>S</i> are said to be all sets that are
   not members of themselves. Is <i>S</i> a member of itself? If it is,
   then it isn&rsquo;t. If it isn&rsquo;t, then it is.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mathematically, Orson types are sets of
   objects, and Orson types can have types. It&rsquo;s therefore tempting to
   suppose you could state Russell&rsquo;s paradox in Orson&rsquo;s type
   system. I don&rsquo;t think this is possible, because (among other things)
   it isn&rsquo;t strong enough to express <small>NOT</small>. You
   can&rsquo;t make a type <i>S</i> that describes all objects which are
   not of the type <i>S.</i> At least I <i>think</i> you can&rsquo;t.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;d be happy to hear from anyone who
   can prove that Orson&rsquo;s type system leads to a paradox, but I probably
   won&rsquo;t understand your proof. I also won&rsquo;t change Orson&rsquo;s
   type system to eliminate the paradox, unless it&rsquo;s easy to make the
   change, or unless your proof breaks something important.
  </p>
  <p align="justify">
   <b>Q.</b> Can a tuple contain a pointer to itself?
  </p>
  <p align="justify">
   <b>A.</b> Yes. There are at least two ways to write the type of such a
   tuple. For example, both of the following code fragments bind
   <i>node</i> to the type of a node in a linear chain of tuples. (I call
   them <i>chains</i> because Orson provides objects called
   <i>lists</i> that are different from these.)
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p>
       <i>link</i>&nbsp;:&#8722;&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;
       <br />
       <i>node</i>&nbsp;:&#8722;&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i></font>(<b>tuple</b>&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><i>string</i>&nbsp;<i>name</i>,&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<i>link</i>&nbsp;<i>next</i>)
      </p>
     </td>
     <td>
      <p>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </p>
     </td>
     <td>
      <p>
       &nbsp;
       <br />
       <i>node</i>&nbsp;:&#8722;&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i></font>(<b>tuple</b>&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><i>string</i>&nbsp;<i>name</i>,&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;<i>next</i>)
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <p align="justify">
   You can even have a form that returns the type of such a chain. For example,
   the form <i>chain</i> returns the type of a node in a linear chain of
   tuples. Each tuple contains an object whose type is <i>base.</i>
  </p>
  <blockquote>
   <p>
    <i>chain</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>(<b>form</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>base</i>)&nbsp;<b>type</b>&nbsp;<i>tup</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>(</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b></font><i>node</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i></font>(<b>tuple</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i>(<b>t</b></font><i>base</i>&nbsp;<i>name</i>,&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;<i>next</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((</font><b>do</b>&nbsp;<i>node</i>))
   </p>
  </blockquote>
  <p align="justify">
   For example, <i>chain</i>(<b>var</b>&nbsp;<i>int</i>) returns
   the type of a node in a linear chain of tuples, each of which contains an
   integer variable.
  </p>
  <p align="justify">
   <b>Q.</b> The equate
   [10]&nbsp;<i>char</i>&nbsp;<i>tc</i>&nbsp;:&#8722;&nbsp;''ten&nbsp;chars''
   gives me an error. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> It&rsquo;s because the string ''ten&nbsp;chars'' has the
   type <i>string</i> (which is bound to
   <b>row</b>&nbsp;<i>char</i>0), and the equate expects an array of
   type [10]&nbsp;<i>char,</i> a different type. Also, your array type
   asks for an array of ten <i>char</i>1&rsquo;s (each 32 bits) but but
   there are ten <i>char</i>0&rsquo;s in your string (each 8 bits). You
   get two different kinds of characters because Orson uses the
   <small>UTF</small>-8 encoding for strings
   <a href="#uni2006">
    [<small>UNI</small> 2006].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You might rewrite the equate as
   <i>string</i>&nbsp;<i>tc</i>&nbsp;:&#8722;&nbsp;''ten&nbsp;chars''.
   It doesn&rsquo;t give you the array that you wanted, but a string, which
   might be just as good, since you can index it to obtain individual
   characters. For example, <i>tc</i>[0] returns the character 't'.
  </p>
  <p align="justify">
   <b>Q.</b> Why can&rsquo;t I pass <i>nil</i> to a generic form? I
   wrote something like this:
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b></font>...)
   </p>
  </blockquote>
  <p align="justify">
   When I call <i>foo</i>(<i>nil</i>), I get an error. My form
   expects a <i>row</i> pointer as an argument, and I thought
   <i>nil</i>&rsquo;s type was a subtype of any <i>row</i> pointer
   type.
  </p>
  <p align="justify">
   <b>A.</b> The type of <i>nil</i> is <i>null,</i> which is
   indeed a subtype of any pointer type, including any <i>row</i> pointer
   type. However, since you wrote a generic form that binds <i>b,</i>
   Orson thinks you want to do something with the base type of the pointer
   <i>p.</i> The problem is that <i>null</i> doesn&rsquo;t have a
   base type, so your form can&rsquo;t accept <i>nil</i> as an argument.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are several things you might do. One is
   to write a form with two members: one to handle <i>null</i> pointers
   and another to handle everything else. Maybe the one that handles
   <i>null</i> pointers should report an error.
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>form</b>&nbsp;(<i>null</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>f</b></font>...),&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>gf</b></font>...))
   </p>
  </blockquote>
  <p align="justify">
   Another is to put the <b>row</b> prefix in a different place, and then
   use an <i>if</i> clause inside the form to test if you have
   <i>nil</i> or not. You must now call <i>base</i>(<i>p</i>)
   explicitly to get <i>p</i>&rsquo;s base type. I tested if
   <i>pType</i> was <i>null,</i> instead of testing if <i>p</i>
   equals <i>nil,</i> so the test is done during transformation.
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<b>row</b>&nbsp;<i>exe</i>&nbsp;<i>pType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>g</b></font><b>form</b>&nbsp;(<i>pType</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b></font>(<b>if</b>&nbsp;<i>pType</i>&nbsp;&#8838;&nbsp;<i>null</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b>(</font><b>then</b>&nbsp;...&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b>(</font><b>else</b>&nbsp;...))
   </p>
  </blockquote>
  <p align="justify">
   Still another is to keep the original definition of <i>foo,</i> but
   cast <i>nil</i> to another pointer type before you pass it. For
   example, you could write
   <i>foo</i>(<i>nil</i>{<b>row</b>&nbsp;<i>void</i>}). You
   can even arrange for Orson to do this automatically, like so:
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>form</b>&nbsp;(<i>null</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>f</b></font><i>foo</i>(<i>nil</i>{<b>row</b>&nbsp;<i>void</i>})),&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>gf</b></font>...))
   </p>
  </blockquote>
  <p align="justify">
   All of these are just kludges to get around <i>null</i>&rsquo;s lack of
   a base type.
  </p>
  <p align="justify">
   <b>Q.</b> So why doesn&rsquo;t <i>null</i> have a base type? Why
   couldn&rsquo;t its base type be <i>void</i>?
  </p>
  <p align="justify">
   <b>A.</b> The type <i>null</i> can&rsquo;t have a base type,
   because <i>nil</i> references no object, and the lack of an object
   shouldn&rsquo;t have a type. (What type is a unicorn?) The base type of
   <i>null</i> can&rsquo;t be <i>void</i> because <i>void</i> is
   the type of an object, namely <i>skip.</i> If <i>null</i> had the
   base type <i>void,</i> then maybe <i>nil</i> would reference
   <i>skip,</i> and you could dereference it. That shouldn&rsquo;t be
   possible.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When designing a programming language,
   it&rsquo;s tempting to pick some object with hardly a meaning, like
   <i>void,</i> and then use it everywhere to plug semantic holes. Common
   Lisp uses its <tt>nil</tt> object that way, and C uses its
   <tt>void</tt> type that way too. I tried not to do things like that in
   Orson.
  </p>
  <hr />
  <a name="current">
  </a>
  <p>
   <b>13. Questions about the current implementation of Orson.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Your Orson compiler doesn&rsquo;t follow the
   &lsquo;&lsquo;Endian Pill C Coding Standard,&rsquo;&rsquo; which says that
   only the first four characters of names are significant. Because of this, I
   can&rsquo;t run Orson on my <small>IBM</small> 650. (Insert your
   favorite C coding standard and your favorite retro computer.)
  </p>
  <p align="justify">
   <b>A.</b> It&rsquo;s worse than you think. The Orson compiler has lots
   of non-portable C code in it. It assumes pointers are totally ordered, even
   if they don&rsquo;t point into the same array. It uses lots of
   G<small>NU</small> extensions, and it translates Orson to C code that
   also uses lots of G<small>NU</small> extensions
   <a href="#sta2008">
    [<small>STA</small> 2008].
   </a>
   Despite that, it seems to work on every computer I&rsquo;ve tried, except on
   those without executable stacks (there&rsquo;s a question about that later).
   I&rsquo;m sorry it doesn&rsquo;t work on your 1956 computer.
  </p>
  <p align="justify">
   <b>Q.</b> Is there a version of Orson that works under Windows? (Insert
   your favorite for-profit operating system.)
  </p>
  <p align="justify">
   <b>A.</b> At present, Orson runs only on Unix-like operating systems,
   such as G<small>NU</small>/Linux. An old, incomplete version of Orson
   ran successfully under Sun&rsquo;s Solaris, many years ago. I don&rsquo;t
   know if the current version runs under whatever operating system Sun uses
   now, as I no longer have access to Sun hardware. I also don&rsquo;t know how
   hard it would be to make Orson work under another system.
  </p>
  <p align="justify">
   <b>Q.</b> Can your compiler translate Orson to dialects of C other than
   just G<small>NU</small> C? Can it translate to <small>ANSI</small>
   C? (Insert your favorite C dialect.)
  </p>
  <p align="justify">
   <b>A.</b> No. I have no plans to make Orson produce
   <small>ANSI</small> C code. Sorry. Implementing the compiler as a
   G<small>NU</small> C translator was the easiest way to get it running.
   C programs produced by the translator depend on features of
   G<small>NU</small> C that may not be in other versions of C. They
   include arbitrary length names, hexadecimal floats, nested functions,
   statement expressions, and zero length arrays. Maybe this list is
   incomplete.
  </p>
  <p align="justify">
   <b>Q.</b> Is there an Orson compiler that produces machine code
   directly, instead of producing <small>GCC</small> code and then
   compiling it?
  </p>
  <p align="justify">
   <b>A.</b> I don&rsquo;t have one. One way to make one would be to write
   an Orson front end for <small>GCC</small>. This would be better than
   trying to make Orson produce <small>ANSI</small> C. There are already
   similar front ends for other languages, such as Ada, Fortran, Objective C,
   and Pascal. I don&rsquo;t know enough about <small>GCC</small>&rsquo;s
   internals to do this myself. Is anyone interested?
  </p>
  <p align="justify">
   <b>Q.</b> I tried to compile an Orson program, but I got an error
   message that I don&rsquo;t understand. The compiler just stopped and said
   <tt>Orson:</tt>&nbsp;<tt>Got</tt>&nbsp;<tt>[Nil]</tt>&nbsp;<tt>in</tt>&nbsp;<tt>evaluate!</tt>
   What does it mean?
  </p>
  <p align="justify">
   <b>A.</b> It means you found a bug in the Orson compiler. Sorry. Any
   message that ends in an exclamation mark means Orson has detected a bug in
   itself. After it detects the bug, it immediately halts without compiling
   your program.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I might try to fix the bug, if you send me
   the program that caused it. Be sure to tell me the version of the compiler
   you&rsquo;re using: you can find that out by typing
   <tt>orson</tt>&nbsp;<tt>-v</tt>. Also tell me if you&rsquo;re
   using a modified version of the prelude, etc.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Better yet, fix the bug yourself. Then tell
   me and everyone else how you did it. You&rsquo;ve got the source code.
  </p>
  <p align="justify">
   <b>Q.</b> I looked at the standard prelude. It uses funny things like
   ?<i>nil</i> and ?<i>intAdd</i>(<i>l,</i>&nbsp;<i>r</i>).
   What are they? How can I use them in my programs?
  </p>
  <p align="justify">
   <b>A.</b> A name that starts with a question mark is a
   <i>hook.</i> (Question marks are shaped like hooks.) When Orson
   encounters a hook, it executes a corresponding C code fragment in the
   compiler. As a result, a hook can do anything that C can do, even things
   that are difficult or impossible in Orson.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You&rsquo;re not allowed to use hooks, unless
   they appear in an Orson source file with an <tt>.op</tt> suffix. Even
   then, it&rsquo;s a bad idea, unless you know what you&rsquo;re doing. Hooks
   are intended to be used only by the implementers and maintainers of the
   Orson compiler and library. (Right now that&rsquo;s only me.) You can crash
   the compiler by giving bad arguments to certain hooks, so they should be
   used only inside methods that verify their arguments for them. Also, future
   versions of Orson may introduce new hooks, may eliminate old hooks, or may
   change how old hooks work.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t your Orson compiler provide a 64-bit
   integer type, <i>int</i>3?
  </p>
  <p align="justify">
   <b>A.</b> Because the present compiler was developed on 32-bit
   computers, mostly with Intel <i>x</i>86 processors. There&rsquo;s no
   reason it couldn&rsquo;t provide <i>int</i>3, since the compiler
   translates Orson programs to <small>GCC</small>, which supports 64-bit
   integers. The problem is that information about simple types appears in many
   different places throughout the present compiler. To provide
   <i>int</i>3, I&rsquo;d have to find all those places and make small
   changes to them. It wouldn&rsquo;t be hard, just tedious.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I shouldn&rsquo;t have designed the compiler
   that way. I should have kept all information about simple types in some kind
   of central repository. If I ever rewrite the Orson compiler (maybe in Orson
   itself) I may implement such a thing.
  </p>
  <p align="justify">
   <b>Q.</b> I can&rsquo;t compile the Orson compiler on my Apple
   Macintosh computer. I can&rsquo;t compile <small>GCC</small> code
   produced by the Orson compiler, either. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> In 2006, Apple i686 Darwin stopped supporting nested
   functions in G<small>NU</small> C programs. Unfortunately, significant
   parts of the Orson compiler are written in continuation passing style
   (<small>CPS</small>), which is most easily simulated in
   <small>GCC</small> with nested functions. G<small>CC</small> code
   produced by the Orson compiler might also use nested functions, even if
   it&rsquo;s not written in <small>CPS</small>.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nested functions were eliminated because the
   <small>GCC</small> compiler implements them using
   <i>trampolines:</i> code fragments that are written to the stack for
   later execution. However, putting executable code on the stack via a buffer
   overflow is also a favorite technique of crackers for gaining illegal access
   to a computer. Apple was apparently trying to prevent such access by making
   it impossible to execute code on the stack.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As far as I know, the Orson compiler now
   works on current Apple systems, and so do the <small>GCC</small>
   programs that it produces. It may be necessary to add extra options to the
   <small>GCC</small> command to make those things happen. I don&rsquo;t
   follow Apple much any more, so I don&rsquo;t necessarily know what those
   things are. I also don&rsquo;t know if Apple now supports an executable
   stack, or if they fixed the problem in some other way.
  </p>
  <hr />
  <a name="misc">
  </a>
  <p>
   <b>14. Miscellaneous questions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson have a <i>return</i> statement?
  </p>
  <p align="justify">
   <b>A.</b> Orson is an expression language, so it doesn&rsquo;t have
   statements at all. I&rsquo;ll assume you mean an expression that, when
   executed, makes a procedure stop and return an object. If you have
   <i>return</i>&rsquo;s, then every path through a procedure body must
   end with one. At least it does if the procedure returns an object.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java compilers try to enumerate all such
   paths, complaining if they find one that doesn&rsquo;t end with a
   <tt>return</tt> statement
   <a href="#gos1996">
    [<small>GOS</small> 1996].
   </a>
   Unfortunately, Turing says it&rsquo;s impossible to do this. As a result,
   Java sometimes complains needlessly, and you must add dummy
   <tt>return</tt> statements to shut it up.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some C compilers, however, apparently
   don&rsquo;t care. They say that a procedure returns an unspecified object if
   it stops without executing a <tt>return</tt> statement. I&rsquo;m not
   sure if this is better than Java, or worse, but it has the virtue of being
   simpler.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Neither of these alternatives is correct, but
   since Orson doesn&rsquo;t have <i>return</i>&rsquo;s, the problem goes
   away. An Orson procedure just returns the object to which its body
   evaluates. If the body has the wrong type, then this is detected by
   Orson&rsquo;s type system. Since the compiler has to check types anyway, it
   requires no extra work. This is yet another reason why expression languages
   are better than statement languages.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are other problems with
   <i>return</i>&rsquo;s, too. For example, what happens if a
   <i>return</i> appears in a form body? Does it terminate the form during
   transformation, or does it transform to an expression that terminates a
   procedure during execution? Should there be two kinds of
   <i>return</i>&rsquo;s, one that terminates forms during transformation,
   and another that terminates procedures during execution? What happens if a
   <i>return</i> appears outside a form or procedure body? If there are no
   <i>return</i>&rsquo;s, then I don&rsquo;t have to answer these
   questions.
  </p>
  <hr />
  <a name="references">
  </a>
  <p align="center">
   <b>References</b>
  </p>
  <table cellpadding="0" cellspacing="0">
   <tr valign="top">
    <td>
     <p>
      <a name="and1991">
      </a>
      [<small>AND</small>&nbsp;1991]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      David P. Anderson, Ron Kuivila. &lsquo;&lsquo;Formula: A Programming
      Language for Expressive Computer Music.&rsquo;&rsquo;
      <i>I<small>EEE</small> Computer.</i> Volume 24, Number 7, July
      1991. Pages 12&#8211;21.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ans1986">
      </a>
      [<small>ANS</small>&nbsp;1986]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      American National Standards Institute. &lsquo;&lsquo;American National
      Standard Code for Information Interchange.&rsquo;&rsquo;
      <small>ANSI</small> X3.4&#8211;1986.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="des1967">
      </a>
      [<small>DES</small>&nbsp;1967]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Ralph De Sola. <i>Abbreviations Dictionary.</i> Meredith Press. New
      York, New York. 1967. Page 104.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="hen1979">
      </a>
      [<small>HEN</small>&nbsp;1979]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Bill Henkin. <i>The Rocky Horror Picture Show Book.</i> Hawthorn
      Books. New York, New York. 1979.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="hud1992">
      </a>
      [<small>HUD</small>&nbsp;1992]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Paul Hudak, Simon Peyton Jones, Philip Wadler, editors.
      &lsquo;&lsquo;Report on the Programming Language Haskell.&rsquo;&rsquo;
      <i>A<small>CM</small> S<small>IGPLAN</small> Notices.</i>
      Volume 27, Number 5, May 1992. Section R.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="jen1974">
      </a>
      [<small>JEN</small>&nbsp;1974]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Kathleen Jensen, Niklaus Wirth. <i>P<small>ASCAL</small> User
      Manual and Report.</i> Springer-Verlag. Berlin, Germany. 1974.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ker1988">
      </a>
      [<small>KER</small>&nbsp;1988]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Brian W. Kernighan, Dennis M. Ritchie. <i>The C Programming
      Language.</i> Second Edition. Prentice-Hall. Upper Saddle River, New
      Jersey. 1988.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="knu1975">
      </a>
      [<small>KNU</small>&nbsp;1975]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Donald E. Knuth. <i>The Art of Computer Programming. Fundamental
      Algorithms.</i> Second Edition. Addison-Wesley. Reading,
      Massachusetts. 1975. Pages 234&#8211;238.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="gos1996">
      </a>
      [<small>GOS</small>&nbsp;1996]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      James Gosling, Bill Joy, Guy Steele. <i>The Java Language
      Specification.</i> Addison-Wesley. Reading, Massachusetts. 1996.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="mcc1987">
      </a>
      [<small>MCC</small>&nbsp;1987]
     </p>
    </td>
    <td>
     <p align="justify">
      Robert McCrum, William Cran, Robert MacNeil. <i>The Story of
      English.</i> Elizabeth Sifton Books. Viking Penguin, Inc. New York,
      New York. 1987. Page 19.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="moe2014">
      </a>
      [<small>MOE</small>&nbsp;2014]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      James B. Moen. &lsquo;&lsquo;The Revised&#8315;&#185; Report on the
      Algorithmic Language Orson.&rsquo;&rsquo; Unpublished technical report.
      2014.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="moo2001">
      </a>
      [<small>MOO</small>&nbsp;2001]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Glenn Moody. <i>Rebel Code.</i> Perseus Publishing. Cambridge,
      Massachusetts. 2001. Page 115.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="okr1992">
      </a>
      [<small>OKR</small>&nbsp;1992]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Marc Okrand. <i>The Klingon Dictionary.</i> Pocket Books. New York,
      New York. 1992.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ruc1982">
      </a>
      [<small>RUC</small>&nbsp;1982]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Rudy Rucker. <i>Infinity and the Mind.</i> Birkhauser. Boston,
      Massachusetts. 1982. Page 193.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="sam1969">
      </a>
      [<small>SAM</small>&nbsp;1969]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Jean E. Sammet. <i>Programming Languages: History and
      Fundamentals.</i> Prentice-Hall. Englewood Cliffs, New Jersey. 1969.
      Pages 388&#8211;400.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="sta2008">
      </a>
      [<small>STA</small>&nbsp;2008]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Richard M. Stallman, the G<small>CC</small> Developer Community.
      &lsquo;&lsquo;Using and Porting the G<small>NU</small> Compiler
      Collection.&rsquo;&rsquo; Free Software Foundation. Boston,
      Massachusetts. 2008.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ste1990">
      </a>
      [<small>STE</small>&nbsp;1990]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Guy L. Steele Jr. <i>Common Lisp: The Language.</i> Second Edition.
      Digital Press. Bedford, Massachusetts. 1990.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="stv2005">
      </a>
      [<small>STV</small>&nbsp;2005]
     </p>
    </td>
    <td>
     <p align="justify">
      W. Richard Stevens. Stephen A. Rago. <i>Advanced Programming in the
      U<small>NIX</small> Environment.</i> Second Edition.
      Addison-Wesley. Upper Saddle River, New Jersey. 2005. Chapters
      11&#8211;12.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="upd1986">
      </a>
      [<small>UPD</small>&nbsp;1986]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      John Updike. <i>Roger&rsquo;s Version.</i> Ballantine Books. New
      York, New York. 1986.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="uni2006">
      </a>
      [<small>UNI</small>&nbsp;2006]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      The Unicode Consortium. <i>The Unicode Standard, Version 5.0.</i>
      Fifth Edition. Addison-Wesley Professional. Reading, Massachusetts. 2006.
     </p>
    </td>
   </tr>
  </table>
 </body>
</html>
