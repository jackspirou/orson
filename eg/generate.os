!
!  EG/GENERATE. Generate strings.
!
!  Copyright © 2014 James B. Moen.
!
!  This  program is free  software: you  can redistribute  it and/or  modify it
!  under the terms  of the GNU General Public License as  published by the Free
!  Software Foundation,  either version 3 of  the License, or  (at your option)
!  any later version.
!
!  This program is distributed in the  hope that it will be useful, but WITHOUT
!  ANY  WARRANTY;  without even  the  implied  warranty  of MERCHANTABILITY  or
!  FITNESS FOR  A PARTICULAR PURPOSE.  See  the GNU General  Public License for
!  more details.
!
!  You should have received a copy of the GNU General Public License along with
!  this program.  If not, see <http://www.gnu.org/licenses/>.
!

(prog

!  GENERATE. Generate MAX COUNT strings from a grammar, writing them to OUTPUT,
!  and starting each one on a new line. Each string is at most MAX LENGTH chars
!  long, and is generated by recursively descending through the grammar at most
!  MAX DEPTH levels deep. Calls to FAIL indicate things that shouldn't happen.

  generate :−
   (proc () void:
    (with
      int        "01⋯1"    :− high(int)       !  Mask to clear the high bit.
      var krig() generator :− makeKrig(seed)  !  Random INT generator.
      var int    length                       !  Number of CHARs in TEMP.
      var stream temp                         !  Holds the generated string.

!  GENERATED. Try to generate a string, and write it to TEMP. If the generation
!  fails then try again. If TEMP holds between MIN LENGTH and MAX LENGTH chars,
!  then copy TEMP to output, and stop trying. Otherwise try again.

      generated :−
       (form () void:
        (while
          length := 0
          reset(temp, 0)
          (if (catch generating(1, makeStart()))
           then true
           else if minLength ≤ length ≤ maxLength
                then reset(temp, 0)
                     (in length
                      do write(read(temp)))
                     writeln()
                     false
                else true)))

!  RANDOM. Return a random nonnegative INT between 0 and MAX − 1.

      random :−
       (proc (int max) int:
        ("01⋯1" & next(generator)) mod max)

!  GENERATING. Do all the work for GENERATE, by recursively generating a string
!  from THIS. DEPTH counts how many recursive calls we've made.

      generating :−
       (proc (int depth, ref codon this) void:
        (with
          var ref codon this :− (past this)

!  GENERATING AND. Generate a string from a conjunction. We generate substrings
!  from each of the conjuncts and concatenate them.

          generatingAnd :−
           (form () void:
            (while this ≠ nil
             do generating(depth + 1, this.car)
                this := this.cdr))

!  GENERATING OR. Generate a string from a disjunction. Suppose the disjunction
!  is S₁ | S₂ ... | Sⱼ.  Every subscripted S has a corresponding subscripted W,
!  its WIDTH. We compute a random number R greater than or equal to 0, but less
!  than the sum of the subscripted W's. We then use R to select Wᵢ, as shown in
!  the illustration (in which W₃ is selected).
!
!         ┌──────┬──────────┬────────┬───────────────┬─     ─┬────────┐
!         │  W₀  │    W₁    │   W₂   │       W₃      │  ⋅⋅⋅  │   Wⱼ   │
!         └──────┴──────────┴────────┴───────────────┴─     ─┴────────┘
!         │←                 R                 →│
!
!  After we select Wᵢ, we generate strings from Sᵢ. Before we do that, however,
!  we increment all the W's except Wᵢ by WIDENING (avoiding overflow), so Sᵢ is
!  less likely to be selected again soon.

          generatingOr :−
           (form () void:
            (with
              var ref codon choice
              var ref codon chosen
              var int width
             do width := 0
                choice := this
                (while choice ≠ nil
                 do width += choice.width
                    choice := choice.cdr)
                width := random(width)
                choice := this
                (while
                 (if choice = nil
                  then fail(''Could not choose disjunct.'')
                  else if width −= choice.width
                          width < 0
                       then chosen := choice
                            false
                       else choice := choice.cdr
                            true))
                choice := this
                (while choice ≠ nil
                 do (if choice ≠ chosen
                     then choice.width := "01⋯1" & (choice.width + widening))
                    choice := choice.cdr)
                generating(depth + 1, chosen.car)))

!  GENERATING NAME. Generate a string from a nonterminal. We get the DEFinition
!  of THIS from the hash table and generate strings from that.

          generatingName :−
           (form () void:
            (if this.def = nil
             then fail(''Undefined nonterminal '%s'.'': this.chars)
             else generating(depth + 1, this.def)))

!  GENERATING RANGE. Generate a string from a range. First generate MIN strings
!  from the BASE of THIS. Then generate a random number of strings from BASE to
!  end up with at most MAX of them.

          generatingRange :−
           (form () void:
            (in this.min
             do generating(depth + 1, this.base))
            (in random(this.max − this.min + 1)
             do generating(depth + 1, this.base)))

!  GENERATING STRING. Generate a string from a terminal. This is the only place
!  where we write to TEMP so we check its LENGTH here. If its LENGTH has become
!  too long, then we throw TRUE to GENERATED, indicating generation has failed.

          generatingString :−
           (form () void:
            (if length += count(this.chars)
                length > maxLength
             then throw(true)
             else write(temp, this.chars)))

!  This is GENERATING's body. If the recursive DEPTH is too deep, then we throw
!  TRUE to GENERATED, indicating generation has failed.  Otherwise, we dispatch
!  on the TAG slot of THIS.

         do (if this = nil
             then fail(''Generator got NIL.'')
             else if depth > maxDepth
                  then throw(true)
                  else debug(depth, this)
                       (case this.tag
                        of andTag: generatingAnd()
                            orTag: generatingOr()
                          nameTag: generatingName()
                         rangeTag: generatingRange()
                        stringTag: generatingString()
                             none: fail(''Generator got unknown object.'')))))

!  This is GENERATE's body.  Open the TEMP file, generate HOW MANY strings, and
!  close the TEMP file again.

     do (if ¬ open(temp)
         then fail(''Cannot open temporary file.''))
        (in howMany
         do generated())
        (if ¬ close(temp)
         then fail(''Cannot close temporary file.''))))
)
